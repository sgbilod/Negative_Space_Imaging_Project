{
  "file_path": "c:\\Users\\sgbil\\OneDrive\\Desktop\\Negative_Space_Imaging_Project\\.venv\\Lib\\site-packages\\numpy\\polynomial\\laguerre.py",
  "classes": [
    {
      "name": "Laguerre",
      "docstring": "A Laguerre series class.\n\nThe Laguerre class provides the standard Python numerical methods\n'+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the\nattributes and methods listed below.\n\nParameters\n----------\ncoef : array_like\n    Laguerre coefficients in order of increasing degree, i.e,\n    ``(1, 2, 3)`` gives ``1*L_0(x) + 2*L_1(X) + 3*L_2(x)``.\ndomain : (2,) array_like, optional\n    Domain to use. The interval ``[domain[0], domain[1]]`` is mapped\n    to the interval ``[window[0], window[1]]`` by shifting and scaling.\n    The default value is [0., 1.].\nwindow : (2,) array_like, optional\n    Window, see `domain` for its use. The default value is [0., 1.].\nsymbol : str, optional\n    Symbol used to represent the independent variable in string\n    representations of the polynomial expression, e.g. for printing.\n    The symbol must be a valid Python identifier. Default value is 'x'.\n\n    .. versionadded:: 1.24",
      "methods": []
    }
  ],
  "functions": [
    {
      "name": "poly2lag",
      "docstring": "poly2lag(pol)\n\nConvert a polynomial to a Laguerre series.\n\nConvert an array representing the coefficients of a polynomial (relative\nto the \"standard\" basis) ordered from lowest degree to highest, to an\narray of the coefficients of the equivalent Laguerre series, ordered\nfrom lowest to highest degree.\n\nParameters\n----------\npol : array_like\n    1-D array containing the polynomial coefficients\n\nReturns\n-------\nc : ndarray\n    1-D array containing the coefficients of the equivalent Laguerre\n    series.\n\nSee Also\n--------\nlag2poly\n\nNotes\n-----\nThe easy way to do conversions between polynomial basis sets\nis to use the convert method of a class instance.\n\nExamples\n--------\n>>> import numpy as np\n>>> from numpy.polynomial.laguerre import poly2lag\n>>> poly2lag(np.arange(4))\narray([ 23., -63.,  58., -18.])"
    },
    {
      "name": "lag2poly",
      "docstring": "Convert a Laguerre series to a polynomial.\n\nConvert an array representing the coefficients of a Laguerre series,\nordered from lowest degree to highest, to an array of the coefficients\nof the equivalent polynomial (relative to the \"standard\" basis) ordered\nfrom lowest to highest degree.\n\nParameters\n----------\nc : array_like\n    1-D array containing the Laguerre series coefficients, ordered\n    from lowest order term to highest.\n\nReturns\n-------\npol : ndarray\n    1-D array containing the coefficients of the equivalent polynomial\n    (relative to the \"standard\" basis) ordered from lowest order term\n    to highest.\n\nSee Also\n--------\npoly2lag\n\nNotes\n-----\nThe easy way to do conversions between polynomial basis sets\nis to use the convert method of a class instance.\n\nExamples\n--------\n>>> from numpy.polynomial.laguerre import lag2poly\n>>> lag2poly([ 23., -63.,  58., -18.])\narray([0., 1., 2., 3.])"
    },
    {
      "name": "lagline",
      "docstring": "Laguerre series whose graph is a straight line.\n\nParameters\n----------\noff, scl : scalars\n    The specified line is given by ``off + scl*x``.\n\nReturns\n-------\ny : ndarray\n    This module's representation of the Laguerre series for\n    ``off + scl*x``.\n\nSee Also\n--------\nnumpy.polynomial.polynomial.polyline\nnumpy.polynomial.chebyshev.chebline\nnumpy.polynomial.legendre.legline\nnumpy.polynomial.hermite.hermline\nnumpy.polynomial.hermite_e.hermeline\n\nExamples\n--------\n>>> from numpy.polynomial.laguerre import lagline, lagval\n>>> lagval(0,lagline(3, 2))\n3.0\n>>> lagval(1,lagline(3, 2))\n5.0"
    },
    {
      "name": "lagfromroots",
      "docstring": "Generate a Laguerre series with given roots.\n\nThe function returns the coefficients of the polynomial\n\n.. math:: p(x) = (x - r_0) * (x - r_1) * ... * (x - r_n),\n\nin Laguerre form, where the :math:`r_n` are the roots specified in `roots`.\nIf a zero has multiplicity n, then it must appear in `roots` n times.\nFor instance, if 2 is a root of multiplicity three and 3 is a root of\nmultiplicity 2, then `roots` looks something like [2, 2, 2, 3, 3]. The\nroots can appear in any order.\n\nIf the returned coefficients are `c`, then\n\n.. math:: p(x) = c_0 + c_1 * L_1(x) + ... +  c_n * L_n(x)\n\nThe coefficient of the last term is not generally 1 for monic\npolynomials in Laguerre form.\n\nParameters\n----------\nroots : array_like\n    Sequence containing the roots.\n\nReturns\n-------\nout : ndarray\n    1-D array of coefficients.  If all roots are real then `out` is a\n    real array, if some of the roots are complex, then `out` is complex\n    even if all the coefficients in the result are real (see Examples\n    below).\n\nSee Also\n--------\nnumpy.polynomial.polynomial.polyfromroots\nnumpy.polynomial.legendre.legfromroots\nnumpy.polynomial.chebyshev.chebfromroots\nnumpy.polynomial.hermite.hermfromroots\nnumpy.polynomial.hermite_e.hermefromroots\n\nExamples\n--------\n>>> from numpy.polynomial.laguerre import lagfromroots, lagval\n>>> coef = lagfromroots((-1, 0, 1))\n>>> lagval((-1, 0, 1), coef)\narray([0.,  0.,  0.])\n>>> coef = lagfromroots((-1j, 1j))\n>>> lagval((-1j, 1j), coef)\narray([0.+0.j, 0.+0.j])"
    },
    {
      "name": "lagadd",
      "docstring": "Add one Laguerre series to another.\n\nReturns the sum of two Laguerre series `c1` + `c2`.  The arguments\nare sequences of coefficients ordered from lowest order term to\nhighest, i.e., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.\n\nParameters\n----------\nc1, c2 : array_like\n    1-D arrays of Laguerre series coefficients ordered from low to\n    high.\n\nReturns\n-------\nout : ndarray\n    Array representing the Laguerre series of their sum.\n\nSee Also\n--------\nlagsub, lagmulx, lagmul, lagdiv, lagpow\n\nNotes\n-----\nUnlike multiplication, division, etc., the sum of two Laguerre series\nis a Laguerre series (without having to \"reproject\" the result onto\nthe basis set) so addition, just like that of \"standard\" polynomials,\nis simply \"component-wise.\"\n\nExamples\n--------\n>>> from numpy.polynomial.laguerre import lagadd\n>>> lagadd([1, 2, 3], [1, 2, 3, 4])\narray([2.,  4.,  6.,  4.])"
    },
    {
      "name": "lagsub",
      "docstring": "Subtract one Laguerre series from another.\n\nReturns the difference of two Laguerre series `c1` - `c2`.  The\nsequences of coefficients are from lowest order term to highest, i.e.,\n[1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.\n\nParameters\n----------\nc1, c2 : array_like\n    1-D arrays of Laguerre series coefficients ordered from low to\n    high.\n\nReturns\n-------\nout : ndarray\n    Of Laguerre series coefficients representing their difference.\n\nSee Also\n--------\nlagadd, lagmulx, lagmul, lagdiv, lagpow\n\nNotes\n-----\nUnlike multiplication, division, etc., the difference of two Laguerre\nseries is a Laguerre series (without having to \"reproject\" the result\nonto the basis set) so subtraction, just like that of \"standard\"\npolynomials, is simply \"component-wise.\"\n\nExamples\n--------\n>>> from numpy.polynomial.laguerre import lagsub\n>>> lagsub([1, 2, 3, 4], [1, 2, 3])\narray([0.,  0.,  0.,  4.])"
    },
    {
      "name": "lagmulx",
      "docstring": "Multiply a Laguerre series by x.\n\nMultiply the Laguerre series `c` by x, where x is the independent\nvariable.\n\n\nParameters\n----------\nc : array_like\n    1-D array of Laguerre series coefficients ordered from low to\n    high.\n\nReturns\n-------\nout : ndarray\n    Array representing the result of the multiplication.\n\nSee Also\n--------\nlagadd, lagsub, lagmul, lagdiv, lagpow\n\nNotes\n-----\nThe multiplication uses the recursion relationship for Laguerre\npolynomials in the form\n\n.. math::\n\n    xP_i(x) = (-(i + 1)*P_{i + 1}(x) + (2i + 1)P_{i}(x) - iP_{i - 1}(x))\n\nExamples\n--------\n>>> from numpy.polynomial.laguerre import lagmulx\n>>> lagmulx([1, 2, 3])\narray([-1.,  -1.,  11.,  -9.])"
    },
    {
      "name": "lagmul",
      "docstring": "Multiply one Laguerre series by another.\n\nReturns the product of two Laguerre series `c1` * `c2`.  The arguments\nare sequences of coefficients, from lowest order \"term\" to highest,\ne.g., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.\n\nParameters\n----------\nc1, c2 : array_like\n    1-D arrays of Laguerre series coefficients ordered from low to\n    high.\n\nReturns\n-------\nout : ndarray\n    Of Laguerre series coefficients representing their product.\n\nSee Also\n--------\nlagadd, lagsub, lagmulx, lagdiv, lagpow\n\nNotes\n-----\nIn general, the (polynomial) product of two C-series results in terms\nthat are not in the Laguerre polynomial basis set.  Thus, to express\nthe product as a Laguerre series, it is necessary to \"reproject\" the\nproduct onto said basis set, which may produce \"unintuitive\" (but\ncorrect) results; see Examples section below.\n\nExamples\n--------\n>>> from numpy.polynomial.laguerre import lagmul\n>>> lagmul([1, 2, 3], [0, 1, 2])\narray([  8., -13.,  38., -51.,  36.])"
    },
    {
      "name": "lagdiv",
      "docstring": "Divide one Laguerre series by another.\n\nReturns the quotient-with-remainder of two Laguerre series\n`c1` / `c2`.  The arguments are sequences of coefficients from lowest\norder \"term\" to highest, e.g., [1,2,3] represents the series\n``P_0 + 2*P_1 + 3*P_2``.\n\nParameters\n----------\nc1, c2 : array_like\n    1-D arrays of Laguerre series coefficients ordered from low to\n    high.\n\nReturns\n-------\n[quo, rem] : ndarrays\n    Of Laguerre series coefficients representing the quotient and\n    remainder.\n\nSee Also\n--------\nlagadd, lagsub, lagmulx, lagmul, lagpow\n\nNotes\n-----\nIn general, the (polynomial) division of one Laguerre series by another\nresults in quotient and remainder terms that are not in the Laguerre\npolynomial basis set.  Thus, to express these results as a Laguerre\nseries, it is necessary to \"reproject\" the results onto the Laguerre\nbasis set, which may produce \"unintuitive\" (but correct) results; see\nExamples section below.\n\nExamples\n--------\n>>> from numpy.polynomial.laguerre import lagdiv\n>>> lagdiv([  8., -13.,  38., -51.,  36.], [0, 1, 2])\n(array([1., 2., 3.]), array([0.]))\n>>> lagdiv([  9., -12.,  38., -51.,  36.], [0, 1, 2])\n(array([1., 2., 3.]), array([1., 1.]))"
    },
    {
      "name": "lagpow",
      "docstring": "Raise a Laguerre series to a power.\n\nReturns the Laguerre series `c` raised to the power `pow`. The\nargument `c` is a sequence of coefficients ordered from low to high.\ni.e., [1,2,3] is the series  ``P_0 + 2*P_1 + 3*P_2.``\n\nParameters\n----------\nc : array_like\n    1-D array of Laguerre series coefficients ordered from low to\n    high.\npow : integer\n    Power to which the series will be raised\nmaxpower : integer, optional\n    Maximum power allowed. This is mainly to limit growth of the series\n    to unmanageable size. Default is 16\n\nReturns\n-------\ncoef : ndarray\n    Laguerre series of power.\n\nSee Also\n--------\nlagadd, lagsub, lagmulx, lagmul, lagdiv\n\nExamples\n--------\n>>> from numpy.polynomial.laguerre import lagpow\n>>> lagpow([1, 2, 3], 2)\narray([ 14., -16.,  56., -72.,  54.])"
    },
    {
      "name": "lagder",
      "docstring": "Differentiate a Laguerre series.\n\nReturns the Laguerre series coefficients `c` differentiated `m` times\nalong `axis`.  At each iteration the result is multiplied by `scl` (the\nscaling factor is for use in a linear change of variable). The argument\n`c` is an array of coefficients from low to high degree along each\naxis, e.g., [1,2,3] represents the series ``1*L_0 + 2*L_1 + 3*L_2``\nwhile [[1,2],[1,2]] represents ``1*L_0(x)*L_0(y) + 1*L_1(x)*L_0(y) +\n2*L_0(x)*L_1(y) + 2*L_1(x)*L_1(y)`` if axis=0 is ``x`` and axis=1 is\n``y``.\n\nParameters\n----------\nc : array_like\n    Array of Laguerre series coefficients. If `c` is multidimensional\n    the different axis correspond to different variables with the\n    degree in each axis given by the corresponding index.\nm : int, optional\n    Number of derivatives taken, must be non-negative. (Default: 1)\nscl : scalar, optional\n    Each differentiation is multiplied by `scl`.  The end result is\n    multiplication by ``scl**m``.  This is for use in a linear change of\n    variable. (Default: 1)\naxis : int, optional\n    Axis over which the derivative is taken. (Default: 0).\n\nReturns\n-------\nder : ndarray\n    Laguerre series of the derivative.\n\nSee Also\n--------\nlagint\n\nNotes\n-----\nIn general, the result of differentiating a Laguerre series does not\nresemble the same operation on a power series. Thus the result of this\nfunction may be \"unintuitive,\" albeit correct; see Examples section\nbelow.\n\nExamples\n--------\n>>> from numpy.polynomial.laguerre import lagder\n>>> lagder([ 1.,  1.,  1., -3.])\narray([1.,  2.,  3.])\n>>> lagder([ 1.,  0.,  0., -4.,  3.], m=2)\narray([1.,  2.,  3.])"
    },
    {
      "name": "lagint",
      "docstring": "Integrate a Laguerre series.\n\nReturns the Laguerre series coefficients `c` integrated `m` times from\n`lbnd` along `axis`. At each iteration the resulting series is\n**multiplied** by `scl` and an integration constant, `k`, is added.\nThe scaling factor is for use in a linear change of variable.  (\"Buyer\nbeware\": note that, depending on what one is doing, one may want `scl`\nto be the reciprocal of what one might expect; for more information,\nsee the Notes section below.)  The argument `c` is an array of\ncoefficients from low to high degree along each axis, e.g., [1,2,3]\nrepresents the series ``L_0 + 2*L_1 + 3*L_2`` while [[1,2],[1,2]]\nrepresents ``1*L_0(x)*L_0(y) + 1*L_1(x)*L_0(y) + 2*L_0(x)*L_1(y) +\n2*L_1(x)*L_1(y)`` if axis=0 is ``x`` and axis=1 is ``y``.\n\n\nParameters\n----------\nc : array_like\n    Array of Laguerre series coefficients. If `c` is multidimensional\n    the different axis correspond to different variables with the\n    degree in each axis given by the corresponding index.\nm : int, optional\n    Order of integration, must be positive. (Default: 1)\nk : {[], list, scalar}, optional\n    Integration constant(s).  The value of the first integral at\n    ``lbnd`` is the first value in the list, the value of the second\n    integral at ``lbnd`` is the second value, etc.  If ``k == []`` (the\n    default), all constants are set to zero.  If ``m == 1``, a single\n    scalar can be given instead of a list.\nlbnd : scalar, optional\n    The lower bound of the integral. (Default: 0)\nscl : scalar, optional\n    Following each integration the result is *multiplied* by `scl`\n    before the integration constant is added. (Default: 1)\naxis : int, optional\n    Axis over which the integral is taken. (Default: 0).\n\nReturns\n-------\nS : ndarray\n    Laguerre series coefficients of the integral.\n\nRaises\n------\nValueError\n    If ``m < 0``, ``len(k) > m``, ``np.ndim(lbnd) != 0``, or\n    ``np.ndim(scl) != 0``.\n\nSee Also\n--------\nlagder\n\nNotes\n-----\nNote that the result of each integration is *multiplied* by `scl`.\nWhy is this important to note?  Say one is making a linear change of\nvariable :math:`u = ax + b` in an integral relative to `x`.  Then\n:math:`dx = du/a`, so one will need to set `scl` equal to\n:math:`1/a` - perhaps not what one would have first thought.\n\nAlso note that, in general, the result of integrating a C-series needs\nto be \"reprojected\" onto the C-series basis set.  Thus, typically,\nthe result of this function is \"unintuitive,\" albeit correct; see\nExamples section below.\n\nExamples\n--------\n>>> from numpy.polynomial.laguerre import lagint\n>>> lagint([1,2,3])\narray([ 1.,  1.,  1., -3.])\n>>> lagint([1,2,3], m=2)\narray([ 1.,  0.,  0., -4.,  3.])\n>>> lagint([1,2,3], k=1)\narray([ 2.,  1.,  1., -3.])\n>>> lagint([1,2,3], lbnd=-1)\narray([11.5,  1. ,  1. , -3. ])\n>>> lagint([1,2], m=2, k=[1,2], lbnd=-1)\narray([ 11.16666667,  -5.        ,  -3.        ,   2.        ]) # may vary"
    },
    {
      "name": "lagval",
      "docstring": "Evaluate a Laguerre series at points x.\n\nIf `c` is of length ``n + 1``, this function returns the value:\n\n.. math:: p(x) = c_0 * L_0(x) + c_1 * L_1(x) + ... + c_n * L_n(x)\n\nThe parameter `x` is converted to an array only if it is a tuple or a\nlist, otherwise it is treated as a scalar. In either case, either `x`\nor its elements must support multiplication and addition both with\nthemselves and with the elements of `c`.\n\nIf `c` is a 1-D array, then ``p(x)`` will have the same shape as `x`.  If\n`c` is multidimensional, then the shape of the result depends on the\nvalue of `tensor`. If `tensor` is true the shape will be c.shape[1:] +\nx.shape. If `tensor` is false the shape will be c.shape[1:]. Note that\nscalars have shape (,).\n\nTrailing zeros in the coefficients will be used in the evaluation, so\nthey should be avoided if efficiency is a concern.\n\nParameters\n----------\nx : array_like, compatible object\n    If `x` is a list or tuple, it is converted to an ndarray, otherwise\n    it is left unchanged and treated as a scalar. In either case, `x`\n    or its elements must support addition and multiplication with\n    themselves and with the elements of `c`.\nc : array_like\n    Array of coefficients ordered so that the coefficients for terms of\n    degree n are contained in c[n]. If `c` is multidimensional the\n    remaining indices enumerate multiple polynomials. In the two\n    dimensional case the coefficients may be thought of as stored in\n    the columns of `c`.\ntensor : boolean, optional\n    If True, the shape of the coefficient array is extended with ones\n    on the right, one for each dimension of `x`. Scalars have dimension 0\n    for this action. The result is that every column of coefficients in\n    `c` is evaluated for every element of `x`. If False, `x` is broadcast\n    over the columns of `c` for the evaluation.  This keyword is useful\n    when `c` is multidimensional. The default value is True.\n\nReturns\n-------\nvalues : ndarray, algebra_like\n    The shape of the return value is described above.\n\nSee Also\n--------\nlagval2d, laggrid2d, lagval3d, laggrid3d\n\nNotes\n-----\nThe evaluation uses Clenshaw recursion, aka synthetic division.\n\nExamples\n--------\n>>> from numpy.polynomial.laguerre import lagval\n>>> coef = [1, 2, 3]\n>>> lagval(1, coef)\n-0.5\n>>> lagval([[1, 2],[3, 4]], coef)\narray([[-0.5, -4. ],\n       [-4.5, -2. ]])"
    },
    {
      "name": "lagval2d",
      "docstring": "Evaluate a 2-D Laguerre series at points (x, y).\n\nThis function returns the values:\n\n.. math:: p(x,y) = \\sum_{i,j} c_{i,j} * L_i(x) * L_j(y)\n\nThe parameters `x` and `y` are converted to arrays only if they are\ntuples or a lists, otherwise they are treated as a scalars and they\nmust have the same shape after conversion. In either case, either `x`\nand `y` or their elements must support multiplication and addition both\nwith themselves and with the elements of `c`.\n\nIf `c` is a 1-D array a one is implicitly appended to its shape to make\nit 2-D. The shape of the result will be c.shape[2:] + x.shape.\n\nParameters\n----------\nx, y : array_like, compatible objects\n    The two dimensional series is evaluated at the points ``(x, y)``,\n    where `x` and `y` must have the same shape. If `x` or `y` is a list\n    or tuple, it is first converted to an ndarray, otherwise it is left\n    unchanged and if it isn't an ndarray it is treated as a scalar.\nc : array_like\n    Array of coefficients ordered so that the coefficient of the term\n    of multi-degree i,j is contained in ``c[i,j]``. If `c` has\n    dimension greater than two the remaining indices enumerate multiple\n    sets of coefficients.\n\nReturns\n-------\nvalues : ndarray, compatible object\n    The values of the two dimensional polynomial at points formed with\n    pairs of corresponding values from `x` and `y`.\n\nSee Also\n--------\nlagval, laggrid2d, lagval3d, laggrid3d\n\nExamples\n--------\n>>> from numpy.polynomial.laguerre import lagval2d\n>>> c = [[1, 2],[3, 4]]\n>>> lagval2d(1, 1, c)\n1.0"
    },
    {
      "name": "laggrid2d",
      "docstring": "Evaluate a 2-D Laguerre series on the Cartesian product of x and y.\n\nThis function returns the values:\n\n.. math:: p(a,b) = \\sum_{i,j} c_{i,j} * L_i(a) * L_j(b)\n\nwhere the points ``(a, b)`` consist of all pairs formed by taking\n`a` from `x` and `b` from `y`. The resulting points form a grid with\n`x` in the first dimension and `y` in the second.\n\nThe parameters `x` and `y` are converted to arrays only if they are\ntuples or a lists, otherwise they are treated as a scalars. In either\ncase, either `x` and `y` or their elements must support multiplication\nand addition both with themselves and with the elements of `c`.\n\nIf `c` has fewer than two dimensions, ones are implicitly appended to\nits shape to make it 2-D. The shape of the result will be c.shape[2:] +\nx.shape + y.shape.\n\nParameters\n----------\nx, y : array_like, compatible objects\n    The two dimensional series is evaluated at the points in the\n    Cartesian product of `x` and `y`.  If `x` or `y` is a list or\n    tuple, it is first converted to an ndarray, otherwise it is left\n    unchanged and, if it isn't an ndarray, it is treated as a scalar.\nc : array_like\n    Array of coefficients ordered so that the coefficient of the term of\n    multi-degree i,j is contained in ``c[i,j]``. If `c` has dimension\n    greater than two the remaining indices enumerate multiple sets of\n    coefficients.\n\nReturns\n-------\nvalues : ndarray, compatible object\n    The values of the two dimensional Chebyshev series at points in the\n    Cartesian product of `x` and `y`.\n\nSee Also\n--------\nlagval, lagval2d, lagval3d, laggrid3d\n\nExamples\n--------\n>>> from numpy.polynomial.laguerre import laggrid2d\n>>> c = [[1, 2], [3, 4]]\n>>> laggrid2d([0, 1], [0, 1], c)\narray([[10.,  4.],\n       [ 3.,  1.]])"
    },
    {
      "name": "lagval3d",
      "docstring": "Evaluate a 3-D Laguerre series at points (x, y, z).\n\nThis function returns the values:\n\n.. math:: p(x,y,z) = \\sum_{i,j,k} c_{i,j,k} * L_i(x) * L_j(y) * L_k(z)\n\nThe parameters `x`, `y`, and `z` are converted to arrays only if\nthey are tuples or a lists, otherwise they are treated as a scalars and\nthey must have the same shape after conversion. In either case, either\n`x`, `y`, and `z` or their elements must support multiplication and\naddition both with themselves and with the elements of `c`.\n\nIf `c` has fewer than 3 dimensions, ones are implicitly appended to its\nshape to make it 3-D. The shape of the result will be c.shape[3:] +\nx.shape.\n\nParameters\n----------\nx, y, z : array_like, compatible object\n    The three dimensional series is evaluated at the points\n    ``(x, y, z)``, where `x`, `y`, and `z` must have the same shape.  If\n    any of `x`, `y`, or `z` is a list or tuple, it is first converted\n    to an ndarray, otherwise it is left unchanged and if it isn't an\n    ndarray it is  treated as a scalar.\nc : array_like\n    Array of coefficients ordered so that the coefficient of the term of\n    multi-degree i,j,k is contained in ``c[i,j,k]``. If `c` has dimension\n    greater than 3 the remaining indices enumerate multiple sets of\n    coefficients.\n\nReturns\n-------\nvalues : ndarray, compatible object\n    The values of the multidimensional polynomial on points formed with\n    triples of corresponding values from `x`, `y`, and `z`.\n\nSee Also\n--------\nlagval, lagval2d, laggrid2d, laggrid3d\n\nExamples\n--------\n>>> from numpy.polynomial.laguerre import lagval3d\n>>> c = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]\n>>> lagval3d(1, 1, 2, c)\n-1.0"
    },
    {
      "name": "laggrid3d",
      "docstring": "Evaluate a 3-D Laguerre series on the Cartesian product of x, y, and z.\n\nThis function returns the values:\n\n.. math:: p(a,b,c) = \\sum_{i,j,k} c_{i,j,k} * L_i(a) * L_j(b) * L_k(c)\n\nwhere the points ``(a, b, c)`` consist of all triples formed by taking\n`a` from `x`, `b` from `y`, and `c` from `z`. The resulting points form\na grid with `x` in the first dimension, `y` in the second, and `z` in\nthe third.\n\nThe parameters `x`, `y`, and `z` are converted to arrays only if they\nare tuples or a lists, otherwise they are treated as a scalars. In\neither case, either `x`, `y`, and `z` or their elements must support\nmultiplication and addition both with themselves and with the elements\nof `c`.\n\nIf `c` has fewer than three dimensions, ones are implicitly appended to\nits shape to make it 3-D. The shape of the result will be c.shape[3:] +\nx.shape + y.shape + z.shape.\n\nParameters\n----------\nx, y, z : array_like, compatible objects\n    The three dimensional series is evaluated at the points in the\n    Cartesian product of `x`, `y`, and `z`.  If `x`, `y`, or `z` is a\n    list or tuple, it is first converted to an ndarray, otherwise it is\n    left unchanged and, if it isn't an ndarray, it is treated as a\n    scalar.\nc : array_like\n    Array of coefficients ordered so that the coefficients for terms of\n    degree i,j are contained in ``c[i,j]``. If `c` has dimension\n    greater than two the remaining indices enumerate multiple sets of\n    coefficients.\n\nReturns\n-------\nvalues : ndarray, compatible object\n    The values of the two dimensional polynomial at points in the Cartesian\n    product of `x` and `y`.\n\nSee Also\n--------\nlagval, lagval2d, laggrid2d, lagval3d\n\nExamples\n--------\n>>> from numpy.polynomial.laguerre import laggrid3d\n>>> c = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]\n>>> laggrid3d([0, 1], [0, 1], [2, 4], c)\narray([[[ -4., -44.],\n        [ -2., -18.]],\n       [[ -2., -14.],\n        [ -1.,  -5.]]])"
    },
    {
      "name": "lagvander",
      "docstring": "Pseudo-Vandermonde matrix of given degree.\n\nReturns the pseudo-Vandermonde matrix of degree `deg` and sample points\n`x`. The pseudo-Vandermonde matrix is defined by\n\n.. math:: V[..., i] = L_i(x)\n\nwhere ``0 <= i <= deg``. The leading indices of `V` index the elements of\n`x` and the last index is the degree of the Laguerre polynomial.\n\nIf `c` is a 1-D array of coefficients of length ``n + 1`` and `V` is the\narray ``V = lagvander(x, n)``, then ``np.dot(V, c)`` and\n``lagval(x, c)`` are the same up to roundoff. This equivalence is\nuseful both for least squares fitting and for the evaluation of a large\nnumber of Laguerre series of the same degree and sample points.\n\nParameters\n----------\nx : array_like\n    Array of points. The dtype is converted to float64 or complex128\n    depending on whether any of the elements are complex. If `x` is\n    scalar it is converted to a 1-D array.\ndeg : int\n    Degree of the resulting matrix.\n\nReturns\n-------\nvander : ndarray\n    The pseudo-Vandermonde matrix. The shape of the returned matrix is\n    ``x.shape + (deg + 1,)``, where The last index is the degree of the\n    corresponding Laguerre polynomial.  The dtype will be the same as\n    the converted `x`.\n\nExamples\n--------\n>>> import numpy as np\n>>> from numpy.polynomial.laguerre import lagvander\n>>> x = np.array([0, 1, 2])\n>>> lagvander(x, 3)\narray([[ 1.        ,  1.        ,  1.        ,  1.        ],\n       [ 1.        ,  0.        , -0.5       , -0.66666667],\n       [ 1.        , -1.        , -1.        , -0.33333333]])"
    },
    {
      "name": "lagvander2d",
      "docstring": "Pseudo-Vandermonde matrix of given degrees.\n\nReturns the pseudo-Vandermonde matrix of degrees `deg` and sample\npoints ``(x, y)``. The pseudo-Vandermonde matrix is defined by\n\n.. math:: V[..., (deg[1] + 1)*i + j] = L_i(x) * L_j(y),\n\nwhere ``0 <= i <= deg[0]`` and ``0 <= j <= deg[1]``. The leading indices of\n`V` index the points ``(x, y)`` and the last index encodes the degrees of\nthe Laguerre polynomials.\n\nIf ``V = lagvander2d(x, y, [xdeg, ydeg])``, then the columns of `V`\ncorrespond to the elements of a 2-D coefficient array `c` of shape\n(xdeg + 1, ydeg + 1) in the order\n\n.. math:: c_{00}, c_{01}, c_{02} ... , c_{10}, c_{11}, c_{12} ...\n\nand ``np.dot(V, c.flat)`` and ``lagval2d(x, y, c)`` will be the same\nup to roundoff. This equivalence is useful both for least squares\nfitting and for the evaluation of a large number of 2-D Laguerre\nseries of the same degrees and sample points.\n\nParameters\n----------\nx, y : array_like\n    Arrays of point coordinates, all of the same shape. The dtypes\n    will be converted to either float64 or complex128 depending on\n    whether any of the elements are complex. Scalars are converted to\n    1-D arrays.\ndeg : list of ints\n    List of maximum degrees of the form [x_deg, y_deg].\n\nReturns\n-------\nvander2d : ndarray\n    The shape of the returned matrix is ``x.shape + (order,)``, where\n    :math:`order = (deg[0]+1)*(deg[1]+1)`.  The dtype will be the same\n    as the converted `x` and `y`.\n\nSee Also\n--------\nlagvander, lagvander3d, lagval2d, lagval3d\n\nExamples\n--------\n>>> import numpy as np\n>>> from numpy.polynomial.laguerre import lagvander2d\n>>> x = np.array([0])\n>>> y = np.array([2])\n>>> lagvander2d(x, y, [2, 1])\narray([[ 1., -1.,  1., -1.,  1., -1.]])"
    },
    {
      "name": "lagvander3d",
      "docstring": "Pseudo-Vandermonde matrix of given degrees.\n\nReturns the pseudo-Vandermonde matrix of degrees `deg` and sample\npoints ``(x, y, z)``. If `l`, `m`, `n` are the given degrees in `x`, `y`, `z`,\nthen The pseudo-Vandermonde matrix is defined by\n\n.. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = L_i(x)*L_j(y)*L_k(z),\n\nwhere ``0 <= i <= l``, ``0 <= j <= m``, and ``0 <= j <= n``.  The leading\nindices of `V` index the points ``(x, y, z)`` and the last index encodes\nthe degrees of the Laguerre polynomials.\n\nIf ``V = lagvander3d(x, y, z, [xdeg, ydeg, zdeg])``, then the columns\nof `V` correspond to the elements of a 3-D coefficient array `c` of\nshape (xdeg + 1, ydeg + 1, zdeg + 1) in the order\n\n.. math:: c_{000}, c_{001}, c_{002},... , c_{010}, c_{011}, c_{012},...\n\nand  ``np.dot(V, c.flat)`` and ``lagval3d(x, y, z, c)`` will be the\nsame up to roundoff. This equivalence is useful both for least squares\nfitting and for the evaluation of a large number of 3-D Laguerre\nseries of the same degrees and sample points.\n\nParameters\n----------\nx, y, z : array_like\n    Arrays of point coordinates, all of the same shape. The dtypes will\n    be converted to either float64 or complex128 depending on whether\n    any of the elements are complex. Scalars are converted to 1-D\n    arrays.\ndeg : list of ints\n    List of maximum degrees of the form [x_deg, y_deg, z_deg].\n\nReturns\n-------\nvander3d : ndarray\n    The shape of the returned matrix is ``x.shape + (order,)``, where\n    :math:`order = (deg[0]+1)*(deg[1]+1)*(deg[2]+1)`.  The dtype will\n    be the same as the converted `x`, `y`, and `z`.\n\nSee Also\n--------\nlagvander, lagvander3d, lagval2d, lagval3d\n\nExamples\n--------\n>>> import numpy as np\n>>> from numpy.polynomial.laguerre import lagvander3d\n>>> x = np.array([0])\n>>> y = np.array([2])\n>>> z = np.array([0])\n>>> lagvander3d(x, y, z, [2, 1, 3])\narray([[ 1.,  1.,  1.,  1., -1., -1., -1., -1.,  1.,  1.,  1.,  1., -1.,\n        -1., -1., -1.,  1.,  1.,  1.,  1., -1., -1., -1., -1.]])"
    },
    {
      "name": "lagfit",
      "docstring": "Least squares fit of Laguerre series to data.\n\nReturn the coefficients of a Laguerre series of degree `deg` that is the\nleast squares fit to the data values `y` given at points `x`. If `y` is\n1-D the returned coefficients will also be 1-D. If `y` is 2-D multiple\nfits are done, one for each column of `y`, and the resulting\ncoefficients are stored in the corresponding columns of a 2-D return.\nThe fitted polynomial(s) are in the form\n\n.. math::  p(x) = c_0 + c_1 * L_1(x) + ... + c_n * L_n(x),\n\nwhere ``n`` is `deg`.\n\nParameters\n----------\nx : array_like, shape (M,)\n    x-coordinates of the M sample points ``(x[i], y[i])``.\ny : array_like, shape (M,) or (M, K)\n    y-coordinates of the sample points. Several data sets of sample\n    points sharing the same x-coordinates can be fitted at once by\n    passing in a 2D-array that contains one dataset per column.\ndeg : int or 1-D array_like\n    Degree(s) of the fitting polynomials. If `deg` is a single integer\n    all terms up to and including the `deg`'th term are included in the\n    fit. For NumPy versions >= 1.11.0 a list of integers specifying the\n    degrees of the terms to include may be used instead.\nrcond : float, optional\n    Relative condition number of the fit. Singular values smaller than\n    this relative to the largest singular value will be ignored. The\n    default value is len(x)*eps, where eps is the relative precision of\n    the float type, about 2e-16 in most cases.\nfull : bool, optional\n    Switch determining nature of return value. When it is False (the\n    default) just the coefficients are returned, when True diagnostic\n    information from the singular value decomposition is also returned.\nw : array_like, shape (`M`,), optional\n    Weights. If not None, the weight ``w[i]`` applies to the unsquared\n    residual ``y[i] - y_hat[i]`` at ``x[i]``. Ideally the weights are\n    chosen so that the errors of the products ``w[i]*y[i]`` all have the\n    same variance.  When using inverse-variance weighting, use\n    ``w[i] = 1/sigma(y[i])``.  The default value is None.\n\nReturns\n-------\ncoef : ndarray, shape (M,) or (M, K)\n    Laguerre coefficients ordered from low to high. If `y` was 2-D,\n    the coefficients for the data in column *k*  of `y` are in column\n    *k*.\n\n[residuals, rank, singular_values, rcond] : list\n    These values are only returned if ``full == True``\n\n    - residuals -- sum of squared residuals of the least squares fit\n    - rank -- the numerical rank of the scaled Vandermonde matrix\n    - singular_values -- singular values of the scaled Vandermonde matrix\n    - rcond -- value of `rcond`.\n\n    For more details, see `numpy.linalg.lstsq`.\n\nWarns\n-----\nRankWarning\n    The rank of the coefficient matrix in the least-squares fit is\n    deficient. The warning is only raised if ``full == False``.  The\n    warnings can be turned off by\n\n    >>> import warnings\n    >>> warnings.simplefilter('ignore', np.exceptions.RankWarning)\n\nSee Also\n--------\nnumpy.polynomial.polynomial.polyfit\nnumpy.polynomial.legendre.legfit\nnumpy.polynomial.chebyshev.chebfit\nnumpy.polynomial.hermite.hermfit\nnumpy.polynomial.hermite_e.hermefit\nlagval : Evaluates a Laguerre series.\nlagvander : pseudo Vandermonde matrix of Laguerre series.\nlagweight : Laguerre weight function.\nnumpy.linalg.lstsq : Computes a least-squares fit from the matrix.\nscipy.interpolate.UnivariateSpline : Computes spline fits.\n\nNotes\n-----\nThe solution is the coefficients of the Laguerre series ``p`` that\nminimizes the sum of the weighted squared errors\n\n.. math:: E = \\sum_j w_j^2 * |y_j - p(x_j)|^2,\n\nwhere the :math:`w_j` are the weights. This problem is solved by\nsetting up as the (typically) overdetermined matrix equation\n\n.. math:: V(x) * c = w * y,\n\nwhere ``V`` is the weighted pseudo Vandermonde matrix of `x`, ``c`` are the\ncoefficients to be solved for, `w` are the weights, and `y` are the\nobserved values.  This equation is then solved using the singular value\ndecomposition of ``V``.\n\nIf some of the singular values of `V` are so small that they are\nneglected, then a `~exceptions.RankWarning` will be issued. This means that\nthe coefficient values may be poorly determined. Using a lower order fit\nwill usually get rid of the warning.  The `rcond` parameter can also be\nset to a value smaller than its default, but the resulting fit may be\nspurious and have large contributions from roundoff error.\n\nFits using Laguerre series are probably most useful when the data can\nbe approximated by ``sqrt(w(x)) * p(x)``, where ``w(x)`` is the Laguerre\nweight. In that case the weight ``sqrt(w(x[i]))`` should be used\ntogether with data values ``y[i]/sqrt(w(x[i]))``. The weight function is\navailable as `lagweight`.\n\nReferences\n----------\n.. [1] Wikipedia, \"Curve fitting\",\n       https://en.wikipedia.org/wiki/Curve_fitting\n\nExamples\n--------\n>>> import numpy as np\n>>> from numpy.polynomial.laguerre import lagfit, lagval\n>>> x = np.linspace(0, 10)\n>>> rng = np.random.default_rng()\n>>> err = rng.normal(scale=1./10, size=len(x))\n>>> y = lagval(x, [1, 2, 3]) + err\n>>> lagfit(x, y, 2)\narray([1.00578369, 1.99417356, 2.99827656]) # may vary"
    },
    {
      "name": "lagcompanion",
      "docstring": "Return the companion matrix of c.\n\nThe usual companion matrix of the Laguerre polynomials is already\nsymmetric when `c` is a basis Laguerre polynomial, so no scaling is\napplied.\n\nParameters\n----------\nc : array_like\n    1-D array of Laguerre series coefficients ordered from low to high\n    degree.\n\nReturns\n-------\nmat : ndarray\n    Companion matrix of dimensions (deg, deg).\n\nExamples\n--------\n>>> from numpy.polynomial.laguerre import lagcompanion\n>>> lagcompanion([1, 2, 3])\narray([[ 1.        , -0.33333333],\n       [-1.        ,  4.33333333]])"
    },
    {
      "name": "lagroots",
      "docstring": "Compute the roots of a Laguerre series.\n\nReturn the roots (a.k.a. \"zeros\") of the polynomial\n\n.. math:: p(x) = \\sum_i c[i] * L_i(x).\n\nParameters\n----------\nc : 1-D array_like\n    1-D array of coefficients.\n\nReturns\n-------\nout : ndarray\n    Array of the roots of the series. If all the roots are real,\n    then `out` is also real, otherwise it is complex.\n\nSee Also\n--------\nnumpy.polynomial.polynomial.polyroots\nnumpy.polynomial.legendre.legroots\nnumpy.polynomial.chebyshev.chebroots\nnumpy.polynomial.hermite.hermroots\nnumpy.polynomial.hermite_e.hermeroots\n\nNotes\n-----\nThe root estimates are obtained as the eigenvalues of the companion\nmatrix, Roots far from the origin of the complex plane may have large\nerrors due to the numerical instability of the series for such\nvalues. Roots with multiplicity greater than 1 will also show larger\nerrors as the value of the series near such points is relatively\ninsensitive to errors in the roots. Isolated roots near the origin can\nbe improved by a few iterations of Newton's method.\n\nThe Laguerre series basis polynomials aren't powers of `x` so the\nresults of this function may seem unintuitive.\n\nExamples\n--------\n>>> from numpy.polynomial.laguerre import lagroots, lagfromroots\n>>> coef = lagfromroots([0, 1, 2])\n>>> coef\narray([  2.,  -8.,  12.,  -6.])\n>>> lagroots(coef)\narray([-4.4408921e-16,  1.0000000e+00,  2.0000000e+00])"
    },
    {
      "name": "laggauss",
      "docstring": "Gauss-Laguerre quadrature.\n\nComputes the sample points and weights for Gauss-Laguerre quadrature.\nThese sample points and weights will correctly integrate polynomials of\ndegree :math:`2*deg - 1` or less over the interval :math:`[0, \\inf]`\nwith the weight function :math:`f(x) = \\exp(-x)`.\n\nParameters\n----------\ndeg : int\n    Number of sample points and weights. It must be >= 1.\n\nReturns\n-------\nx : ndarray\n    1-D ndarray containing the sample points.\ny : ndarray\n    1-D ndarray containing the weights.\n\nNotes\n-----\nThe results have only been tested up to degree 100 higher degrees may\nbe problematic. The weights are determined by using the fact that\n\n.. math:: w_k = c / (L'_n(x_k) * L_{n-1}(x_k))\n\nwhere :math:`c` is a constant independent of :math:`k` and :math:`x_k`\nis the k'th root of :math:`L_n`, and then scaling the results to get\nthe right value when integrating 1.\n\nExamples\n--------\n>>> from numpy.polynomial.laguerre import laggauss\n>>> laggauss(2)\n(array([0.58578644, 3.41421356]), array([0.85355339, 0.14644661]))"
    },
    {
      "name": "lagweight",
      "docstring": "Weight function of the Laguerre polynomials.\n\nThe weight function is :math:`exp(-x)` and the interval of integration\nis :math:`[0, \\inf]`. The Laguerre polynomials are orthogonal, but not\nnormalized, with respect to this weight function.\n\nParameters\n----------\nx : array_like\n   Values at which the weight function will be computed.\n\nReturns\n-------\nw : ndarray\n   The weight function at `x`.\n\nExamples\n--------\n>>> from numpy.polynomial.laguerre import lagweight\n>>> x = np.array([0, 1, 2])\n>>> lagweight(x)\narray([1.        , 0.36787944, 0.13533528])"
    }
  ],
  "innovations": []
}