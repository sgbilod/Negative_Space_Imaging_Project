{
  "file_path": "c:\\Users\\sgbil\\OneDrive\\Desktop\\Negative_Space_Imaging_Project\\.venv\\Lib\\site-packages\\numpy\\lib\\_twodim_base_impl.py",
  "classes": [],
  "functions": [
    {
      "name": "fliplr",
      "docstring": "Reverse the order of elements along axis 1 (left/right).\n\nFor a 2-D array, this flips the entries in each row in the left/right\ndirection. Columns are preserved, but appear in a different order than\nbefore.\n\nParameters\n----------\nm : array_like\n    Input array, must be at least 2-D.\n\nReturns\n-------\nf : ndarray\n    A view of `m` with the columns reversed.  Since a view\n    is returned, this operation is :math:`\\mathcal O(1)`.\n\nSee Also\n--------\nflipud : Flip array in the up/down direction.\nflip : Flip array in one or more dimensions.\nrot90 : Rotate array counterclockwise.\n\nNotes\n-----\nEquivalent to ``m[:,::-1]`` or ``np.flip(m, axis=1)``.\nRequires the array to be at least 2-D.\n\nExamples\n--------\n>>> import numpy as np\n>>> A = np.diag([1.,2.,3.])\n>>> A\narray([[1.,  0.,  0.],\n       [0.,  2.,  0.],\n       [0.,  0.,  3.]])\n>>> np.fliplr(A)\narray([[0.,  0.,  1.],\n       [0.,  2.,  0.],\n       [3.,  0.,  0.]])\n\n>>> rng = np.random.default_rng()\n>>> A = rng.normal(size=(2,3,5))\n>>> np.all(np.fliplr(A) == A[:,::-1,...])\nTrue"
    },
    {
      "name": "flipud",
      "docstring": "Reverse the order of elements along axis 0 (up/down).\n\nFor a 2-D array, this flips the entries in each column in the up/down\ndirection. Rows are preserved, but appear in a different order than before.\n\nParameters\n----------\nm : array_like\n    Input array.\n\nReturns\n-------\nout : array_like\n    A view of `m` with the rows reversed.  Since a view is\n    returned, this operation is :math:`\\mathcal O(1)`.\n\nSee Also\n--------\nfliplr : Flip array in the left/right direction.\nflip : Flip array in one or more dimensions.\nrot90 : Rotate array counterclockwise.\n\nNotes\n-----\nEquivalent to ``m[::-1, ...]`` or ``np.flip(m, axis=0)``.\nRequires the array to be at least 1-D.\n\nExamples\n--------\n>>> import numpy as np\n>>> A = np.diag([1.0, 2, 3])\n>>> A\narray([[1.,  0.,  0.],\n       [0.,  2.,  0.],\n       [0.,  0.,  3.]])\n>>> np.flipud(A)\narray([[0.,  0.,  3.],\n       [0.,  2.,  0.],\n       [1.,  0.,  0.]])\n\n>>> rng = np.random.default_rng()\n>>> A = rng.normal(size=(2,3,5))\n>>> np.all(np.flipud(A) == A[::-1,...])\nTrue\n\n>>> np.flipud([1,2])\narray([2, 1])"
    },
    {
      "name": "eye",
      "docstring": "Return a 2-D array with ones on the diagonal and zeros elsewhere.\n\nParameters\n----------\nN : int\n  Number of rows in the output.\nM : int, optional\n  Number of columns in the output. If None, defaults to `N`.\nk : int, optional\n  Index of the diagonal: 0 (the default) refers to the main diagonal,\n  a positive value refers to an upper diagonal, and a negative value\n  to a lower diagonal.\ndtype : data-type, optional\n  Data-type of the returned array.\norder : {'C', 'F'}, optional\n    Whether the output should be stored in row-major (C-style) or\n    column-major (Fortran-style) order in memory.\ndevice : str, optional\n    The device on which to place the created array. Default: None.\n    For Array-API interoperability only, so must be ``\"cpu\"`` if passed.\n\n    .. versionadded:: 2.0.0\n${ARRAY_FUNCTION_LIKE}\n\n    .. versionadded:: 1.20.0\n\nReturns\n-------\nI : ndarray of shape (N,M)\n  An array where all elements are equal to zero, except for the `k`-th\n  diagonal, whose values are equal to one.\n\nSee Also\n--------\nidentity : (almost) equivalent function\ndiag : diagonal 2-D array from a 1-D array specified by the user.\n\nExamples\n--------\n>>> import numpy as np\n>>> np.eye(2, dtype=int)\narray([[1, 0],\n       [0, 1]])\n>>> np.eye(3, k=1)\narray([[0.,  1.,  0.],\n       [0.,  0.,  1.],\n       [0.,  0.,  0.]])"
    },
    {
      "name": "diag",
      "docstring": "Extract a diagonal or construct a diagonal array.\n\nSee the more detailed documentation for ``numpy.diagonal`` if you use this\nfunction to extract a diagonal and wish to write to the resulting array;\nwhether it returns a copy or a view depends on what version of numpy you\nare using.\n\nParameters\n----------\nv : array_like\n    If `v` is a 2-D array, return a copy of its `k`-th diagonal.\n    If `v` is a 1-D array, return a 2-D array with `v` on the `k`-th\n    diagonal.\nk : int, optional\n    Diagonal in question. The default is 0. Use `k>0` for diagonals\n    above the main diagonal, and `k<0` for diagonals below the main\n    diagonal.\n\nReturns\n-------\nout : ndarray\n    The extracted diagonal or constructed diagonal array.\n\nSee Also\n--------\ndiagonal : Return specified diagonals.\ndiagflat : Create a 2-D array with the flattened input as a diagonal.\ntrace : Sum along diagonals.\ntriu : Upper triangle of an array.\ntril : Lower triangle of an array.\n\nExamples\n--------\n>>> import numpy as np\n>>> x = np.arange(9).reshape((3,3))\n>>> x\narray([[0, 1, 2],\n       [3, 4, 5],\n       [6, 7, 8]])\n\n>>> np.diag(x)\narray([0, 4, 8])\n>>> np.diag(x, k=1)\narray([1, 5])\n>>> np.diag(x, k=-1)\narray([3, 7])\n\n>>> np.diag(np.diag(x))\narray([[0, 0, 0],\n       [0, 4, 0],\n       [0, 0, 8]])"
    },
    {
      "name": "diagflat",
      "docstring": "Create a two-dimensional array with the flattened input as a diagonal.\n\nParameters\n----------\nv : array_like\n    Input data, which is flattened and set as the `k`-th\n    diagonal of the output.\nk : int, optional\n    Diagonal to set; 0, the default, corresponds to the \"main\" diagonal,\n    a positive (negative) `k` giving the number of the diagonal above\n    (below) the main.\n\nReturns\n-------\nout : ndarray\n    The 2-D output array.\n\nSee Also\n--------\ndiag : MATLAB work-alike for 1-D and 2-D arrays.\ndiagonal : Return specified diagonals.\ntrace : Sum along diagonals.\n\nExamples\n--------\n>>> import numpy as np\n>>> np.diagflat([[1,2], [3,4]])\narray([[1, 0, 0, 0],\n       [0, 2, 0, 0],\n       [0, 0, 3, 0],\n       [0, 0, 0, 4]])\n\n>>> np.diagflat([1,2], 1)\narray([[0, 1, 0],\n       [0, 0, 2],\n       [0, 0, 0]])"
    },
    {
      "name": "tri",
      "docstring": "An array with ones at and below the given diagonal and zeros elsewhere.\n\nParameters\n----------\nN : int\n    Number of rows in the array.\nM : int, optional\n    Number of columns in the array.\n    By default, `M` is taken equal to `N`.\nk : int, optional\n    The sub-diagonal at and below which the array is filled.\n    `k` = 0 is the main diagonal, while `k` < 0 is below it,\n    and `k` > 0 is above.  The default is 0.\ndtype : dtype, optional\n    Data type of the returned array.  The default is float.\n${ARRAY_FUNCTION_LIKE}\n\n    .. versionadded:: 1.20.0\n\nReturns\n-------\ntri : ndarray of shape (N, M)\n    Array with its lower triangle filled with ones and zero elsewhere;\n    in other words ``T[i,j] == 1`` for ``j <= i + k``, 0 otherwise.\n\nExamples\n--------\n>>> import numpy as np\n>>> np.tri(3, 5, 2, dtype=int)\narray([[1, 1, 1, 0, 0],\n       [1, 1, 1, 1, 0],\n       [1, 1, 1, 1, 1]])\n\n>>> np.tri(3, 5, -1)\narray([[0.,  0.,  0.,  0.,  0.],\n       [1.,  0.,  0.,  0.,  0.],\n       [1.,  1.,  0.,  0.,  0.]])"
    },
    {
      "name": "tril",
      "docstring": "Lower triangle of an array.\n\nReturn a copy of an array with elements above the `k`-th diagonal zeroed.\nFor arrays with ``ndim`` exceeding 2, `tril` will apply to the final two\naxes.\n\nParameters\n----------\nm : array_like, shape (..., M, N)\n    Input array.\nk : int, optional\n    Diagonal above which to zero elements.  `k = 0` (the default) is the\n    main diagonal, `k < 0` is below it and `k > 0` is above.\n\nReturns\n-------\ntril : ndarray, shape (..., M, N)\n    Lower triangle of `m`, of same shape and data-type as `m`.\n\nSee Also\n--------\ntriu : same thing, only for the upper triangle\n\nExamples\n--------\n>>> import numpy as np\n>>> np.tril([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)\narray([[ 0,  0,  0],\n       [ 4,  0,  0],\n       [ 7,  8,  0],\n       [10, 11, 12]])\n\n>>> np.tril(np.arange(3*4*5).reshape(3, 4, 5))\narray([[[ 0,  0,  0,  0,  0],\n        [ 5,  6,  0,  0,  0],\n        [10, 11, 12,  0,  0],\n        [15, 16, 17, 18,  0]],\n       [[20,  0,  0,  0,  0],\n        [25, 26,  0,  0,  0],\n        [30, 31, 32,  0,  0],\n        [35, 36, 37, 38,  0]],\n       [[40,  0,  0,  0,  0],\n        [45, 46,  0,  0,  0],\n        [50, 51, 52,  0,  0],\n        [55, 56, 57, 58,  0]]])"
    },
    {
      "name": "triu",
      "docstring": "Upper triangle of an array.\n\nReturn a copy of an array with the elements below the `k`-th diagonal\nzeroed. For arrays with ``ndim`` exceeding 2, `triu` will apply to the\nfinal two axes.\n\nPlease refer to the documentation for `tril` for further details.\n\nSee Also\n--------\ntril : lower triangle of an array\n\nExamples\n--------\n>>> import numpy as np\n>>> np.triu([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)\narray([[ 1,  2,  3],\n       [ 4,  5,  6],\n       [ 0,  8,  9],\n       [ 0,  0, 12]])\n\n>>> np.triu(np.arange(3*4*5).reshape(3, 4, 5))\narray([[[ 0,  1,  2,  3,  4],\n        [ 0,  6,  7,  8,  9],\n        [ 0,  0, 12, 13, 14],\n        [ 0,  0,  0, 18, 19]],\n       [[20, 21, 22, 23, 24],\n        [ 0, 26, 27, 28, 29],\n        [ 0,  0, 32, 33, 34],\n        [ 0,  0,  0, 38, 39]],\n       [[40, 41, 42, 43, 44],\n        [ 0, 46, 47, 48, 49],\n        [ 0,  0, 52, 53, 54],\n        [ 0,  0,  0, 58, 59]]])"
    },
    {
      "name": "vander",
      "docstring": "Generate a Vandermonde matrix.\n\nThe columns of the output matrix are powers of the input vector. The\norder of the powers is determined by the `increasing` boolean argument.\nSpecifically, when `increasing` is False, the `i`-th output column is\nthe input vector raised element-wise to the power of ``N - i - 1``. Such\na matrix with a geometric progression in each row is named for Alexandre-\nTheophile Vandermonde.\n\nParameters\n----------\nx : array_like\n    1-D input array.\nN : int, optional\n    Number of columns in the output.  If `N` is not specified, a square\n    array is returned (``N = len(x)``).\nincreasing : bool, optional\n    Order of the powers of the columns.  If True, the powers increase\n    from left to right, if False (the default) they are reversed.\n\nReturns\n-------\nout : ndarray\n    Vandermonde matrix.  If `increasing` is False, the first column is\n    ``x^(N-1)``, the second ``x^(N-2)`` and so forth. If `increasing` is\n    True, the columns are ``x^0, x^1, ..., x^(N-1)``.\n\nSee Also\n--------\npolynomial.polynomial.polyvander\n\nExamples\n--------\n>>> import numpy as np\n>>> x = np.array([1, 2, 3, 5])\n>>> N = 3\n>>> np.vander(x, N)\narray([[ 1,  1,  1],\n       [ 4,  2,  1],\n       [ 9,  3,  1],\n       [25,  5,  1]])\n\n>>> np.column_stack([x**(N-1-i) for i in range(N)])\narray([[ 1,  1,  1],\n       [ 4,  2,  1],\n       [ 9,  3,  1],\n       [25,  5,  1]])\n\n>>> x = np.array([1, 2, 3, 5])\n>>> np.vander(x)\narray([[  1,   1,   1,   1],\n       [  8,   4,   2,   1],\n       [ 27,   9,   3,   1],\n       [125,  25,   5,   1]])\n>>> np.vander(x, increasing=True)\narray([[  1,   1,   1,   1],\n       [  1,   2,   4,   8],\n       [  1,   3,   9,  27],\n       [  1,   5,  25, 125]])\n\nThe determinant of a square Vandermonde matrix is the product\nof the differences between the values of the input vector:\n\n>>> np.linalg.det(np.vander(x))\n48.000000000000043 # may vary\n>>> (5-3)*(5-2)*(5-1)*(3-2)*(3-1)*(2-1)\n48"
    },
    {
      "name": "histogram2d",
      "docstring": "Compute the bi-dimensional histogram of two data samples.\n\nParameters\n----------\nx : array_like, shape (N,)\n    An array containing the x coordinates of the points to be\n    histogrammed.\ny : array_like, shape (N,)\n    An array containing the y coordinates of the points to be\n    histogrammed.\nbins : int or array_like or [int, int] or [array, array], optional\n    The bin specification:\n\n    * If int, the number of bins for the two dimensions (nx=ny=bins).\n    * If array_like, the bin edges for the two dimensions\n      (x_edges=y_edges=bins).\n    * If [int, int], the number of bins in each dimension\n      (nx, ny = bins).\n    * If [array, array], the bin edges in each dimension\n      (x_edges, y_edges = bins).\n    * A combination [int, array] or [array, int], where int\n      is the number of bins and array is the bin edges.\n\nrange : array_like, shape(2,2), optional\n    The leftmost and rightmost edges of the bins along each dimension\n    (if not specified explicitly in the `bins` parameters):\n    ``[[xmin, xmax], [ymin, ymax]]``. All values outside of this range\n    will be considered outliers and not tallied in the histogram.\ndensity : bool, optional\n    If False, the default, returns the number of samples in each bin.\n    If True, returns the probability *density* function at the bin,\n    ``bin_count / sample_count / bin_area``.\nweights : array_like, shape(N,), optional\n    An array of values ``w_i`` weighing each sample ``(x_i, y_i)``.\n    Weights are normalized to 1 if `density` is True. If `density` is\n    False, the values of the returned histogram are equal to the sum of\n    the weights belonging to the samples falling into each bin.\n\nReturns\n-------\nH : ndarray, shape(nx, ny)\n    The bi-dimensional histogram of samples `x` and `y`. Values in `x`\n    are histogrammed along the first dimension and values in `y` are\n    histogrammed along the second dimension.\nxedges : ndarray, shape(nx+1,)\n    The bin edges along the first dimension.\nyedges : ndarray, shape(ny+1,)\n    The bin edges along the second dimension.\n\nSee Also\n--------\nhistogram : 1D histogram\nhistogramdd : Multidimensional histogram\n\nNotes\n-----\nWhen `density` is True, then the returned histogram is the sample\ndensity, defined such that the sum over bins of the product\n``bin_value * bin_area`` is 1.\n\nPlease note that the histogram does not follow the Cartesian convention\nwhere `x` values are on the abscissa and `y` values on the ordinate\naxis.  Rather, `x` is histogrammed along the first dimension of the\narray (vertical), and `y` along the second dimension of the array\n(horizontal).  This ensures compatibility with `histogramdd`.\n\nExamples\n--------\n>>> import numpy as np\n>>> from matplotlib.image import NonUniformImage\n>>> import matplotlib.pyplot as plt\n\nConstruct a 2-D histogram with variable bin width. First define the bin\nedges:\n\n>>> xedges = [0, 1, 3, 5]\n>>> yedges = [0, 2, 3, 4, 6]\n\nNext we create a histogram H with random bin content:\n\n>>> x = np.random.normal(2, 1, 100)\n>>> y = np.random.normal(1, 1, 100)\n>>> H, xedges, yedges = np.histogram2d(x, y, bins=(xedges, yedges))\n>>> # Histogram does not follow Cartesian convention (see Notes),\n>>> # therefore transpose H for visualization purposes.\n>>> H = H.T\n\n:func:`imshow <matplotlib.pyplot.imshow>` can only display square bins:\n\n>>> fig = plt.figure(figsize=(7, 3))\n>>> ax = fig.add_subplot(131, title='imshow: square bins')\n>>> plt.imshow(H, interpolation='nearest', origin='lower',\n...         extent=[xedges[0], xedges[-1], yedges[0], yedges[-1]])\n<matplotlib.image.AxesImage object at 0x...>\n\n:func:`pcolormesh <matplotlib.pyplot.pcolormesh>` can display actual edges:\n\n>>> ax = fig.add_subplot(132, title='pcolormesh: actual edges',\n...         aspect='equal')\n>>> X, Y = np.meshgrid(xedges, yedges)\n>>> ax.pcolormesh(X, Y, H)\n<matplotlib.collections.QuadMesh object at 0x...>\n\n:class:`NonUniformImage <matplotlib.image.NonUniformImage>` can be used to\ndisplay actual bin edges with interpolation:\n\n>>> ax = fig.add_subplot(133, title='NonUniformImage: interpolated',\n...         aspect='equal', xlim=xedges[[0, -1]], ylim=yedges[[0, -1]])\n>>> im = NonUniformImage(ax, interpolation='bilinear')\n>>> xcenters = (xedges[:-1] + xedges[1:]) / 2\n>>> ycenters = (yedges[:-1] + yedges[1:]) / 2\n>>> im.set_data(xcenters, ycenters, H)\n>>> ax.add_image(im)\n>>> plt.show()\n\nIt is also possible to construct a 2-D histogram without specifying bin\nedges:\n\n>>> # Generate non-symmetric test data\n>>> n = 10000\n>>> x = np.linspace(1, 100, n)\n>>> y = 2*np.log(x) + np.random.rand(n) - 0.5\n>>> # Compute 2d histogram. Note the order of x/y and xedges/yedges\n>>> H, yedges, xedges = np.histogram2d(y, x, bins=20)\n\nNow we can plot the histogram using\n:func:`pcolormesh <matplotlib.pyplot.pcolormesh>`, and a\n:func:`hexbin <matplotlib.pyplot.hexbin>` for comparison.\n\n>>> # Plot histogram using pcolormesh\n>>> fig, (ax1, ax2) = plt.subplots(ncols=2, sharey=True)\n>>> ax1.pcolormesh(xedges, yedges, H, cmap='rainbow')\n>>> ax1.plot(x, 2*np.log(x), 'k-')\n>>> ax1.set_xlim(x.min(), x.max())\n>>> ax1.set_ylim(y.min(), y.max())\n>>> ax1.set_xlabel('x')\n>>> ax1.set_ylabel('y')\n>>> ax1.set_title('histogram2d')\n>>> ax1.grid()\n\n>>> # Create hexbin plot for comparison\n>>> ax2.hexbin(x, y, gridsize=20, cmap='rainbow')\n>>> ax2.plot(x, 2*np.log(x), 'k-')\n>>> ax2.set_title('hexbin')\n>>> ax2.set_xlim(x.min(), x.max())\n>>> ax2.set_xlabel('x')\n>>> ax2.grid()\n\n>>> plt.show()"
    },
    {
      "name": "mask_indices",
      "docstring": "Return the indices to access (n, n) arrays, given a masking function.\n\nAssume `mask_func` is a function that, for a square array a of size\n``(n, n)`` with a possible offset argument `k`, when called as\n``mask_func(a, k)`` returns a new array with zeros in certain locations\n(functions like `triu` or `tril` do precisely this). Then this function\nreturns the indices where the non-zero values would be located.\n\nParameters\n----------\nn : int\n    The returned indices will be valid to access arrays of shape (n, n).\nmask_func : callable\n    A function whose call signature is similar to that of `triu`, `tril`.\n    That is, ``mask_func(x, k)`` returns a boolean array, shaped like `x`.\n    `k` is an optional argument to the function.\nk : scalar\n    An optional argument which is passed through to `mask_func`. Functions\n    like `triu`, `tril` take a second argument that is interpreted as an\n    offset.\n\nReturns\n-------\nindices : tuple of arrays.\n    The `n` arrays of indices corresponding to the locations where\n    ``mask_func(np.ones((n, n)), k)`` is True.\n\nSee Also\n--------\ntriu, tril, triu_indices, tril_indices\n\nExamples\n--------\n>>> import numpy as np\n\nThese are the indices that would allow you to access the upper triangular\npart of any 3x3 array:\n\n>>> iu = np.mask_indices(3, np.triu)\n\nFor example, if `a` is a 3x3 array:\n\n>>> a = np.arange(9).reshape(3, 3)\n>>> a\narray([[0, 1, 2],\n       [3, 4, 5],\n       [6, 7, 8]])\n>>> a[iu]\narray([0, 1, 2, 4, 5, 8])\n\nAn offset can be passed also to the masking function.  This gets us the\nindices starting on the first diagonal right of the main one:\n\n>>> iu1 = np.mask_indices(3, np.triu, 1)\n\nwith which we now extract only three elements:\n\n>>> a[iu1]\narray([1, 2, 5])"
    },
    {
      "name": "tril_indices",
      "docstring": "Return the indices for the lower-triangle of an (n, m) array.\n\nParameters\n----------\nn : int\n    The row dimension of the arrays for which the returned\n    indices will be valid.\nk : int, optional\n    Diagonal offset (see `tril` for details).\nm : int, optional\n    The column dimension of the arrays for which the returned\n    arrays will be valid.\n    By default `m` is taken equal to `n`.\n\n\nReturns\n-------\ninds : tuple of arrays\n    The row and column indices, respectively. The row indices are sorted\n    in non-decreasing order, and the correspdonding column indices are\n    strictly increasing for each row.\n\nSee also\n--------\ntriu_indices : similar function, for upper-triangular.\nmask_indices : generic function accepting an arbitrary mask function.\ntril, triu\n\nExamples\n--------\n>>> import numpy as np\n\nCompute two different sets of indices to access 4x4 arrays, one for the\nlower triangular part starting at the main diagonal, and one starting two\ndiagonals further right:\n\n>>> il1 = np.tril_indices(4)\n>>> il1\n(array([0, 1, 1, 2, 2, 2, 3, 3, 3, 3]), array([0, 0, 1, 0, 1, 2, 0, 1, 2, 3]))\n\nNote that row indices (first array) are non-decreasing, and the corresponding\ncolumn indices (second array) are strictly increasing for each row.\nHere is how they can be used with a sample array:\n\n>>> a = np.arange(16).reshape(4, 4)\n>>> a\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11],\n       [12, 13, 14, 15]])\n\nBoth for indexing:\n\n>>> a[il1]\narray([ 0,  4,  5, ..., 13, 14, 15])\n\nAnd for assigning values:\n\n>>> a[il1] = -1\n>>> a\narray([[-1,  1,  2,  3],\n       [-1, -1,  6,  7],\n       [-1, -1, -1, 11],\n       [-1, -1, -1, -1]])\n\nThese cover almost the whole array (two diagonals right of the main one):\n\n>>> il2 = np.tril_indices(4, 2)\n>>> a[il2] = -10\n>>> a\narray([[-10, -10, -10,   3],\n       [-10, -10, -10, -10],\n       [-10, -10, -10, -10],\n       [-10, -10, -10, -10]])"
    },
    {
      "name": "tril_indices_from",
      "docstring": "Return the indices for the lower-triangle of arr.\n\nSee `tril_indices` for full details.\n\nParameters\n----------\narr : array_like\n    The indices will be valid for square arrays whose dimensions are\n    the same as arr.\nk : int, optional\n    Diagonal offset (see `tril` for details).\n\nExamples\n--------\n>>> import numpy as np\n\nCreate a 4 by 4 array\n\n>>> a = np.arange(16).reshape(4, 4)\n>>> a\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11],\n       [12, 13, 14, 15]])\n\nPass the array to get the indices of the lower triangular elements.\n\n>>> trili = np.tril_indices_from(a)\n>>> trili\n(array([0, 1, 1, 2, 2, 2, 3, 3, 3, 3]), array([0, 0, 1, 0, 1, 2, 0, 1, 2, 3]))\n\n>>> a[trili]\narray([ 0,  4,  5,  8,  9, 10, 12, 13, 14, 15])\n\nThis is syntactic sugar for tril_indices().\n\n>>> np.tril_indices(a.shape[0])\n(array([0, 1, 1, 2, 2, 2, 3, 3, 3, 3]), array([0, 0, 1, 0, 1, 2, 0, 1, 2, 3]))\n\nUse the `k` parameter to return the indices for the lower triangular array\nup to the k-th diagonal.\n\n>>> trili1 = np.tril_indices_from(a, k=1)\n>>> a[trili1]\narray([ 0,  1,  4,  5,  6,  8,  9, 10, 11, 12, 13, 14, 15])\n\nSee Also\n--------\ntril_indices, tril, triu_indices_from"
    },
    {
      "name": "triu_indices",
      "docstring": "Return the indices for the upper-triangle of an (n, m) array.\n\nParameters\n----------\nn : int\n    The size of the arrays for which the returned indices will\n    be valid.\nk : int, optional\n    Diagonal offset (see `triu` for details).\nm : int, optional\n    The column dimension of the arrays for which the returned\n    arrays will be valid.\n    By default `m` is taken equal to `n`.\n\n\nReturns\n-------\ninds : tuple, shape(2) of ndarrays, shape(`n`)\n    The row and column indices, respectively. The row indices are sorted\n    in non-decreasing order, and the correspdonding column indices are\n    strictly increasing for each row.\n\nSee also\n--------\ntril_indices : similar function, for lower-triangular.\nmask_indices : generic function accepting an arbitrary mask function.\ntriu, tril\n\nExamples\n--------\n>>> import numpy as np\n\nCompute two different sets of indices to access 4x4 arrays, one for the\nupper triangular part starting at the main diagonal, and one starting two\ndiagonals further right:\n\n>>> iu1 = np.triu_indices(4)\n>>> iu1\n(array([0, 0, 0, 0, 1, 1, 1, 2, 2, 3]), array([0, 1, 2, 3, 1, 2, 3, 2, 3, 3]))\n\nNote that row indices (first array) are non-decreasing, and the corresponding\ncolumn indices (second array) are strictly increasing for each row.\n\nHere is how they can be used with a sample array:\n\n>>> a = np.arange(16).reshape(4, 4)\n>>> a\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11],\n       [12, 13, 14, 15]])\n\nBoth for indexing:\n\n>>> a[iu1]\narray([ 0,  1,  2, ..., 10, 11, 15])\n\nAnd for assigning values:\n\n>>> a[iu1] = -1\n>>> a\narray([[-1, -1, -1, -1],\n       [ 4, -1, -1, -1],\n       [ 8,  9, -1, -1],\n       [12, 13, 14, -1]])\n\nThese cover only a small part of the whole array (two diagonals right\nof the main one):\n\n>>> iu2 = np.triu_indices(4, 2)\n>>> a[iu2] = -10\n>>> a\narray([[ -1,  -1, -10, -10],\n       [  4,  -1,  -1, -10],\n       [  8,   9,  -1,  -1],\n       [ 12,  13,  14,  -1]])"
    },
    {
      "name": "triu_indices_from",
      "docstring": "Return the indices for the upper-triangle of arr.\n\nSee `triu_indices` for full details.\n\nParameters\n----------\narr : ndarray, shape(N, N)\n    The indices will be valid for square arrays.\nk : int, optional\n    Diagonal offset (see `triu` for details).\n\nReturns\n-------\ntriu_indices_from : tuple, shape(2) of ndarray, shape(N)\n    Indices for the upper-triangle of `arr`.\n\nExamples\n--------\n>>> import numpy as np\n\nCreate a 4 by 4 array\n\n>>> a = np.arange(16).reshape(4, 4)\n>>> a\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11],\n       [12, 13, 14, 15]])\n\nPass the array to get the indices of the upper triangular elements.\n\n>>> triui = np.triu_indices_from(a)\n>>> triui\n(array([0, 0, 0, 0, 1, 1, 1, 2, 2, 3]), array([0, 1, 2, 3, 1, 2, 3, 2, 3, 3]))\n\n>>> a[triui]\narray([ 0,  1,  2,  3,  5,  6,  7, 10, 11, 15])\n\nThis is syntactic sugar for triu_indices().\n\n>>> np.triu_indices(a.shape[0])\n(array([0, 0, 0, 0, 1, 1, 1, 2, 2, 3]), array([0, 1, 2, 3, 1, 2, 3, 2, 3, 3]))\n\nUse the `k` parameter to return the indices for the upper triangular array\nfrom the k-th diagonal.\n\n>>> triuim1 = np.triu_indices_from(a, k=1)\n>>> a[triuim1]\narray([ 1,  2,  3,  6,  7, 11])\n\n\nSee Also\n--------\ntriu_indices, triu, tril_indices_from"
    }
  ],
  "innovations": []
}