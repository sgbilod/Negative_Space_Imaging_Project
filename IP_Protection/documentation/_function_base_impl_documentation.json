{
  "file_path": "c:\\Users\\sgbil\\OneDrive\\Desktop\\Negative_Space_Imaging_Project\\.venv\\Lib\\site-packages\\numpy\\lib\\_function_base_impl.py",
  "classes": [
    {
      "name": "vectorize",
      "docstring": "vectorize(pyfunc=np._NoValue, otypes=None, doc=None, excluded=None,\ncache=False, signature=None)\n\nReturns an object that acts like pyfunc, but takes arrays as input.\n\nDefine a vectorized function which takes a nested sequence of objects or\nnumpy arrays as inputs and returns a single numpy array or a tuple of numpy\narrays. The vectorized function evaluates `pyfunc` over successive tuples\nof the input arrays like the python map function, except it uses the\nbroadcasting rules of numpy.\n\nThe data type of the output of `vectorized` is determined by calling\nthe function with the first element of the input.  This can be avoided\nby specifying the `otypes` argument.\n\nParameters\n----------\npyfunc : callable, optional\n    A python function or method.\n    Can be omitted to produce a decorator with keyword arguments.\notypes : str or list of dtypes, optional\n    The output data type. It must be specified as either a string of\n    typecode characters or a list of data type specifiers. There should\n    be one data type specifier for each output.\ndoc : str, optional\n    The docstring for the function. If None, the docstring will be the\n    ``pyfunc.__doc__``.\nexcluded : set, optional\n    Set of strings or integers representing the positional or keyword\n    arguments for which the function will not be vectorized. These will be\n    passed directly to `pyfunc` unmodified.\n\ncache : bool, optional\n    If `True`, then cache the first function call that determines the number\n    of outputs if `otypes` is not provided.\n\nsignature : string, optional\n    Generalized universal function signature, e.g., ``(m,n),(n)->(m)`` for\n    vectorized matrix-vector multiplication. If provided, ``pyfunc`` will\n    be called with (and expected to return) arrays with shapes given by the\n    size of corresponding core dimensions. By default, ``pyfunc`` is\n    assumed to take scalars as input and output.\n\nReturns\n-------\nout : callable\n    A vectorized function if ``pyfunc`` was provided,\n    a decorator otherwise.\n\nSee Also\n--------\nfrompyfunc : Takes an arbitrary Python function and returns a ufunc\n\nNotes\n-----\nThe `vectorize` function is provided primarily for convenience, not for\nperformance. The implementation is essentially a for loop.\n\nIf `otypes` is not specified, then a call to the function with the\nfirst argument will be used to determine the number of outputs.  The\nresults of this call will be cached if `cache` is `True` to prevent\ncalling the function twice.  However, to implement the cache, the\noriginal function must be wrapped which will slow down subsequent\ncalls, so only do this if your function is expensive.\n\nThe new keyword argument interface and `excluded` argument support\nfurther degrades performance.\n\nReferences\n----------\n.. [1] :doc:`/reference/c-api/generalized-ufuncs`\n\nExamples\n--------\n>>> import numpy as np\n>>> def myfunc(a, b):\n...     \"Return a-b if a>b, otherwise return a+b\"\n...     if a > b:\n...         return a - b\n...     else:\n...         return a + b\n\n>>> vfunc = np.vectorize(myfunc)\n>>> vfunc([1, 2, 3, 4], 2)\narray([3, 4, 1, 2])\n\nThe docstring is taken from the input function to `vectorize` unless it\nis specified:\n\n>>> vfunc.__doc__\n'Return a-b if a>b, otherwise return a+b'\n>>> vfunc = np.vectorize(myfunc, doc='Vectorized `myfunc`')\n>>> vfunc.__doc__\n'Vectorized `myfunc`'\n\nThe output type is determined by evaluating the first element of the input,\nunless it is specified:\n\n>>> out = vfunc([1, 2, 3, 4], 2)\n>>> type(out[0])\n<class 'numpy.int64'>\n>>> vfunc = np.vectorize(myfunc, otypes=[float])\n>>> out = vfunc([1, 2, 3, 4], 2)\n>>> type(out[0])\n<class 'numpy.float64'>\n\nThe `excluded` argument can be used to prevent vectorizing over certain\narguments.  This can be useful for array-like arguments of a fixed length\nsuch as the coefficients for a polynomial as in `polyval`:\n\n>>> def mypolyval(p, x):\n...     _p = list(p)\n...     res = _p.pop(0)\n...     while _p:\n...         res = res*x + _p.pop(0)\n...     return res\n\nHere, we exclude the zeroth argument from vectorization whether it is\npassed by position or keyword.\n\n>>> vpolyval = np.vectorize(mypolyval, excluded={0, 'p'})\n>>> vpolyval([1, 2, 3], x=[0, 1])\narray([3, 6])\n>>> vpolyval(p=[1, 2, 3], x=[0, 1])\narray([3, 6])\n\nThe `signature` argument allows for vectorizing functions that act on\nnon-scalar arrays of fixed length. For example, you can use it for a\nvectorized calculation of Pearson correlation coefficient and its p-value:\n\n>>> import scipy.stats\n>>> pearsonr = np.vectorize(scipy.stats.pearsonr,\n...                 signature='(n),(n)->(),()')\n>>> pearsonr([[0, 1, 2, 3]], [[1, 2, 3, 4], [4, 3, 2, 1]])\n(array([ 1., -1.]), array([ 0.,  0.]))\n\nOr for a vectorized convolution:\n\n>>> convolve = np.vectorize(np.convolve, signature='(n),(m)->(k)')\n>>> convolve(np.eye(4), [1, 2, 1])\narray([[1., 2., 1., 0., 0., 0.],\n       [0., 1., 2., 1., 0., 0.],\n       [0., 0., 1., 2., 1., 0.],\n       [0., 0., 0., 1., 2., 1.]])\n\nDecorator syntax is supported.  The decorator can be called as\na function to provide keyword arguments:\n\n>>> @np.vectorize\n... def identity(x):\n...     return x\n...\n>>> identity([0, 1, 2])\narray([0, 1, 2])\n>>> @np.vectorize(otypes=[float])\n... def as_float(x):\n...     return x\n...\n>>> as_float([0, 1, 2])\narray([0., 1., 2.])",
      "methods": [
        {
          "name": "__init__",
          "docstring": null
        }
      ]
    }
  ],
  "functions": [
    {
      "name": "rot90",
      "docstring": "Rotate an array by 90 degrees in the plane specified by axes.\n\nRotation direction is from the first towards the second axis.\nThis means for a 2D array with the default `k` and `axes`, the\nrotation will be counterclockwise.\n\nParameters\n----------\nm : array_like\n    Array of two or more dimensions.\nk : integer\n    Number of times the array is rotated by 90 degrees.\naxes : (2,) array_like\n    The array is rotated in the plane defined by the axes.\n    Axes must be different.\n\nReturns\n-------\ny : ndarray\n    A rotated view of `m`.\n\nSee Also\n--------\nflip : Reverse the order of elements in an array along the given axis.\nfliplr : Flip an array horizontally.\nflipud : Flip an array vertically.\n\nNotes\n-----\n``rot90(m, k=1, axes=(1,0))``  is the reverse of\n``rot90(m, k=1, axes=(0,1))``\n\n``rot90(m, k=1, axes=(1,0))`` is equivalent to\n``rot90(m, k=-1, axes=(0,1))``\n\nExamples\n--------\n>>> import numpy as np\n>>> m = np.array([[1,2],[3,4]], int)\n>>> m\narray([[1, 2],\n       [3, 4]])\n>>> np.rot90(m)\narray([[2, 4],\n       [1, 3]])\n>>> np.rot90(m, 2)\narray([[4, 3],\n       [2, 1]])\n>>> m = np.arange(8).reshape((2,2,2))\n>>> np.rot90(m, 1, (1,2))\narray([[[1, 3],\n        [0, 2]],\n       [[5, 7],\n        [4, 6]]])"
    },
    {
      "name": "flip",
      "docstring": "Reverse the order of elements in an array along the given axis.\n\nThe shape of the array is preserved, but the elements are reordered.\n\nParameters\n----------\nm : array_like\n    Input array.\naxis : None or int or tuple of ints, optional\n     Axis or axes along which to flip over. The default,\n     axis=None, will flip over all of the axes of the input array.\n     If axis is negative it counts from the last to the first axis.\n\n     If axis is a tuple of ints, flipping is performed on all of the axes\n     specified in the tuple.\n\nReturns\n-------\nout : array_like\n    A view of `m` with the entries of axis reversed.  Since a view is\n    returned, this operation is done in constant time.\n\nSee Also\n--------\nflipud : Flip an array vertically (axis=0).\nfliplr : Flip an array horizontally (axis=1).\n\nNotes\n-----\nflip(m, 0) is equivalent to flipud(m).\n\nflip(m, 1) is equivalent to fliplr(m).\n\nflip(m, n) corresponds to ``m[...,::-1,...]`` with ``::-1`` at position n.\n\nflip(m) corresponds to ``m[::-1,::-1,...,::-1]`` with ``::-1`` at all\npositions.\n\nflip(m, (0, 1)) corresponds to ``m[::-1,::-1,...]`` with ``::-1`` at\nposition 0 and position 1.\n\nExamples\n--------\n>>> import numpy as np\n>>> A = np.arange(8).reshape((2,2,2))\n>>> A\narray([[[0, 1],\n        [2, 3]],\n       [[4, 5],\n        [6, 7]]])\n>>> np.flip(A, 0)\narray([[[4, 5],\n        [6, 7]],\n       [[0, 1],\n        [2, 3]]])\n>>> np.flip(A, 1)\narray([[[2, 3],\n        [0, 1]],\n       [[6, 7],\n        [4, 5]]])\n>>> np.flip(A)\narray([[[7, 6],\n        [5, 4]],\n       [[3, 2],\n        [1, 0]]])\n>>> np.flip(A, (0, 2))\narray([[[5, 4],\n        [7, 6]],\n       [[1, 0],\n        [3, 2]]])\n>>> rng = np.random.default_rng()\n>>> A = rng.normal(size=(3,4,5))\n>>> np.all(np.flip(A,2) == A[:,:,::-1,...])\nTrue"
    },
    {
      "name": "iterable",
      "docstring": "Check whether or not an object can be iterated over.\n\nParameters\n----------\ny : object\n  Input object.\n\nReturns\n-------\nb : bool\n  Return ``True`` if the object has an iterator method or is a\n  sequence and ``False`` otherwise.\n\n\nExamples\n--------\n>>> import numpy as np\n>>> np.iterable([1, 2, 3])\nTrue\n>>> np.iterable(2)\nFalse\n\nNotes\n-----\nIn most cases, the results of ``np.iterable(obj)`` are consistent with\n``isinstance(obj, collections.abc.Iterable)``. One notable exception is\nthe treatment of 0-dimensional arrays::\n\n    >>> from collections.abc import Iterable\n    >>> a = np.array(1.0)  # 0-dimensional numpy array\n    >>> isinstance(a, Iterable)\n    True\n    >>> np.iterable(a)\n    False"
    },
    {
      "name": "average",
      "docstring": "Compute the weighted average along the specified axis.\n\nParameters\n----------\na : array_like\n    Array containing data to be averaged. If `a` is not an array, a\n    conversion is attempted.\naxis : None or int or tuple of ints, optional\n    Axis or axes along which to average `a`.  The default,\n    `axis=None`, will average over all of the elements of the input array.\n    If axis is negative it counts from the last to the first axis.\n    If axis is a tuple of ints, averaging is performed on all of the axes\n    specified in the tuple instead of a single axis or all the axes as\n    before.\nweights : array_like, optional\n    An array of weights associated with the values in `a`. Each value in\n    `a` contributes to the average according to its associated weight.\n    The array of weights must be the same shape as `a` if no axis is\n    specified, otherwise the weights must have dimensions and shape\n    consistent with `a` along the specified axis.\n    If `weights=None`, then all data in `a` are assumed to have a\n    weight equal to one.\n    The calculation is::\n\n        avg = sum(a * weights) / sum(weights)\n\n    where the sum is over all included elements.\n    The only constraint on the values of `weights` is that `sum(weights)`\n    must not be 0.\nreturned : bool, optional\n    Default is `False`. If `True`, the tuple (`average`, `sum_of_weights`)\n    is returned, otherwise only the average is returned.\n    If `weights=None`, `sum_of_weights` is equivalent to the number of\n    elements over which the average is taken.\nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left\n    in the result as dimensions with size one. With this option,\n    the result will broadcast correctly against the original `a`.\n    *Note:* `keepdims` will not work with instances of `numpy.matrix`\n    or other classes whose methods do not support `keepdims`.\n\n    .. versionadded:: 1.23.0\n\nReturns\n-------\nretval, [sum_of_weights] : array_type or double\n    Return the average along the specified axis. When `returned` is `True`,\n    return a tuple with the average as the first element and the sum\n    of the weights as the second element. `sum_of_weights` is of the\n    same type as `retval`. The result dtype follows a general pattern.\n    If `weights` is None, the result dtype will be that of `a` , or ``float64``\n    if `a` is integral. Otherwise, if `weights` is not None and `a` is non-\n    integral, the result type will be the type of lowest precision capable of\n    representing values of both `a` and `weights`. If `a` happens to be\n    integral, the previous rules still applies but the result dtype will\n    at least be ``float64``.\n\nRaises\n------\nZeroDivisionError\n    When all weights along axis are zero. See `numpy.ma.average` for a\n    version robust to this type of error.\nTypeError\n    When `weights` does not have the same shape as `a`, and `axis=None`.\nValueError\n    When `weights` does not have dimensions and shape consistent with `a`\n    along specified `axis`.\n\nSee Also\n--------\nmean\n\nma.average : average for masked arrays -- useful if your data contains\n             \"missing\" values\nnumpy.result_type : Returns the type that results from applying the\n                    numpy type promotion rules to the arguments.\n\nExamples\n--------\n>>> import numpy as np\n>>> data = np.arange(1, 5)\n>>> data\narray([1, 2, 3, 4])\n>>> np.average(data)\n2.5\n>>> np.average(np.arange(1, 11), weights=np.arange(10, 0, -1))\n4.0\n\n>>> data = np.arange(6).reshape((3, 2))\n>>> data\narray([[0, 1],\n       [2, 3],\n       [4, 5]])\n>>> np.average(data, axis=1, weights=[1./4, 3./4])\narray([0.75, 2.75, 4.75])\n>>> np.average(data, weights=[1./4, 3./4])\nTraceback (most recent call last):\n    ...\nTypeError: Axis must be specified when shapes of a and weights differ.\n\nWith ``keepdims=True``, the following result has shape (3, 1).\n\n>>> np.average(data, axis=1, keepdims=True)\narray([[0.5],\n       [2.5],\n       [4.5]])\n\n>>> data = np.arange(8).reshape((2, 2, 2))\n>>> data\narray([[[0, 1],\n        [2, 3]],\n       [[4, 5],\n        [6, 7]]])\n>>> np.average(data, axis=(0, 1), weights=[[1./4, 3./4], [1., 1./2]])\narray([3.4, 4.4])\n>>> np.average(data, axis=0, weights=[[1./4, 3./4], [1., 1./2]])\nTraceback (most recent call last):\n    ...\nValueError: Shape of weights must be consistent\nwith shape of a along specified axis."
    },
    {
      "name": "asarray_chkfinite",
      "docstring": "Convert the input to an array, checking for NaNs or Infs.\n\nParameters\n----------\na : array_like\n    Input data, in any form that can be converted to an array.  This\n    includes lists, lists of tuples, tuples, tuples of tuples, tuples\n    of lists and ndarrays.  Success requires no NaNs or Infs.\ndtype : data-type, optional\n    By default, the data-type is inferred from the input data.\norder : {'C', 'F', 'A', 'K'}, optional\n    Memory layout.  'A' and 'K' depend on the order of input array a.\n    'C' row-major (C-style),\n    'F' column-major (Fortran-style) memory representation.\n    'A' (any) means 'F' if `a` is Fortran contiguous, 'C' otherwise\n    'K' (keep) preserve input order\n    Defaults to 'C'.\n\nReturns\n-------\nout : ndarray\n    Array interpretation of `a`.  No copy is performed if the input\n    is already an ndarray.  If `a` is a subclass of ndarray, a base\n    class ndarray is returned.\n\nRaises\n------\nValueError\n    Raises ValueError if `a` contains NaN (Not a Number) or Inf (Infinity).\n\nSee Also\n--------\nasarray : Create and array.\nasanyarray : Similar function which passes through subclasses.\nascontiguousarray : Convert input to a contiguous array.\nasfortranarray : Convert input to an ndarray with column-major\n                 memory order.\nfromiter : Create an array from an iterator.\nfromfunction : Construct an array by executing a function on grid\n               positions.\n\nExamples\n--------\n>>> import numpy as np\n\nConvert a list into an array. If all elements are finite, then\n``asarray_chkfinite`` is identical to ``asarray``.\n\n>>> a = [1, 2]\n>>> np.asarray_chkfinite(a, dtype=float)\narray([1., 2.])\n\nRaises ValueError if array_like contains Nans or Infs.\n\n>>> a = [1, 2, np.inf]\n>>> try:\n...     np.asarray_chkfinite(a)\n... except ValueError:\n...     print('ValueError')\n...\nValueError"
    },
    {
      "name": "piecewise",
      "docstring": "Evaluate a piecewise-defined function.\n\nGiven a set of conditions and corresponding functions, evaluate each\nfunction on the input data wherever its condition is true.\n\nParameters\n----------\nx : ndarray or scalar\n    The input domain.\ncondlist : list of bool arrays or bool scalars\n    Each boolean array corresponds to a function in `funclist`.  Wherever\n    `condlist[i]` is True, `funclist[i](x)` is used as the output value.\n\n    Each boolean array in `condlist` selects a piece of `x`,\n    and should therefore be of the same shape as `x`.\n\n    The length of `condlist` must correspond to that of `funclist`.\n    If one extra function is given, i.e. if\n    ``len(funclist) == len(condlist) + 1``, then that extra function\n    is the default value, used wherever all conditions are false.\nfunclist : list of callables, f(x,*args,**kw), or scalars\n    Each function is evaluated over `x` wherever its corresponding\n    condition is True.  It should take a 1d array as input and give an 1d\n    array or a scalar value as output.  If, instead of a callable,\n    a scalar is provided then a constant function (``lambda x: scalar``) is\n    assumed.\nargs : tuple, optional\n    Any further arguments given to `piecewise` are passed to the functions\n    upon execution, i.e., if called ``piecewise(..., ..., 1, 'a')``, then\n    each function is called as ``f(x, 1, 'a')``.\nkw : dict, optional\n    Keyword arguments used in calling `piecewise` are passed to the\n    functions upon execution, i.e., if called\n    ``piecewise(..., ..., alpha=1)``, then each function is called as\n    ``f(x, alpha=1)``.\n\nReturns\n-------\nout : ndarray\n    The output is the same shape and type as x and is found by\n    calling the functions in `funclist` on the appropriate portions of `x`,\n    as defined by the boolean arrays in `condlist`.  Portions not covered\n    by any condition have a default value of 0.\n\n\nSee Also\n--------\nchoose, select, where\n\nNotes\n-----\nThis is similar to choose or select, except that functions are\nevaluated on elements of `x` that satisfy the corresponding condition from\n`condlist`.\n\nThe result is::\n\n        |--\n        |funclist[0](x[condlist[0]])\n  out = |funclist[1](x[condlist[1]])\n        |...\n        |funclist[n2](x[condlist[n2]])\n        |--\n\nExamples\n--------\n>>> import numpy as np\n\nDefine the signum function, which is -1 for ``x < 0`` and +1 for ``x >= 0``.\n\n>>> x = np.linspace(-2.5, 2.5, 6)\n>>> np.piecewise(x, [x < 0, x >= 0], [-1, 1])\narray([-1., -1., -1.,  1.,  1.,  1.])\n\nDefine the absolute value, which is ``-x`` for ``x <0`` and ``x`` for\n``x >= 0``.\n\n>>> np.piecewise(x, [x < 0, x >= 0], [lambda x: -x, lambda x: x])\narray([2.5,  1.5,  0.5,  0.5,  1.5,  2.5])\n\nApply the same function to a scalar value.\n\n>>> y = -2\n>>> np.piecewise(y, [y < 0, y >= 0], [lambda x: -x, lambda x: x])\narray(2)"
    },
    {
      "name": "select",
      "docstring": "Return an array drawn from elements in choicelist, depending on conditions.\n\nParameters\n----------\ncondlist : list of bool ndarrays\n    The list of conditions which determine from which array in `choicelist`\n    the output elements are taken. When multiple conditions are satisfied,\n    the first one encountered in `condlist` is used.\nchoicelist : list of ndarrays\n    The list of arrays from which the output elements are taken. It has\n    to be of the same length as `condlist`.\ndefault : scalar, optional\n    The element inserted in `output` when all conditions evaluate to False.\n\nReturns\n-------\noutput : ndarray\n    The output at position m is the m-th element of the array in\n    `choicelist` where the m-th element of the corresponding array in\n    `condlist` is True.\n\nSee Also\n--------\nwhere : Return elements from one of two arrays depending on condition.\ntake, choose, compress, diag, diagonal\n\nExamples\n--------\n>>> import numpy as np\n\nBeginning with an array of integers from 0 to 5 (inclusive),\nelements less than ``3`` are negated, elements greater than ``3``\nare squared, and elements not meeting either of these conditions\n(exactly ``3``) are replaced with a `default` value of ``42``.\n\n>>> x = np.arange(6)\n>>> condlist = [x<3, x>3]\n>>> choicelist = [x, x**2]\n>>> np.select(condlist, choicelist, 42)\narray([ 0,  1,  2, 42, 16, 25])\n\nWhen multiple conditions are satisfied, the first one encountered in\n`condlist` is used.\n\n>>> condlist = [x<=4, x>3]\n>>> choicelist = [x, x**2]\n>>> np.select(condlist, choicelist, 55)\narray([ 0,  1,  2,  3,  4, 25])"
    },
    {
      "name": "copy",
      "docstring": "Return an array copy of the given object.\n\nParameters\n----------\na : array_like\n    Input data.\norder : {'C', 'F', 'A', 'K'}, optional\n    Controls the memory layout of the copy. 'C' means C-order,\n    'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,\n    'C' otherwise. 'K' means match the layout of `a` as closely\n    as possible. (Note that this function and :meth:`ndarray.copy` are very\n    similar, but have different default values for their order=\n    arguments.)\nsubok : bool, optional\n    If True, then sub-classes will be passed-through, otherwise the\n    returned array will be forced to be a base-class array (defaults to False).\n\nReturns\n-------\narr : ndarray\n    Array interpretation of `a`.\n\nSee Also\n--------\nndarray.copy : Preferred method for creating an array copy\n\nNotes\n-----\nThis is equivalent to:\n\n>>> np.array(a, copy=True)  #doctest: +SKIP\n\nThe copy made of the data is shallow, i.e., for arrays with object dtype,\nthe new array will point to the same objects.\nSee Examples from `ndarray.copy`.\n\nExamples\n--------\n>>> import numpy as np\n\nCreate an array x, with a reference y and a copy z:\n\n>>> x = np.array([1, 2, 3])\n>>> y = x\n>>> z = np.copy(x)\n\nNote that, when we modify x, y changes, but not z:\n\n>>> x[0] = 10\n>>> x[0] == y[0]\nTrue\n>>> x[0] == z[0]\nFalse\n\nNote that, np.copy clears previously set WRITEABLE=False flag.\n\n>>> a = np.array([1, 2, 3])\n>>> a.flags[\"WRITEABLE\"] = False\n>>> b = np.copy(a)\n>>> b.flags[\"WRITEABLE\"]\nTrue\n>>> b[0] = 3\n>>> b\narray([3, 2, 3])"
    },
    {
      "name": "gradient",
      "docstring": "Return the gradient of an N-dimensional array.\n\nThe gradient is computed using second order accurate central differences\nin the interior points and either first or second order accurate one-sides\n(forward or backwards) differences at the boundaries.\nThe returned gradient hence has the same shape as the input array.\n\nParameters\n----------\nf : array_like\n    An N-dimensional array containing samples of a scalar function.\nvarargs : list of scalar or array, optional\n    Spacing between f values. Default unitary spacing for all dimensions.\n    Spacing can be specified using:\n\n    1. single scalar to specify a sample distance for all dimensions.\n    2. N scalars to specify a constant sample distance for each dimension.\n       i.e. `dx`, `dy`, `dz`, ...\n    3. N arrays to specify the coordinates of the values along each\n       dimension of F. The length of the array must match the size of\n       the corresponding dimension\n    4. Any combination of N scalars/arrays with the meaning of 2. and 3.\n\n    If `axis` is given, the number of varargs must equal the number of axes.\n    Default: 1. (see Examples below).\n\nedge_order : {1, 2}, optional\n    Gradient is calculated using N-th order accurate differences\n    at the boundaries. Default: 1.\naxis : None or int or tuple of ints, optional\n    Gradient is calculated only along the given axis or axes\n    The default (axis = None) is to calculate the gradient for all the axes\n    of the input array. axis may be negative, in which case it counts from\n    the last to the first axis.\n\nReturns\n-------\ngradient : ndarray or tuple of ndarray\n    A tuple of ndarrays (or a single ndarray if there is only one\n    dimension) corresponding to the derivatives of f with respect\n    to each dimension. Each derivative has the same shape as f.\n\nExamples\n--------\n>>> import numpy as np\n>>> f = np.array([1, 2, 4, 7, 11, 16])\n>>> np.gradient(f)\narray([1. , 1.5, 2.5, 3.5, 4.5, 5. ])\n>>> np.gradient(f, 2)\narray([0.5 ,  0.75,  1.25,  1.75,  2.25,  2.5 ])\n\nSpacing can be also specified with an array that represents the coordinates\nof the values F along the dimensions.\nFor instance a uniform spacing:\n\n>>> x = np.arange(f.size)\n>>> np.gradient(f, x)\narray([1. ,  1.5,  2.5,  3.5,  4.5,  5. ])\n\nOr a non uniform one:\n\n>>> x = np.array([0., 1., 1.5, 3.5, 4., 6.])\n>>> np.gradient(f, x)\narray([1. ,  3. ,  3.5,  6.7,  6.9,  2.5])\n\nFor two dimensional arrays, the return will be two arrays ordered by\naxis. In this example the first array stands for the gradient in\nrows and the second one in columns direction:\n\n>>> np.gradient(np.array([[1, 2, 6], [3, 4, 5]]))\n(array([[ 2.,  2., -1.],\n        [ 2.,  2., -1.]]),\n array([[1. , 2.5, 4. ],\n        [1. , 1. , 1. ]]))\n\nIn this example the spacing is also specified:\nuniform for axis=0 and non uniform for axis=1\n\n>>> dx = 2.\n>>> y = [1., 1.5, 3.5]\n>>> np.gradient(np.array([[1, 2, 6], [3, 4, 5]]), dx, y)\n(array([[ 1. ,  1. , -0.5],\n        [ 1. ,  1. , -0.5]]),\n array([[2. , 2. , 2. ],\n        [2. , 1.7, 0.5]]))\n\nIt is possible to specify how boundaries are treated using `edge_order`\n\n>>> x = np.array([0, 1, 2, 3, 4])\n>>> f = x**2\n>>> np.gradient(f, edge_order=1)\narray([1.,  2.,  4.,  6.,  7.])\n>>> np.gradient(f, edge_order=2)\narray([0., 2., 4., 6., 8.])\n\nThe `axis` keyword can be used to specify a subset of axes of which the\ngradient is calculated\n\n>>> np.gradient(np.array([[1, 2, 6], [3, 4, 5]]), axis=0)\narray([[ 2.,  2., -1.],\n       [ 2.,  2., -1.]])\n\nThe `varargs` argument defines the spacing between sample points in the\ninput array. It can take two forms:\n\n1. An array, specifying coordinates, which may be unevenly spaced:\n\n>>> x = np.array([0., 2., 3., 6., 8.])\n>>> y = x ** 2\n>>> np.gradient(y, x, edge_order=2)\narray([ 0.,  4.,  6., 12., 16.])\n\n2. A scalar, representing the fixed sample distance:\n\n>>> dx = 2\n>>> x = np.array([0., 2., 4., 6., 8.])\n>>> y = x ** 2\n>>> np.gradient(y, dx, edge_order=2)\narray([ 0.,  4.,  8., 12., 16.])\n\nIt's possible to provide different data for spacing along each dimension.\nThe number of arguments must match the number of dimensions in the input\ndata.\n\n>>> dx = 2\n>>> dy = 3\n>>> x = np.arange(0, 6, dx)\n>>> y = np.arange(0, 9, dy)\n>>> xs, ys = np.meshgrid(x, y)\n>>> zs = xs + 2 * ys\n>>> np.gradient(zs, dy, dx)  # Passing two scalars\n(array([[2., 2., 2.],\n        [2., 2., 2.],\n        [2., 2., 2.]]),\n array([[1., 1., 1.],\n        [1., 1., 1.],\n        [1., 1., 1.]]))\n\nMixing scalars and arrays is also allowed:\n\n>>> np.gradient(zs, y, dx)  # Passing one array and one scalar\n(array([[2., 2., 2.],\n        [2., 2., 2.],\n        [2., 2., 2.]]),\n array([[1., 1., 1.],\n        [1., 1., 1.],\n        [1., 1., 1.]]))\n\nNotes\n-----\nAssuming that :math:`f\\in C^{3}` (i.e., :math:`f` has at least 3 continuous\nderivatives) and let :math:`h_{*}` be a non-homogeneous stepsize, we\nminimize the \"consistency error\" :math:`\\eta_{i}` between the true gradient\nand its estimate from a linear combination of the neighboring grid-points:\n\n.. math::\n\n    \\eta_{i} = f_{i}^{\\left(1\\right)} -\n                \\left[ \\alpha f\\left(x_{i}\\right) +\n                        \\beta f\\left(x_{i} + h_{d}\\right) +\n                        \\gamma f\\left(x_{i}-h_{s}\\right)\n                \\right]\n\nBy substituting :math:`f(x_{i} + h_{d})` and :math:`f(x_{i} - h_{s})`\nwith their Taylor series expansion, this translates into solving\nthe following the linear system:\n\n.. math::\n\n    \\left\\{\n        \\begin{array}{r}\n            \\alpha+\\beta+\\gamma=0 \\\\\n            \\beta h_{d}-\\gamma h_{s}=1 \\\\\n            \\beta h_{d}^{2}+\\gamma h_{s}^{2}=0\n        \\end{array}\n    \\right.\n\nThe resulting approximation of :math:`f_{i}^{(1)}` is the following:\n\n.. math::\n\n    \\hat f_{i}^{(1)} =\n        \\frac{\n            h_{s}^{2}f\\left(x_{i} + h_{d}\\right)\n            + \\left(h_{d}^{2} - h_{s}^{2}\\right)f\\left(x_{i}\\right)\n            - h_{d}^{2}f\\left(x_{i}-h_{s}\\right)}\n            { h_{s}h_{d}\\left(h_{d} + h_{s}\\right)}\n        + \\mathcal{O}\\left(\\frac{h_{d}h_{s}^{2}\n                            + h_{s}h_{d}^{2}}{h_{d}\n                            + h_{s}}\\right)\n\nIt is worth noting that if :math:`h_{s}=h_{d}`\n(i.e., data are evenly spaced)\nwe find the standard second order approximation:\n\n.. math::\n\n    \\hat f_{i}^{(1)}=\n        \\frac{f\\left(x_{i+1}\\right) - f\\left(x_{i-1}\\right)}{2h}\n        + \\mathcal{O}\\left(h^{2}\\right)\n\nWith a similar procedure the forward/backward approximations used for\nboundaries can be derived.\n\nReferences\n----------\n.. [1]  Quarteroni A., Sacco R., Saleri F. (2007) Numerical Mathematics\n        (Texts in Applied Mathematics). New York: Springer.\n.. [2]  Durran D. R. (1999) Numerical Methods for Wave Equations\n        in Geophysical Fluid Dynamics. New York: Springer.\n.. [3]  Fornberg B. (1988) Generation of Finite Difference Formulas on\n        Arbitrarily Spaced Grids,\n        Mathematics of Computation 51, no. 184 : 699-706.\n        `PDF <https://www.ams.org/journals/mcom/1988-51-184/\n        S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf>`_."
    },
    {
      "name": "diff",
      "docstring": "Calculate the n-th discrete difference along the given axis.\n\nThe first difference is given by ``out[i] = a[i+1] - a[i]`` along\nthe given axis, higher differences are calculated by using `diff`\nrecursively.\n\nParameters\n----------\na : array_like\n    Input array\nn : int, optional\n    The number of times values are differenced. If zero, the input\n    is returned as-is.\naxis : int, optional\n    The axis along which the difference is taken, default is the\n    last axis.\nprepend, append : array_like, optional\n    Values to prepend or append to `a` along axis prior to\n    performing the difference.  Scalar values are expanded to\n    arrays with length 1 in the direction of axis and the shape\n    of the input array in along all other axes.  Otherwise the\n    dimension and shape must match `a` except along axis.\n\nReturns\n-------\ndiff : ndarray\n    The n-th differences. The shape of the output is the same as `a`\n    except along `axis` where the dimension is smaller by `n`. The\n    type of the output is the same as the type of the difference\n    between any two elements of `a`. This is the same as the type of\n    `a` in most cases. A notable exception is `datetime64`, which\n    results in a `timedelta64` output array.\n\nSee Also\n--------\ngradient, ediff1d, cumsum\n\nNotes\n-----\nType is preserved for boolean arrays, so the result will contain\n`False` when consecutive elements are the same and `True` when they\ndiffer.\n\nFor unsigned integer arrays, the results will also be unsigned. This\nshould not be surprising, as the result is consistent with\ncalculating the difference directly:\n\n>>> u8_arr = np.array([1, 0], dtype=np.uint8)\n>>> np.diff(u8_arr)\narray([255], dtype=uint8)\n>>> u8_arr[1,...] - u8_arr[0,...]\nnp.uint8(255)\n\nIf this is not desirable, then the array should be cast to a larger\ninteger type first:\n\n>>> i16_arr = u8_arr.astype(np.int16)\n>>> np.diff(i16_arr)\narray([-1], dtype=int16)\n\nExamples\n--------\n>>> import numpy as np\n>>> x = np.array([1, 2, 4, 7, 0])\n>>> np.diff(x)\narray([ 1,  2,  3, -7])\n>>> np.diff(x, n=2)\narray([  1,   1, -10])\n\n>>> x = np.array([[1, 3, 6, 10], [0, 5, 6, 8]])\n>>> np.diff(x)\narray([[2, 3, 4],\n       [5, 1, 2]])\n>>> np.diff(x, axis=0)\narray([[-1,  2,  0, -2]])\n\n>>> x = np.arange('1066-10-13', '1066-10-16', dtype=np.datetime64)\n>>> np.diff(x)\narray([1, 1], dtype='timedelta64[D]')"
    },
    {
      "name": "interp",
      "docstring": "One-dimensional linear interpolation for monotonically increasing sample points.\n\nReturns the one-dimensional piecewise linear interpolant to a function\nwith given discrete data points (`xp`, `fp`), evaluated at `x`.\n\nParameters\n----------\nx : array_like\n    The x-coordinates at which to evaluate the interpolated values.\n\nxp : 1-D sequence of floats\n    The x-coordinates of the data points, must be increasing if argument\n    `period` is not specified. Otherwise, `xp` is internally sorted after\n    normalizing the periodic boundaries with ``xp = xp % period``.\n\nfp : 1-D sequence of float or complex\n    The y-coordinates of the data points, same length as `xp`.\n\nleft : optional float or complex corresponding to fp\n    Value to return for `x < xp[0]`, default is `fp[0]`.\n\nright : optional float or complex corresponding to fp\n    Value to return for `x > xp[-1]`, default is `fp[-1]`.\n\nperiod : None or float, optional\n    A period for the x-coordinates. This parameter allows the proper\n    interpolation of angular x-coordinates. Parameters `left` and `right`\n    are ignored if `period` is specified.\n\nReturns\n-------\ny : float or complex (corresponding to fp) or ndarray\n    The interpolated values, same shape as `x`.\n\nRaises\n------\nValueError\n    If `xp` and `fp` have different length\n    If `xp` or `fp` are not 1-D sequences\n    If `period == 0`\n\nSee Also\n--------\nscipy.interpolate\n\nWarnings\n--------\nThe x-coordinate sequence is expected to be increasing, but this is not\nexplicitly enforced.  However, if the sequence `xp` is non-increasing,\ninterpolation results are meaningless.\n\nNote that, since NaN is unsortable, `xp` also cannot contain NaNs.\n\nA simple check for `xp` being strictly increasing is::\n\n    np.all(np.diff(xp) > 0)\n\nExamples\n--------\n>>> import numpy as np\n>>> xp = [1, 2, 3]\n>>> fp = [3, 2, 0]\n>>> np.interp(2.5, xp, fp)\n1.0\n>>> np.interp([0, 1, 1.5, 2.72, 3.14], xp, fp)\narray([3.  , 3.  , 2.5 , 0.56, 0.  ])\n>>> UNDEF = -99.0\n>>> np.interp(3.14, xp, fp, right=UNDEF)\n-99.0\n\nPlot an interpolant to the sine function:\n\n>>> x = np.linspace(0, 2*np.pi, 10)\n>>> y = np.sin(x)\n>>> xvals = np.linspace(0, 2*np.pi, 50)\n>>> yinterp = np.interp(xvals, x, y)\n>>> import matplotlib.pyplot as plt\n>>> plt.plot(x, y, 'o')\n[<matplotlib.lines.Line2D object at 0x...>]\n>>> plt.plot(xvals, yinterp, '-x')\n[<matplotlib.lines.Line2D object at 0x...>]\n>>> plt.show()\n\nInterpolation with periodic x-coordinates:\n\n>>> x = [-180, -170, -185, 185, -10, -5, 0, 365]\n>>> xp = [190, -190, 350, -350]\n>>> fp = [5, 10, 3, 4]\n>>> np.interp(x, xp, fp, period=360)\narray([7.5 , 5.  , 8.75, 6.25, 3.  , 3.25, 3.5 , 3.75])\n\nComplex interpolation:\n\n>>> x = [1.5, 4.0]\n>>> xp = [2,3,5]\n>>> fp = [1.0j, 0, 2+3j]\n>>> np.interp(x, xp, fp)\narray([0.+1.j , 1.+1.5j])"
    },
    {
      "name": "angle",
      "docstring": "Return the angle of the complex argument.\n\nParameters\n----------\nz : array_like\n    A complex number or sequence of complex numbers.\ndeg : bool, optional\n    Return angle in degrees if True, radians if False (default).\n\nReturns\n-------\nangle : ndarray or scalar\n    The counterclockwise angle from the positive real axis on the complex\n    plane in the range ``(-pi, pi]``, with dtype as numpy.float64.\n\nSee Also\n--------\narctan2\nabsolute\n\nNotes\n-----\nThis function passes the imaginary and real parts of the argument to\n`arctan2` to compute the result; consequently, it follows the convention\nof `arctan2` when the magnitude of the argument is zero. See example.\n\nExamples\n--------\n>>> import numpy as np\n>>> np.angle([1.0, 1.0j, 1+1j])               # in radians\narray([ 0.        ,  1.57079633,  0.78539816]) # may vary\n>>> np.angle(1+1j, deg=True)                  # in degrees\n45.0\n>>> np.angle([0., -0., complex(0., -0.), complex(-0., -0.)])  # convention\narray([ 0.        ,  3.14159265, -0.        , -3.14159265])"
    },
    {
      "name": "unwrap",
      "docstring": "Unwrap by taking the complement of large deltas with respect to the period.\n\nThis unwraps a signal `p` by changing elements which have an absolute\ndifference from their predecessor of more than ``max(discont, period/2)``\nto their `period`-complementary values.\n\nFor the default case where `period` is :math:`2\\pi` and `discont` is\n:math:`\\pi`, this unwraps a radian phase `p` such that adjacent differences\nare never greater than :math:`\\pi` by adding :math:`2k\\pi` for some\ninteger :math:`k`.\n\nParameters\n----------\np : array_like\n    Input array.\ndiscont : float, optional\n    Maximum discontinuity between values, default is ``period/2``.\n    Values below ``period/2`` are treated as if they were ``period/2``.\n    To have an effect different from the default, `discont` should be\n    larger than ``period/2``.\naxis : int, optional\n    Axis along which unwrap will operate, default is the last axis.\nperiod : float, optional\n    Size of the range over which the input wraps. By default, it is\n    ``2 pi``.\n\n    .. versionadded:: 1.21.0\n\nReturns\n-------\nout : ndarray\n    Output array.\n\nSee Also\n--------\nrad2deg, deg2rad\n\nNotes\n-----\nIf the discontinuity in `p` is smaller than ``period/2``,\nbut larger than `discont`, no unwrapping is done because taking\nthe complement would only make the discontinuity larger.\n\nExamples\n--------\n>>> import numpy as np\n>>> phase = np.linspace(0, np.pi, num=5)\n>>> phase[3:] += np.pi\n>>> phase\narray([ 0.        ,  0.78539816,  1.57079633,  5.49778714,  6.28318531]) # may vary\n>>> np.unwrap(phase)\narray([ 0.        ,  0.78539816,  1.57079633, -0.78539816,  0.        ]) # may vary\n>>> np.unwrap([0, 1, 2, -1, 0], period=4)\narray([0, 1, 2, 3, 4])\n>>> np.unwrap([ 1, 2, 3, 4, 5, 6, 1, 2, 3], period=6)\narray([1, 2, 3, 4, 5, 6, 7, 8, 9])\n>>> np.unwrap([2, 3, 4, 5, 2, 3, 4, 5], period=4)\narray([2, 3, 4, 5, 6, 7, 8, 9])\n>>> phase_deg = np.mod(np.linspace(0 ,720, 19), 360) - 180\n>>> np.unwrap(phase_deg, period=360)\narray([-180., -140., -100.,  -60.,  -20.,   20.,   60.,  100.,  140.,\n        180.,  220.,  260.,  300.,  340.,  380.,  420.,  460.,  500.,\n        540.])"
    },
    {
      "name": "sort_complex",
      "docstring": "Sort a complex array using the real part first, then the imaginary part.\n\nParameters\n----------\na : array_like\n    Input array\n\nReturns\n-------\nout : complex ndarray\n    Always returns a sorted complex array.\n\nExamples\n--------\n>>> import numpy as np\n>>> np.sort_complex([5, 3, 6, 2, 1])\narray([1.+0.j, 2.+0.j, 3.+0.j, 5.+0.j, 6.+0.j])\n\n>>> np.sort_complex([1 + 2j, 2 - 1j, 3 - 2j, 3 - 3j, 3 + 5j])\narray([1.+2.j,  2.-1.j,  3.-3.j,  3.-2.j,  3.+5.j])"
    },
    {
      "name": "trim_zeros",
      "docstring": "Remove values along a dimension which are zero along all other.\n\nParameters\n----------\nfilt : array_like\n    Input array.\ntrim : {\"fb\", \"f\", \"b\"}, optional\n    A string with 'f' representing trim from front and 'b' to trim from\n    back. By default, zeros are trimmed on both sides.\n    Front and back refer to the edges of a dimension, with \"front\" refering\n    to the side with the lowest index 0, and \"back\" refering to the highest\n    index (or index -1).\naxis : int or sequence, optional\n    If None, `filt` is cropped such, that the smallest bounding box is\n    returned that still contains all values which are not zero.\n    If an axis is specified, `filt` will be sliced in that dimension only\n    on the sides specified by `trim`. The remaining area will be the\n    smallest that still contains all values wich are not zero.\n\nReturns\n-------\ntrimmed : ndarray or sequence\n    The result of trimming the input. The number of dimensions and the\n    input data type are preserved.\n\nNotes\n-----\nFor all-zero arrays, the first axis is trimmed first.\n\nExamples\n--------\n>>> import numpy as np\n>>> a = np.array((0, 0, 0, 1, 2, 3, 0, 2, 1, 0))\n>>> np.trim_zeros(a)\narray([1, 2, 3, 0, 2, 1])\n\n>>> np.trim_zeros(a, trim='b')\narray([0, 0, 0, ..., 0, 2, 1])\n\nMultiple dimensions are supported.\n\n>>> b = np.array([[0, 0, 2, 3, 0, 0],\n...               [0, 1, 0, 3, 0, 0],\n...               [0, 0, 0, 0, 0, 0]])\n>>> np.trim_zeros(b)\narray([[0, 2, 3],\n       [1, 0, 3]])\n\n>>> np.trim_zeros(b, axis=-1)\narray([[0, 2, 3],\n       [1, 0, 3],\n       [0, 0, 0]])\n\nThe input data type is preserved, list/tuple in means list/tuple out.\n\n>>> np.trim_zeros([0, 1, 2, 0])\n[1, 2]"
    },
    {
      "name": "extract",
      "docstring": "Return the elements of an array that satisfy some condition.\n\nThis is equivalent to ``np.compress(ravel(condition), ravel(arr))``.  If\n`condition` is boolean ``np.extract`` is equivalent to ``arr[condition]``.\n\nNote that `place` does the exact opposite of `extract`.\n\nParameters\n----------\ncondition : array_like\n    An array whose nonzero or True entries indicate the elements of `arr`\n    to extract.\narr : array_like\n    Input array of the same size as `condition`.\n\nReturns\n-------\nextract : ndarray\n    Rank 1 array of values from `arr` where `condition` is True.\n\nSee Also\n--------\ntake, put, copyto, compress, place\n\nExamples\n--------\n>>> import numpy as np\n>>> arr = np.arange(12).reshape((3, 4))\n>>> arr\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])\n>>> condition = np.mod(arr, 3)==0\n>>> condition\narray([[ True, False, False,  True],\n       [False, False,  True, False],\n       [False,  True, False, False]])\n>>> np.extract(condition, arr)\narray([0, 3, 6, 9])\n\n\nIf `condition` is boolean:\n\n>>> arr[condition]\narray([0, 3, 6, 9])"
    },
    {
      "name": "place",
      "docstring": "Change elements of an array based on conditional and input values.\n\nSimilar to ``np.copyto(arr, vals, where=mask)``, the difference is that\n`place` uses the first N elements of `vals`, where N is the number of\nTrue values in `mask`, while `copyto` uses the elements where `mask`\nis True.\n\nNote that `extract` does the exact opposite of `place`.\n\nParameters\n----------\narr : ndarray\n    Array to put data into.\nmask : array_like\n    Boolean mask array. Must have the same size as `a`.\nvals : 1-D sequence\n    Values to put into `a`. Only the first N elements are used, where\n    N is the number of True values in `mask`. If `vals` is smaller\n    than N, it will be repeated, and if elements of `a` are to be masked,\n    this sequence must be non-empty.\n\nSee Also\n--------\ncopyto, put, take, extract\n\nExamples\n--------\n>>> import numpy as np\n>>> arr = np.arange(6).reshape(2, 3)\n>>> np.place(arr, arr>2, [44, 55])\n>>> arr\narray([[ 0,  1,  2],\n       [44, 55, 44]])"
    },
    {
      "name": "disp",
      "docstring": "Display a message on a device.\n\n.. deprecated:: 2.0\n    Use your own printing function instead.\n\nParameters\n----------\nmesg : str\n    Message to display.\ndevice : object\n    Device to write message. If None, defaults to ``sys.stdout`` which is\n    very similar to ``print``. `device` needs to have ``write()`` and\n    ``flush()`` methods.\nlinefeed : bool, optional\n    Option whether to print a line feed or not. Defaults to True.\n\nRaises\n------\nAttributeError\n    If `device` does not have a ``write()`` or ``flush()`` method.\n\nExamples\n--------\n>>> import numpy as np\n\nBesides ``sys.stdout``, a file-like object can also be used as it has\nboth required methods:\n\n>>> from io import StringIO\n>>> buf = StringIO()\n>>> np.disp('\"Display\" in a file', device=buf)\n>>> buf.getvalue()\n'\"Display\" in a file\\n'"
    },
    {
      "name": "cov",
      "docstring": "Estimate a covariance matrix, given data and weights.\n\nCovariance indicates the level to which two variables vary together.\nIf we examine N-dimensional samples, :math:`X = [x_1, x_2, ... x_N]^T`,\nthen the covariance matrix element :math:`C_{ij}` is the covariance of\n:math:`x_i` and :math:`x_j`. The element :math:`C_{ii}` is the variance\nof :math:`x_i`.\n\nSee the notes for an outline of the algorithm.\n\nParameters\n----------\nm : array_like\n    A 1-D or 2-D array containing multiple variables and observations.\n    Each row of `m` represents a variable, and each column a single\n    observation of all those variables. Also see `rowvar` below.\ny : array_like, optional\n    An additional set of variables and observations. `y` has the same form\n    as that of `m`.\nrowvar : bool, optional\n    If `rowvar` is True (default), then each row represents a\n    variable, with observations in the columns. Otherwise, the relationship\n    is transposed: each column represents a variable, while the rows\n    contain observations.\nbias : bool, optional\n    Default normalization (False) is by ``(N - 1)``, where ``N`` is the\n    number of observations given (unbiased estimate). If `bias` is True,\n    then normalization is by ``N``. These values can be overridden by using\n    the keyword ``ddof`` in numpy versions >= 1.5.\nddof : int, optional\n    If not ``None`` the default value implied by `bias` is overridden.\n    Note that ``ddof=1`` will return the unbiased estimate, even if both\n    `fweights` and `aweights` are specified, and ``ddof=0`` will return\n    the simple average. See the notes for the details. The default value\n    is ``None``.\nfweights : array_like, int, optional\n    1-D array of integer frequency weights; the number of times each\n    observation vector should be repeated.\naweights : array_like, optional\n    1-D array of observation vector weights. These relative weights are\n    typically large for observations considered \"important\" and smaller for\n    observations considered less \"important\". If ``ddof=0`` the array of\n    weights can be used to assign probabilities to observation vectors.\ndtype : data-type, optional\n    Data-type of the result. By default, the return data-type will have\n    at least `numpy.float64` precision.\n\n    .. versionadded:: 1.20\n\nReturns\n-------\nout : ndarray\n    The covariance matrix of the variables.\n\nSee Also\n--------\ncorrcoef : Normalized covariance matrix\n\nNotes\n-----\nAssume that the observations are in the columns of the observation\narray `m` and let ``f = fweights`` and ``a = aweights`` for brevity. The\nsteps to compute the weighted covariance are as follows::\n\n    >>> m = np.arange(10, dtype=np.float64)\n    >>> f = np.arange(10) * 2\n    >>> a = np.arange(10) ** 2.\n    >>> ddof = 1\n    >>> w = f * a\n    >>> v1 = np.sum(w)\n    >>> v2 = np.sum(w * a)\n    >>> m -= np.sum(m * w, axis=None, keepdims=True) / v1\n    >>> cov = np.dot(m * w, m.T) * v1 / (v1**2 - ddof * v2)\n\nNote that when ``a == 1``, the normalization factor\n``v1 / (v1**2 - ddof * v2)`` goes over to ``1 / (np.sum(f) - ddof)``\nas it should.\n\nExamples\n--------\n>>> import numpy as np\n\nConsider two variables, :math:`x_0` and :math:`x_1`, which\ncorrelate perfectly, but in opposite directions:\n\n>>> x = np.array([[0, 2], [1, 1], [2, 0]]).T\n>>> x\narray([[0, 1, 2],\n       [2, 1, 0]])\n\nNote how :math:`x_0` increases while :math:`x_1` decreases. The covariance\nmatrix shows this clearly:\n\n>>> np.cov(x)\narray([[ 1., -1.],\n       [-1.,  1.]])\n\nNote that element :math:`C_{0,1}`, which shows the correlation between\n:math:`x_0` and :math:`x_1`, is negative.\n\nFurther, note how `x` and `y` are combined:\n\n>>> x = [-2.1, -1,  4.3]\n>>> y = [3,  1.1,  0.12]\n>>> X = np.stack((x, y), axis=0)\n>>> np.cov(X)\narray([[11.71      , -4.286     ], # may vary\n       [-4.286     ,  2.144133]])\n>>> np.cov(x, y)\narray([[11.71      , -4.286     ], # may vary\n       [-4.286     ,  2.144133]])\n>>> np.cov(x)\narray(11.71)"
    },
    {
      "name": "corrcoef",
      "docstring": "Return Pearson product-moment correlation coefficients.\n\nPlease refer to the documentation for `cov` for more detail.  The\nrelationship between the correlation coefficient matrix, `R`, and the\ncovariance matrix, `C`, is\n\n.. math:: R_{ij} = \\frac{ C_{ij} } { \\sqrt{ C_{ii} C_{jj} } }\n\nThe values of `R` are between -1 and 1, inclusive.\n\nParameters\n----------\nx : array_like\n    A 1-D or 2-D array containing multiple variables and observations.\n    Each row of `x` represents a variable, and each column a single\n    observation of all those variables. Also see `rowvar` below.\ny : array_like, optional\n    An additional set of variables and observations. `y` has the same\n    shape as `x`.\nrowvar : bool, optional\n    If `rowvar` is True (default), then each row represents a\n    variable, with observations in the columns. Otherwise, the relationship\n    is transposed: each column represents a variable, while the rows\n    contain observations.\nbias : _NoValue, optional\n    Has no effect, do not use.\n\n    .. deprecated:: 1.10.0\nddof : _NoValue, optional\n    Has no effect, do not use.\n\n    .. deprecated:: 1.10.0\ndtype : data-type, optional\n    Data-type of the result. By default, the return data-type will have\n    at least `numpy.float64` precision.\n\n    .. versionadded:: 1.20\n\nReturns\n-------\nR : ndarray\n    The correlation coefficient matrix of the variables.\n\nSee Also\n--------\ncov : Covariance matrix\n\nNotes\n-----\nDue to floating point rounding the resulting array may not be Hermitian,\nthe diagonal elements may not be 1, and the elements may not satisfy the\ninequality abs(a) <= 1. The real and imaginary parts are clipped to the\ninterval [-1,  1] in an attempt to improve on that situation but is not\nmuch help in the complex case.\n\nThis function accepts but discards arguments `bias` and `ddof`.  This is\nfor backwards compatibility with previous versions of this function.  These\narguments had no effect on the return values of the function and can be\nsafely ignored in this and previous versions of numpy.\n\nExamples\n--------\n>>> import numpy as np\n\nIn this example we generate two random arrays, ``xarr`` and ``yarr``, and\ncompute the row-wise and column-wise Pearson correlation coefficients,\n``R``. Since ``rowvar`` is  true by  default, we first find the row-wise\nPearson correlation coefficients between the variables of ``xarr``.\n\n>>> import numpy as np\n>>> rng = np.random.default_rng(seed=42)\n>>> xarr = rng.random((3, 3))\n>>> xarr\narray([[0.77395605, 0.43887844, 0.85859792],\n       [0.69736803, 0.09417735, 0.97562235],\n       [0.7611397 , 0.78606431, 0.12811363]])\n>>> R1 = np.corrcoef(xarr)\n>>> R1\narray([[ 1.        ,  0.99256089, -0.68080986],\n       [ 0.99256089,  1.        , -0.76492172],\n       [-0.68080986, -0.76492172,  1.        ]])\n\nIf we add another set of variables and observations ``yarr``, we can\ncompute the row-wise Pearson correlation coefficients between the\nvariables in ``xarr`` and ``yarr``.\n\n>>> yarr = rng.random((3, 3))\n>>> yarr\narray([[0.45038594, 0.37079802, 0.92676499],\n       [0.64386512, 0.82276161, 0.4434142 ],\n       [0.22723872, 0.55458479, 0.06381726]])\n>>> R2 = np.corrcoef(xarr, yarr)\n>>> R2\narray([[ 1.        ,  0.99256089, -0.68080986,  0.75008178, -0.934284  ,\n        -0.99004057],\n       [ 0.99256089,  1.        , -0.76492172,  0.82502011, -0.97074098,\n        -0.99981569],\n       [-0.68080986, -0.76492172,  1.        , -0.99507202,  0.89721355,\n         0.77714685],\n       [ 0.75008178,  0.82502011, -0.99507202,  1.        , -0.93657855,\n        -0.83571711],\n       [-0.934284  , -0.97074098,  0.89721355, -0.93657855,  1.        ,\n         0.97517215],\n       [-0.99004057, -0.99981569,  0.77714685, -0.83571711,  0.97517215,\n         1.        ]])\n\nFinally if we use the option ``rowvar=False``, the columns are now\nbeing treated as the variables and we will find the column-wise Pearson\ncorrelation coefficients between variables in ``xarr`` and ``yarr``.\n\n>>> R3 = np.corrcoef(xarr, yarr, rowvar=False)\n>>> R3\narray([[ 1.        ,  0.77598074, -0.47458546, -0.75078643, -0.9665554 ,\n         0.22423734],\n       [ 0.77598074,  1.        , -0.92346708, -0.99923895, -0.58826587,\n        -0.44069024],\n       [-0.47458546, -0.92346708,  1.        ,  0.93773029,  0.23297648,\n         0.75137473],\n       [-0.75078643, -0.99923895,  0.93773029,  1.        ,  0.55627469,\n         0.47536961],\n       [-0.9665554 , -0.58826587,  0.23297648,  0.55627469,  1.        ,\n        -0.46666491],\n       [ 0.22423734, -0.44069024,  0.75137473,  0.47536961, -0.46666491,\n         1.        ]])"
    },
    {
      "name": "blackman",
      "docstring": "Return the Blackman window.\n\nThe Blackman window is a taper formed by using the first three\nterms of a summation of cosines. It was designed to have close to the\nminimal leakage possible.  It is close to optimal, only slightly worse\nthan a Kaiser window.\n\nParameters\n----------\nM : int\n    Number of points in the output window. If zero or less, an empty\n    array is returned.\n\nReturns\n-------\nout : ndarray\n    The window, with the maximum value normalized to one (the value one\n    appears only if the number of samples is odd).\n\nSee Also\n--------\nbartlett, hamming, hanning, kaiser\n\nNotes\n-----\nThe Blackman window is defined as\n\n.. math::  w(n) = 0.42 - 0.5 \\cos(2\\pi n/M) + 0.08 \\cos(4\\pi n/M)\n\nMost references to the Blackman window come from the signal processing\nliterature, where it is used as one of many windowing functions for\nsmoothing values.  It is also known as an apodization (which means\n\"removing the foot\", i.e. smoothing discontinuities at the beginning\nand end of the sampled signal) or tapering function. It is known as a\n\"near optimal\" tapering function, almost as good (by some measures)\nas the kaiser window.\n\nReferences\n----------\nBlackman, R.B. and Tukey, J.W., (1958) The measurement of power spectra,\nDover Publications, New York.\n\nOppenheim, A.V., and R.W. Schafer. Discrete-Time Signal Processing.\nUpper Saddle River, NJ: Prentice-Hall, 1999, pp. 468-471.\n\nExamples\n--------\n>>> import numpy as np\n>>> import matplotlib.pyplot as plt\n>>> np.blackman(12)\narray([-1.38777878e-17,   3.26064346e-02,   1.59903635e-01, # may vary\n        4.14397981e-01,   7.36045180e-01,   9.67046769e-01,\n        9.67046769e-01,   7.36045180e-01,   4.14397981e-01,\n        1.59903635e-01,   3.26064346e-02,  -1.38777878e-17])\n\nPlot the window and the frequency response.\n\n.. plot::\n    :include-source:\n\n    import matplotlib.pyplot as plt\n    from numpy.fft import fft, fftshift\n    window = np.blackman(51)\n    plt.plot(window)\n    plt.title(\"Blackman window\")\n    plt.ylabel(\"Amplitude\")\n    plt.xlabel(\"Sample\")\n    plt.show()  # doctest: +SKIP\n\n    plt.figure()\n    A = fft(window, 2048) / 25.5\n    mag = np.abs(fftshift(A))\n    freq = np.linspace(-0.5, 0.5, len(A))\n    with np.errstate(divide='ignore', invalid='ignore'):\n        response = 20 * np.log10(mag)\n    response = np.clip(response, -100, 100)\n    plt.plot(freq, response)\n    plt.title(\"Frequency response of Blackman window\")\n    plt.ylabel(\"Magnitude [dB]\")\n    plt.xlabel(\"Normalized frequency [cycles per sample]\")\n    plt.axis('tight')\n    plt.show()"
    },
    {
      "name": "bartlett",
      "docstring": "Return the Bartlett window.\n\nThe Bartlett window is very similar to a triangular window, except\nthat the end points are at zero.  It is often used in signal\nprocessing for tapering a signal, without generating too much\nripple in the frequency domain.\n\nParameters\n----------\nM : int\n    Number of points in the output window. If zero or less, an\n    empty array is returned.\n\nReturns\n-------\nout : array\n    The triangular window, with the maximum value normalized to one\n    (the value one appears only if the number of samples is odd), with\n    the first and last samples equal to zero.\n\nSee Also\n--------\nblackman, hamming, hanning, kaiser\n\nNotes\n-----\nThe Bartlett window is defined as\n\n.. math:: w(n) = \\frac{2}{M-1} \\left(\n          \\frac{M-1}{2} - \\left|n - \\frac{M-1}{2}\\right|\n          \\right)\n\nMost references to the Bartlett window come from the signal processing\nliterature, where it is used as one of many windowing functions for\nsmoothing values.  Note that convolution with this window produces linear\ninterpolation.  It is also known as an apodization (which means \"removing\nthe foot\", i.e. smoothing discontinuities at the beginning and end of the\nsampled signal) or tapering function. The Fourier transform of the\nBartlett window is the product of two sinc functions. Note the excellent\ndiscussion in Kanasewich [2]_.\n\nReferences\n----------\n.. [1] M.S. Bartlett, \"Periodogram Analysis and Continuous Spectra\",\n       Biometrika 37, 1-16, 1950.\n.. [2] E.R. Kanasewich, \"Time Sequence Analysis in Geophysics\",\n       The University of Alberta Press, 1975, pp. 109-110.\n.. [3] A.V. Oppenheim and R.W. Schafer, \"Discrete-Time Signal\n       Processing\", Prentice-Hall, 1999, pp. 468-471.\n.. [4] Wikipedia, \"Window function\",\n       https://en.wikipedia.org/wiki/Window_function\n.. [5] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,\n       \"Numerical Recipes\", Cambridge University Press, 1986, page 429.\n\nExamples\n--------\n>>> import numpy as np\n>>> import matplotlib.pyplot as plt\n>>> np.bartlett(12)\narray([ 0.        ,  0.18181818,  0.36363636,  0.54545455,  0.72727273, # may vary\n        0.90909091,  0.90909091,  0.72727273,  0.54545455,  0.36363636,\n        0.18181818,  0.        ])\n\nPlot the window and its frequency response (requires SciPy and matplotlib).\n\n.. plot::\n    :include-source:\n\n    import matplotlib.pyplot as plt\n    from numpy.fft import fft, fftshift\n    window = np.bartlett(51)\n    plt.plot(window)\n    plt.title(\"Bartlett window\")\n    plt.ylabel(\"Amplitude\")\n    plt.xlabel(\"Sample\")\n    plt.show()\n    plt.figure()\n    A = fft(window, 2048) / 25.5\n    mag = np.abs(fftshift(A))\n    freq = np.linspace(-0.5, 0.5, len(A))\n    with np.errstate(divide='ignore', invalid='ignore'):\n        response = 20 * np.log10(mag)\n    response = np.clip(response, -100, 100)\n    plt.plot(freq, response)\n    plt.title(\"Frequency response of Bartlett window\")\n    plt.ylabel(\"Magnitude [dB]\")\n    plt.xlabel(\"Normalized frequency [cycles per sample]\")\n    plt.axis('tight')\n    plt.show()"
    },
    {
      "name": "hanning",
      "docstring": "Return the Hanning window.\n\nThe Hanning window is a taper formed by using a weighted cosine.\n\nParameters\n----------\nM : int\n    Number of points in the output window. If zero or less, an\n    empty array is returned.\n\nReturns\n-------\nout : ndarray, shape(M,)\n    The window, with the maximum value normalized to one (the value\n    one appears only if `M` is odd).\n\nSee Also\n--------\nbartlett, blackman, hamming, kaiser\n\nNotes\n-----\nThe Hanning window is defined as\n\n.. math::  w(n) = 0.5 - 0.5\\cos\\left(\\frac{2\\pi{n}}{M-1}\\right)\n           \\qquad 0 \\leq n \\leq M-1\n\nThe Hanning was named for Julius von Hann, an Austrian meteorologist.\nIt is also known as the Cosine Bell. Some authors prefer that it be\ncalled a Hann window, to help avoid confusion with the very similar\nHamming window.\n\nMost references to the Hanning window come from the signal processing\nliterature, where it is used as one of many windowing functions for\nsmoothing values.  It is also known as an apodization (which means\n\"removing the foot\", i.e. smoothing discontinuities at the beginning\nand end of the sampled signal) or tapering function.\n\nReferences\n----------\n.. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power\n       spectra, Dover Publications, New York.\n.. [2] E.R. Kanasewich, \"Time Sequence Analysis in Geophysics\",\n       The University of Alberta Press, 1975, pp. 106-108.\n.. [3] Wikipedia, \"Window function\",\n       https://en.wikipedia.org/wiki/Window_function\n.. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,\n       \"Numerical Recipes\", Cambridge University Press, 1986, page 425.\n\nExamples\n--------\n>>> import numpy as np\n>>> np.hanning(12)\narray([0.        , 0.07937323, 0.29229249, 0.57115742, 0.82743037,\n       0.97974649, 0.97974649, 0.82743037, 0.57115742, 0.29229249,\n       0.07937323, 0.        ])\n\nPlot the window and its frequency response.\n\n.. plot::\n    :include-source:\n\n    import matplotlib.pyplot as plt\n    from numpy.fft import fft, fftshift\n    window = np.hanning(51)\n    plt.plot(window)\n    plt.title(\"Hann window\")\n    plt.ylabel(\"Amplitude\")\n    plt.xlabel(\"Sample\")\n    plt.show()\n\n    plt.figure()\n    A = fft(window, 2048) / 25.5\n    mag = np.abs(fftshift(A))\n    freq = np.linspace(-0.5, 0.5, len(A))\n    with np.errstate(divide='ignore', invalid='ignore'):\n        response = 20 * np.log10(mag)\n    response = np.clip(response, -100, 100)\n    plt.plot(freq, response)\n    plt.title(\"Frequency response of the Hann window\")\n    plt.ylabel(\"Magnitude [dB]\")\n    plt.xlabel(\"Normalized frequency [cycles per sample]\")\n    plt.axis('tight')\n    plt.show()"
    },
    {
      "name": "hamming",
      "docstring": "Return the Hamming window.\n\nThe Hamming window is a taper formed by using a weighted cosine.\n\nParameters\n----------\nM : int\n    Number of points in the output window. If zero or less, an\n    empty array is returned.\n\nReturns\n-------\nout : ndarray\n    The window, with the maximum value normalized to one (the value\n    one appears only if the number of samples is odd).\n\nSee Also\n--------\nbartlett, blackman, hanning, kaiser\n\nNotes\n-----\nThe Hamming window is defined as\n\n.. math::  w(n) = 0.54 - 0.46\\cos\\left(\\frac{2\\pi{n}}{M-1}\\right)\n           \\qquad 0 \\leq n \\leq M-1\n\nThe Hamming was named for R. W. Hamming, an associate of J. W. Tukey\nand is described in Blackman and Tukey. It was recommended for\nsmoothing the truncated autocovariance function in the time domain.\nMost references to the Hamming window come from the signal processing\nliterature, where it is used as one of many windowing functions for\nsmoothing values.  It is also known as an apodization (which means\n\"removing the foot\", i.e. smoothing discontinuities at the beginning\nand end of the sampled signal) or tapering function.\n\nReferences\n----------\n.. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power\n       spectra, Dover Publications, New York.\n.. [2] E.R. Kanasewich, \"Time Sequence Analysis in Geophysics\", The\n       University of Alberta Press, 1975, pp. 109-110.\n.. [3] Wikipedia, \"Window function\",\n       https://en.wikipedia.org/wiki/Window_function\n.. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,\n       \"Numerical Recipes\", Cambridge University Press, 1986, page 425.\n\nExamples\n--------\n>>> import numpy as np\n>>> np.hamming(12)\narray([ 0.08      ,  0.15302337,  0.34890909,  0.60546483,  0.84123594, # may vary\n        0.98136677,  0.98136677,  0.84123594,  0.60546483,  0.34890909,\n        0.15302337,  0.08      ])\n\nPlot the window and the frequency response.\n\n.. plot::\n    :include-source:\n\n    import matplotlib.pyplot as plt\n    from numpy.fft import fft, fftshift\n    window = np.hamming(51)\n    plt.plot(window)\n    plt.title(\"Hamming window\")\n    plt.ylabel(\"Amplitude\")\n    plt.xlabel(\"Sample\")\n    plt.show()\n\n    plt.figure()\n    A = fft(window, 2048) / 25.5\n    mag = np.abs(fftshift(A))\n    freq = np.linspace(-0.5, 0.5, len(A))\n    response = 20 * np.log10(mag)\n    response = np.clip(response, -100, 100)\n    plt.plot(freq, response)\n    plt.title(\"Frequency response of Hamming window\")\n    plt.ylabel(\"Magnitude [dB]\")\n    plt.xlabel(\"Normalized frequency [cycles per sample]\")\n    plt.axis('tight')\n    plt.show()"
    },
    {
      "name": "i0",
      "docstring": "Modified Bessel function of the first kind, order 0.\n\nUsually denoted :math:`I_0`.\n\nParameters\n----------\nx : array_like of float\n    Argument of the Bessel function.\n\nReturns\n-------\nout : ndarray, shape = x.shape, dtype = float\n    The modified Bessel function evaluated at each of the elements of `x`.\n\nSee Also\n--------\nscipy.special.i0, scipy.special.iv, scipy.special.ive\n\nNotes\n-----\nThe scipy implementation is recommended over this function: it is a\nproper ufunc written in C, and more than an order of magnitude faster.\n\nWe use the algorithm published by Clenshaw [1]_ and referenced by\nAbramowitz and Stegun [2]_, for which the function domain is\npartitioned into the two intervals [0,8] and (8,inf), and Chebyshev\npolynomial expansions are employed in each interval. Relative error on\nthe domain [0,30] using IEEE arithmetic is documented [3]_ as having a\npeak of 5.8e-16 with an rms of 1.4e-16 (n = 30000).\n\nReferences\n----------\n.. [1] C. W. Clenshaw, \"Chebyshev series for mathematical functions\", in\n       *National Physical Laboratory Mathematical Tables*, vol. 5, London:\n       Her Majesty's Stationery Office, 1962.\n.. [2] M. Abramowitz and I. A. Stegun, *Handbook of Mathematical\n       Functions*, 10th printing, New York: Dover, 1964, pp. 379.\n       https://personal.math.ubc.ca/~cbm/aands/page_379.htm\n.. [3] https://metacpan.org/pod/distribution/Math-Cephes/lib/Math/Cephes.pod#i0:-Modified-Bessel-function-of-order-zero\n\nExamples\n--------\n>>> import numpy as np\n>>> np.i0(0.)\narray(1.0)\n>>> np.i0([0, 1, 2, 3])\narray([1.        , 1.26606588, 2.2795853 , 4.88079259])"
    },
    {
      "name": "kaiser",
      "docstring": "Return the Kaiser window.\n\nThe Kaiser window is a taper formed by using a Bessel function.\n\nParameters\n----------\nM : int\n    Number of points in the output window. If zero or less, an\n    empty array is returned.\nbeta : float\n    Shape parameter for window.\n\nReturns\n-------\nout : array\n    The window, with the maximum value normalized to one (the value\n    one appears only if the number of samples is odd).\n\nSee Also\n--------\nbartlett, blackman, hamming, hanning\n\nNotes\n-----\nThe Kaiser window is defined as\n\n.. math::  w(n) = I_0\\left( \\beta \\sqrt{1-\\frac{4n^2}{(M-1)^2}}\n           \\right)/I_0(\\beta)\n\nwith\n\n.. math:: \\quad -\\frac{M-1}{2} \\leq n \\leq \\frac{M-1}{2},\n\nwhere :math:`I_0` is the modified zeroth-order Bessel function.\n\nThe Kaiser was named for Jim Kaiser, who discovered a simple\napproximation to the DPSS window based on Bessel functions.  The Kaiser\nwindow is a very good approximation to the Digital Prolate Spheroidal\nSequence, or Slepian window, which is the transform which maximizes the\nenergy in the main lobe of the window relative to total energy.\n\nThe Kaiser can approximate many other windows by varying the beta\nparameter.\n\n====  =======================\nbeta  Window shape\n====  =======================\n0     Rectangular\n5     Similar to a Hamming\n6     Similar to a Hanning\n8.6   Similar to a Blackman\n====  =======================\n\nA beta value of 14 is probably a good starting point. Note that as beta\ngets large, the window narrows, and so the number of samples needs to be\nlarge enough to sample the increasingly narrow spike, otherwise NaNs will\nget returned.\n\nMost references to the Kaiser window come from the signal processing\nliterature, where it is used as one of many windowing functions for\nsmoothing values.  It is also known as an apodization (which means\n\"removing the foot\", i.e. smoothing discontinuities at the beginning\nand end of the sampled signal) or tapering function.\n\nReferences\n----------\n.. [1] J. F. Kaiser, \"Digital Filters\" - Ch 7 in \"Systems analysis by\n       digital computer\", Editors: F.F. Kuo and J.F. Kaiser, p 218-285.\n       John Wiley and Sons, New York, (1966).\n.. [2] E.R. Kanasewich, \"Time Sequence Analysis in Geophysics\", The\n       University of Alberta Press, 1975, pp. 177-178.\n.. [3] Wikipedia, \"Window function\",\n       https://en.wikipedia.org/wiki/Window_function\n\nExamples\n--------\n>>> import numpy as np\n>>> import matplotlib.pyplot as plt\n>>> np.kaiser(12, 14)\n array([7.72686684e-06, 3.46009194e-03, 4.65200189e-02, # may vary\n        2.29737120e-01, 5.99885316e-01, 9.45674898e-01,\n        9.45674898e-01, 5.99885316e-01, 2.29737120e-01,\n        4.65200189e-02, 3.46009194e-03, 7.72686684e-06])\n\n\nPlot the window and the frequency response.\n\n.. plot::\n    :include-source:\n\n    import matplotlib.pyplot as plt\n    from numpy.fft import fft, fftshift\n    window = np.kaiser(51, 14)\n    plt.plot(window)\n    plt.title(\"Kaiser window\")\n    plt.ylabel(\"Amplitude\")\n    plt.xlabel(\"Sample\")\n    plt.show()\n\n    plt.figure()\n    A = fft(window, 2048) / 25.5\n    mag = np.abs(fftshift(A))\n    freq = np.linspace(-0.5, 0.5, len(A))\n    response = 20 * np.log10(mag)\n    response = np.clip(response, -100, 100)\n    plt.plot(freq, response)\n    plt.title(\"Frequency response of Kaiser window\")\n    plt.ylabel(\"Magnitude [dB]\")\n    plt.xlabel(\"Normalized frequency [cycles per sample]\")\n    plt.axis('tight')\n    plt.show()"
    },
    {
      "name": "sinc",
      "docstring": "Return the normalized sinc function.\n\nThe sinc function is equal to :math:`\\sin(\\pi x)/(\\pi x)` for any argument\n:math:`x\\ne 0`. ``sinc(0)`` takes the limit value 1, making ``sinc`` not\nonly everywhere continuous but also infinitely differentiable.\n\n.. note::\n\n    Note the normalization factor of ``pi`` used in the definition.\n    This is the most commonly used definition in signal processing.\n    Use ``sinc(x / np.pi)`` to obtain the unnormalized sinc function\n    :math:`\\sin(x)/x` that is more common in mathematics.\n\nParameters\n----------\nx : ndarray\n    Array (possibly multi-dimensional) of values for which to calculate\n    ``sinc(x)``.\n\nReturns\n-------\nout : ndarray\n    ``sinc(x)``, which has the same shape as the input.\n\nNotes\n-----\nThe name sinc is short for \"sine cardinal\" or \"sinus cardinalis\".\n\nThe sinc function is used in various signal processing applications,\nincluding in anti-aliasing, in the construction of a Lanczos resampling\nfilter, and in interpolation.\n\nFor bandlimited interpolation of discrete-time signals, the ideal\ninterpolation kernel is proportional to the sinc function.\n\nReferences\n----------\n.. [1] Weisstein, Eric W. \"Sinc Function.\" From MathWorld--A Wolfram Web\n       Resource. https://mathworld.wolfram.com/SincFunction.html\n.. [2] Wikipedia, \"Sinc function\",\n       https://en.wikipedia.org/wiki/Sinc_function\n\nExamples\n--------\n>>> import numpy as np\n>>> import matplotlib.pyplot as plt\n>>> x = np.linspace(-4, 4, 41)\n>>> np.sinc(x)\n array([-3.89804309e-17,  -4.92362781e-02,  -8.40918587e-02, # may vary\n        -8.90384387e-02,  -5.84680802e-02,   3.89804309e-17,\n        6.68206631e-02,   1.16434881e-01,   1.26137788e-01,\n        8.50444803e-02,  -3.89804309e-17,  -1.03943254e-01,\n        -1.89206682e-01,  -2.16236208e-01,  -1.55914881e-01,\n        3.89804309e-17,   2.33872321e-01,   5.04551152e-01,\n        7.56826729e-01,   9.35489284e-01,   1.00000000e+00,\n        9.35489284e-01,   7.56826729e-01,   5.04551152e-01,\n        2.33872321e-01,   3.89804309e-17,  -1.55914881e-01,\n       -2.16236208e-01,  -1.89206682e-01,  -1.03943254e-01,\n       -3.89804309e-17,   8.50444803e-02,   1.26137788e-01,\n        1.16434881e-01,   6.68206631e-02,   3.89804309e-17,\n        -5.84680802e-02,  -8.90384387e-02,  -8.40918587e-02,\n        -4.92362781e-02,  -3.89804309e-17])\n\n>>> plt.plot(x, np.sinc(x))\n[<matplotlib.lines.Line2D object at 0x...>]\n>>> plt.title(\"Sinc Function\")\nText(0.5, 1.0, 'Sinc Function')\n>>> plt.ylabel(\"Amplitude\")\nText(0, 0.5, 'Amplitude')\n>>> plt.xlabel(\"X\")\nText(0.5, 0, 'X')\n>>> plt.show()"
    },
    {
      "name": "median",
      "docstring": "Compute the median along the specified axis.\n\nReturns the median of the array elements.\n\nParameters\n----------\na : array_like\n    Input array or object that can be converted to an array.\naxis : {int, sequence of int, None}, optional\n    Axis or axes along which the medians are computed. The default,\n    axis=None, will compute the median along a flattened version of\n    the array. If a sequence of axes, the array is first flattened\n    along the given axes, then the median is computed along the\n    resulting flattened axis.\nout : ndarray, optional\n    Alternative output array in which to place the result. It must\n    have the same shape and buffer length as the expected output,\n    but the type (of the output) will be cast if necessary.\noverwrite_input : bool, optional\n   If True, then allow use of memory of input array `a` for\n   calculations. The input array will be modified by the call to\n   `median`. This will save memory when you do not need to preserve\n   the contents of the input array. Treat the input as undefined,\n   but it will probably be fully or partially sorted. Default is\n   False. If `overwrite_input` is ``True`` and `a` is not already an\n   `ndarray`, an error will be raised.\nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left\n    in the result as dimensions with size one. With this option,\n    the result will broadcast correctly against the original `arr`.\n\nReturns\n-------\nmedian : ndarray\n    A new array holding the result. If the input contains integers\n    or floats smaller than ``float64``, then the output data-type is\n    ``np.float64``.  Otherwise, the data-type of the output is the\n    same as that of the input. If `out` is specified, that array is\n    returned instead.\n\nSee Also\n--------\nmean, percentile\n\nNotes\n-----\nGiven a vector ``V`` of length ``N``, the median of ``V`` is the\nmiddle value of a sorted copy of ``V``, ``V_sorted`` - i\ne., ``V_sorted[(N-1)/2]``, when ``N`` is odd, and the average of the\ntwo middle values of ``V_sorted`` when ``N`` is even.\n\nExamples\n--------\n>>> import numpy as np\n>>> a = np.array([[10, 7, 4], [3, 2, 1]])\n>>> a\narray([[10,  7,  4],\n       [ 3,  2,  1]])\n>>> np.median(a)\nnp.float64(3.5)\n>>> np.median(a, axis=0)\narray([6.5, 4.5, 2.5])\n>>> np.median(a, axis=1)\narray([7.,  2.])\n>>> np.median(a, axis=(0, 1))\nnp.float64(3.5)\n>>> m = np.median(a, axis=0)\n>>> out = np.zeros_like(m)\n>>> np.median(a, axis=0, out=m)\narray([6.5,  4.5,  2.5])\n>>> m\narray([6.5,  4.5,  2.5])\n>>> b = a.copy()\n>>> np.median(b, axis=1, overwrite_input=True)\narray([7.,  2.])\n>>> assert not np.all(a==b)\n>>> b = a.copy()\n>>> np.median(b, axis=None, overwrite_input=True)\nnp.float64(3.5)\n>>> assert not np.all(a==b)"
    },
    {
      "name": "percentile",
      "docstring": "Compute the q-th percentile of the data along the specified axis.\n\nReturns the q-th percentile(s) of the array elements.\n\nParameters\n----------\na : array_like of real numbers\n    Input array or object that can be converted to an array.\nq : array_like of float\n    Percentage or sequence of percentages for the percentiles to compute.\n    Values must be between 0 and 100 inclusive.\naxis : {int, tuple of int, None}, optional\n    Axis or axes along which the percentiles are computed. The\n    default is to compute the percentile(s) along a flattened\n    version of the array.\nout : ndarray, optional\n    Alternative output array in which to place the result. It must\n    have the same shape and buffer length as the expected output,\n    but the type (of the output) will be cast if necessary.\noverwrite_input : bool, optional\n    If True, then allow the input array `a` to be modified by intermediate\n    calculations, to save memory. In this case, the contents of the input\n    `a` after this function completes is undefined.\nmethod : str, optional\n    This parameter specifies the method to use for estimating the\n    percentile.  There are many different methods, some unique to NumPy.\n    See the notes for explanation.  The options sorted by their R type\n    as summarized in the H&F paper [1]_ are:\n\n    1. 'inverted_cdf'\n    2. 'averaged_inverted_cdf'\n    3. 'closest_observation'\n    4. 'interpolated_inverted_cdf'\n    5. 'hazen'\n    6. 'weibull'\n    7. 'linear'  (default)\n    8. 'median_unbiased'\n    9. 'normal_unbiased'\n\n    The first three methods are discontinuous.  NumPy further defines the\n    following discontinuous variations of the default 'linear' (7.) option:\n\n    * 'lower'\n    * 'higher',\n    * 'midpoint'\n    * 'nearest'\n\n    .. versionchanged:: 1.22.0\n        This argument was previously called \"interpolation\" and only\n        offered the \"linear\" default and last four options.\n\nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in\n    the result as dimensions with size one. With this option, the\n    result will broadcast correctly against the original array `a`.\n\n weights : array_like, optional\n    An array of weights associated with the values in `a`. Each value in\n    `a` contributes to the percentile according to its associated weight.\n    The weights array can either be 1-D (in which case its length must be\n    the size of `a` along the given axis) or of the same shape as `a`.\n    If `weights=None`, then all data in `a` are assumed to have a\n    weight equal to one.\n    Only `method=\"inverted_cdf\"` supports weights.\n    See the notes for more details.\n\n    .. versionadded:: 2.0.0\n\ninterpolation : str, optional\n    Deprecated name for the method keyword argument.\n\n    .. deprecated:: 1.22.0\n\nReturns\n-------\npercentile : scalar or ndarray\n    If `q` is a single percentile and `axis=None`, then the result\n    is a scalar. If multiple percentiles are given, first axis of\n    the result corresponds to the percentiles. The other axes are\n    the axes that remain after the reduction of `a`. If the input\n    contains integers or floats smaller than ``float64``, the output\n    data-type is ``float64``. Otherwise, the output data-type is the\n    same as that of the input. If `out` is specified, that array is\n    returned instead.\n\nSee Also\n--------\nmean\nmedian : equivalent to ``percentile(..., 50)``\nnanpercentile\nquantile : equivalent to percentile, except q in the range [0, 1].\n\nNotes\n-----\nThe behavior of `numpy.percentile` with percentage `q` is\nthat of `numpy.quantile` with argument ``q/100``.\nFor more information, please see `numpy.quantile`.\n\nExamples\n--------\n>>> import numpy as np\n>>> a = np.array([[10, 7, 4], [3, 2, 1]])\n>>> a\narray([[10,  7,  4],\n       [ 3,  2,  1]])\n>>> np.percentile(a, 50)\n3.5\n>>> np.percentile(a, 50, axis=0)\narray([6.5, 4.5, 2.5])\n>>> np.percentile(a, 50, axis=1)\narray([7.,  2.])\n>>> np.percentile(a, 50, axis=1, keepdims=True)\narray([[7.],\n       [2.]])\n\n>>> m = np.percentile(a, 50, axis=0)\n>>> out = np.zeros_like(m)\n>>> np.percentile(a, 50, axis=0, out=out)\narray([6.5, 4.5, 2.5])\n>>> m\narray([6.5, 4.5, 2.5])\n\n>>> b = a.copy()\n>>> np.percentile(b, 50, axis=1, overwrite_input=True)\narray([7.,  2.])\n>>> assert not np.all(a == b)\n\nThe different methods can be visualized graphically:\n\n.. plot::\n\n    import matplotlib.pyplot as plt\n\n    a = np.arange(4)\n    p = np.linspace(0, 100, 6001)\n    ax = plt.gca()\n    lines = [\n        ('linear', '-', 'C0'),\n        ('inverted_cdf', ':', 'C1'),\n        # Almost the same as `inverted_cdf`:\n        ('averaged_inverted_cdf', '-.', 'C1'),\n        ('closest_observation', ':', 'C2'),\n        ('interpolated_inverted_cdf', '--', 'C1'),\n        ('hazen', '--', 'C3'),\n        ('weibull', '-.', 'C4'),\n        ('median_unbiased', '--', 'C5'),\n        ('normal_unbiased', '-.', 'C6'),\n        ]\n    for method, style, color in lines:\n        ax.plot(\n            p, np.percentile(a, p, method=method),\n            label=method, linestyle=style, color=color)\n    ax.set(\n        title='Percentiles for different methods and data: ' + str(a),\n        xlabel='Percentile',\n        ylabel='Estimated percentile value',\n        yticks=a)\n    ax.legend(bbox_to_anchor=(1.03, 1))\n    plt.tight_layout()\n    plt.show()\n\nReferences\n----------\n.. [1] R. J. Hyndman and Y. Fan,\n   \"Sample quantiles in statistical packages,\"\n   The American Statistician, 50(4), pp. 361-365, 1996"
    },
    {
      "name": "quantile",
      "docstring": "Compute the q-th quantile of the data along the specified axis.\n\nParameters\n----------\na : array_like of real numbers\n    Input array or object that can be converted to an array.\nq : array_like of float\n    Probability or sequence of probabilities of the quantiles to compute.\n    Values must be between 0 and 1 inclusive.\naxis : {int, tuple of int, None}, optional\n    Axis or axes along which the quantiles are computed. The default is\n    to compute the quantile(s) along a flattened version of the array.\nout : ndarray, optional\n    Alternative output array in which to place the result. It must have\n    the same shape and buffer length as the expected output, but the\n    type (of the output) will be cast if necessary.\noverwrite_input : bool, optional\n    If True, then allow the input array `a` to be modified by\n    intermediate calculations, to save memory. In this case, the\n    contents of the input `a` after this function completes is\n    undefined.\nmethod : str, optional\n    This parameter specifies the method to use for estimating the\n    quantile.  There are many different methods, some unique to NumPy.\n    The recommended options, numbered as they appear in [1]_, are:\n\n    1. 'inverted_cdf'\n    2. 'averaged_inverted_cdf'\n    3. 'closest_observation'\n    4. 'interpolated_inverted_cdf'\n    5. 'hazen'\n    6. 'weibull'\n    7. 'linear'  (default)\n    8. 'median_unbiased'\n    9. 'normal_unbiased'\n\n    The first three methods are discontinuous. For backward compatibility\n    with previous versions of NumPy, the following discontinuous variations\n    of the default 'linear' (7.) option are available:\n\n    * 'lower'\n    * 'higher',\n    * 'midpoint'\n    * 'nearest'\n\n    See Notes for details.\n\n    .. versionchanged:: 1.22.0\n        This argument was previously called \"interpolation\" and only\n        offered the \"linear\" default and last four options.\n\nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in\n    the result as dimensions with size one. With this option, the\n    result will broadcast correctly against the original array `a`.\n\nweights : array_like, optional\n    An array of weights associated with the values in `a`. Each value in\n    `a` contributes to the quantile according to its associated weight.\n    The weights array can either be 1-D (in which case its length must be\n    the size of `a` along the given axis) or of the same shape as `a`.\n    If `weights=None`, then all data in `a` are assumed to have a\n    weight equal to one.\n    Only `method=\"inverted_cdf\"` supports weights.\n    See the notes for more details.\n\n    .. versionadded:: 2.0.0\n\ninterpolation : str, optional\n    Deprecated name for the method keyword argument.\n\n    .. deprecated:: 1.22.0\n\nReturns\n-------\nquantile : scalar or ndarray\n    If `q` is a single probability and `axis=None`, then the result\n    is a scalar. If multiple probability levels are given, first axis\n    of the result corresponds to the quantiles. The other axes are\n    the axes that remain after the reduction of `a`. If the input\n    contains integers or floats smaller than ``float64``, the output\n    data-type is ``float64``. Otherwise, the output data-type is the\n    same as that of the input. If `out` is specified, that array is\n    returned instead.\n\nSee Also\n--------\nmean\npercentile : equivalent to quantile, but with q in the range [0, 100].\nmedian : equivalent to ``quantile(..., 0.5)``\nnanquantile\n\nNotes\n-----\nGiven a sample `a` from an underlying distribution, `quantile` provides a\nnonparametric estimate of the inverse cumulative distribution function.\n\nBy default, this is done by interpolating between adjacent elements in\n``y``, a sorted copy of `a`::\n\n    (1-g)*y[j] + g*y[j+1]\n\nwhere the index ``j`` and coefficient ``g`` are the integral and\nfractional components of ``q * (n-1)``, and ``n`` is the number of\nelements in the sample.\n\nThis is a special case of Equation 1 of H&F [1]_. More generally,\n\n- ``j = (q*n + m - 1) // 1``, and\n- ``g = (q*n + m - 1) % 1``,\n\nwhere ``m`` may be defined according to several different conventions.\nThe preferred convention may be selected using the ``method`` parameter:\n\n=============================== =============== ===============\n``method``                      number in H&F   ``m``\n=============================== =============== ===============\n``interpolated_inverted_cdf``   4               ``0``\n``hazen``                       5               ``1/2``\n``weibull``                     6               ``q``\n``linear`` (default)            7               ``1 - q``\n``median_unbiased``             8               ``q/3 + 1/3``\n``normal_unbiased``             9               ``q/4 + 3/8``\n=============================== =============== ===============\n\nNote that indices ``j`` and ``j + 1`` are clipped to the range ``0`` to\n``n - 1`` when the results of the formula would be outside the allowed\nrange of non-negative indices. The ``- 1`` in the formulas for ``j`` and\n``g`` accounts for Python's 0-based indexing.\n\nThe table above includes only the estimators from H&F that are continuous\nfunctions of probability `q` (estimators 4-9). NumPy also provides the\nthree discontinuous estimators from H&F (estimators 1-3), where ``j`` is\ndefined as above, ``m`` is defined as follows, and ``g`` is a function\nof the real-valued ``index = q*n + m - 1`` and ``j``.\n\n1. ``inverted_cdf``: ``m = 0`` and ``g = int(index - j > 0)``\n2. ``averaged_inverted_cdf``: ``m = 0`` and\n   ``g = (1 + int(index - j > 0)) / 2``\n3. ``closest_observation``: ``m = -1/2`` and\n   ``g = 1 - int((index == j) & (j%2 == 1))``\n\nFor backward compatibility with previous versions of NumPy, `quantile`\nprovides four additional discontinuous estimators. Like\n``method='linear'``, all have ``m = 1 - q`` so that ``j = q*(n-1) // 1``,\nbut ``g`` is defined as follows.\n\n- ``lower``: ``g = 0``\n- ``midpoint``: ``g = 0.5``\n- ``higher``: ``g = 1``\n- ``nearest``: ``g = (q*(n-1) % 1) > 0.5``\n\n**Weighted quantiles:**\nMore formally, the quantile at probability level :math:`q` of a cumulative\ndistribution function :math:`F(y)=P(Y \\leq y)` with probability measure\n:math:`P` is defined as any number :math:`x` that fulfills the\n*coverage conditions*\n\n.. math:: P(Y < x) \\leq q \\quad\\text{and}\\quad P(Y \\leq x) \\geq q\n\nwith random variable :math:`Y\\sim P`.\nSample quantiles, the result of `quantile`, provide nonparametric\nestimation of the underlying population counterparts, represented by the\nunknown :math:`F`, given a data vector `a` of length ``n``.\n\nSome of the estimators above arise when one considers :math:`F` as the\nempirical distribution function of the data, i.e.\n:math:`F(y) = \\frac{1}{n} \\sum_i 1_{a_i \\leq y}`.\nThen, different methods correspond to different choices of :math:`x` that\nfulfill the above coverage conditions. Methods that follow this approach\nare ``inverted_cdf`` and ``averaged_inverted_cdf``.\n\nFor weighted quantiles, the coverage conditions still hold. The\nempirical cumulative distribution is simply replaced by its weighted\nversion, i.e.\n:math:`P(Y \\leq t) = \\frac{1}{\\sum_i w_i} \\sum_i w_i 1_{x_i \\leq t}`.\nOnly ``method=\"inverted_cdf\"`` supports weights.\n\nExamples\n--------\n>>> import numpy as np\n>>> a = np.array([[10, 7, 4], [3, 2, 1]])\n>>> a\narray([[10,  7,  4],\n       [ 3,  2,  1]])\n>>> np.quantile(a, 0.5)\n3.5\n>>> np.quantile(a, 0.5, axis=0)\narray([6.5, 4.5, 2.5])\n>>> np.quantile(a, 0.5, axis=1)\narray([7.,  2.])\n>>> np.quantile(a, 0.5, axis=1, keepdims=True)\narray([[7.],\n       [2.]])\n>>> m = np.quantile(a, 0.5, axis=0)\n>>> out = np.zeros_like(m)\n>>> np.quantile(a, 0.5, axis=0, out=out)\narray([6.5, 4.5, 2.5])\n>>> m\narray([6.5, 4.5, 2.5])\n>>> b = a.copy()\n>>> np.quantile(b, 0.5, axis=1, overwrite_input=True)\narray([7.,  2.])\n>>> assert not np.all(a == b)\n\nSee also `numpy.percentile` for a visualization of most methods.\n\nReferences\n----------\n.. [1] R. J. Hyndman and Y. Fan,\n   \"Sample quantiles in statistical packages,\"\n   The American Statistician, 50(4), pp. 361-365, 1996"
    },
    {
      "name": "trapezoid",
      "docstring": "Integrate along the given axis using the composite trapezoidal rule.\n\nIf `x` is provided, the integration happens in sequence along its\nelements - they are not sorted.\n\nIntegrate `y` (`x`) along each 1d slice on the given axis, compute\n:math:`\\int y(x) dx`.\nWhen `x` is specified, this integrates along the parametric curve,\ncomputing :math:`\\int_t y(t) dt =\n\\int_t y(t) \\left.\\frac{dx}{dt}\\right|_{x=x(t)} dt`.\n\n.. versionadded:: 2.0.0\n\nParameters\n----------\ny : array_like\n    Input array to integrate.\nx : array_like, optional\n    The sample points corresponding to the `y` values. If `x` is None,\n    the sample points are assumed to be evenly spaced `dx` apart. The\n    default is None.\ndx : scalar, optional\n    The spacing between sample points when `x` is None. The default is 1.\naxis : int, optional\n    The axis along which to integrate.\n\nReturns\n-------\ntrapezoid : float or ndarray\n    Definite integral of `y` = n-dimensional array as approximated along\n    a single axis by the trapezoidal rule. If `y` is a 1-dimensional array,\n    then the result is a float. If `n` is greater than 1, then the result\n    is an `n`-1 dimensional array.\n\nSee Also\n--------\nsum, cumsum\n\nNotes\n-----\nImage [2]_ illustrates trapezoidal rule -- y-axis locations of points\nwill be taken from `y` array, by default x-axis distances between\npoints will be 1.0, alternatively they can be provided with `x` array\nor with `dx` scalar.  Return value will be equal to combined area under\nthe red lines.\n\n\nReferences\n----------\n.. [1] Wikipedia page: https://en.wikipedia.org/wiki/Trapezoidal_rule\n\n.. [2] Illustration image:\n       https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png\n\nExamples\n--------\n>>> import numpy as np\n\nUse the trapezoidal rule on evenly spaced points:\n\n>>> np.trapezoid([1, 2, 3])\n4.0\n\nThe spacing between sample points can be selected by either the\n``x`` or ``dx`` arguments:\n\n>>> np.trapezoid([1, 2, 3], x=[4, 6, 8])\n8.0\n>>> np.trapezoid([1, 2, 3], dx=2)\n8.0\n\nUsing a decreasing ``x`` corresponds to integrating in reverse:\n\n>>> np.trapezoid([1, 2, 3], x=[8, 6, 4])\n-8.0\n\nMore generally ``x`` is used to integrate along a parametric curve. We can\nestimate the integral :math:`\\int_0^1 x^2 = 1/3` using:\n\n>>> x = np.linspace(0, 1, num=50)\n>>> y = x**2\n>>> np.trapezoid(y, x)\n0.33340274885464394\n\nOr estimate the area of a circle, noting we repeat the sample which closes\nthe curve:\n\n>>> theta = np.linspace(0, 2 * np.pi, num=1000, endpoint=True)\n>>> np.trapezoid(np.cos(theta), x=np.sin(theta))\n3.141571941375841\n\n``np.trapezoid`` can be applied along a specified axis to do multiple\ncomputations in one call:\n\n>>> a = np.arange(6).reshape(2, 3)\n>>> a\narray([[0, 1, 2],\n       [3, 4, 5]])\n>>> np.trapezoid(a, axis=0)\narray([1.5, 2.5, 3.5])\n>>> np.trapezoid(a, axis=1)\narray([2.,  8.])"
    },
    {
      "name": "trapz",
      "docstring": "`trapz` is deprecated in NumPy 2.0.\n\nPlease use `trapezoid` instead, or one of the numerical integration\nfunctions in `scipy.integrate`."
    },
    {
      "name": "meshgrid",
      "docstring": "Return a tuple of coordinate matrices from coordinate vectors.\n\nMake N-D coordinate arrays for vectorized evaluations of\nN-D scalar/vector fields over N-D grids, given\none-dimensional coordinate arrays x1, x2,..., xn.\n\nParameters\n----------\nx1, x2,..., xn : array_like\n    1-D arrays representing the coordinates of a grid.\nindexing : {'xy', 'ij'}, optional\n    Cartesian ('xy', default) or matrix ('ij') indexing of output.\n    See Notes for more details.\nsparse : bool, optional\n    If True the shape of the returned coordinate array for dimension *i*\n    is reduced from ``(N1, ..., Ni, ... Nn)`` to\n    ``(1, ..., 1, Ni, 1, ..., 1)``.  These sparse coordinate grids are\n    intended to be use with :ref:`basics.broadcasting`.  When all\n    coordinates are used in an expression, broadcasting still leads to a\n    fully-dimensonal result array.\n\n    Default is False.\n\ncopy : bool, optional\n    If False, a view into the original arrays are returned in order to\n    conserve memory.  Default is True.  Please note that\n    ``sparse=False, copy=False`` will likely return non-contiguous\n    arrays.  Furthermore, more than one element of a broadcast array\n    may refer to a single memory location.  If you need to write to the\n    arrays, make copies first.\n\nReturns\n-------\nX1, X2,..., XN : tuple of ndarrays\n    For vectors `x1`, `x2`,..., `xn` with lengths ``Ni=len(xi)``,\n    returns ``(N1, N2, N3,..., Nn)`` shaped arrays if indexing='ij'\n    or ``(N2, N1, N3,..., Nn)`` shaped arrays if indexing='xy'\n    with the elements of `xi` repeated to fill the matrix along\n    the first dimension for `x1`, the second for `x2` and so on.\n\nNotes\n-----\nThis function supports both indexing conventions through the indexing\nkeyword argument.  Giving the string 'ij' returns a meshgrid with\nmatrix indexing, while 'xy' returns a meshgrid with Cartesian indexing.\nIn the 2-D case with inputs of length M and N, the outputs are of shape\n(N, M) for 'xy' indexing and (M, N) for 'ij' indexing.  In the 3-D case\nwith inputs of length M, N and P, outputs are of shape (N, M, P) for\n'xy' indexing and (M, N, P) for 'ij' indexing.  The difference is\nillustrated by the following code snippet::\n\n    xv, yv = np.meshgrid(x, y, indexing='ij')\n    for i in range(nx):\n        for j in range(ny):\n            # treat xv[i,j], yv[i,j]\n\n    xv, yv = np.meshgrid(x, y, indexing='xy')\n    for i in range(nx):\n        for j in range(ny):\n            # treat xv[j,i], yv[j,i]\n\nIn the 1-D and 0-D case, the indexing and sparse keywords have no effect.\n\nSee Also\n--------\nmgrid : Construct a multi-dimensional \"meshgrid\" using indexing notation.\nogrid : Construct an open multi-dimensional \"meshgrid\" using indexing\n        notation.\n:ref:`how-to-index`\n\nExamples\n--------\n>>> import numpy as np\n>>> nx, ny = (3, 2)\n>>> x = np.linspace(0, 1, nx)\n>>> y = np.linspace(0, 1, ny)\n>>> xv, yv = np.meshgrid(x, y)\n>>> xv\narray([[0. , 0.5, 1. ],\n       [0. , 0.5, 1. ]])\n>>> yv\narray([[0.,  0.,  0.],\n       [1.,  1.,  1.]])\n\nThe result of `meshgrid` is a coordinate grid:\n\n>>> import matplotlib.pyplot as plt\n>>> plt.plot(xv, yv, marker='o', color='k', linestyle='none')\n>>> plt.show()\n\nYou can create sparse output arrays to save memory and computation time.\n\n>>> xv, yv = np.meshgrid(x, y, sparse=True)\n>>> xv\narray([[0. ,  0.5,  1. ]])\n>>> yv\narray([[0.],\n       [1.]])\n\n`meshgrid` is very useful to evaluate functions on a grid. If the\nfunction depends on all coordinates, both dense and sparse outputs can be\nused.\n\n>>> x = np.linspace(-5, 5, 101)\n>>> y = np.linspace(-5, 5, 101)\n>>> # full coordinate arrays\n>>> xx, yy = np.meshgrid(x, y)\n>>> zz = np.sqrt(xx**2 + yy**2)\n>>> xx.shape, yy.shape, zz.shape\n((101, 101), (101, 101), (101, 101))\n>>> # sparse coordinate arrays\n>>> xs, ys = np.meshgrid(x, y, sparse=True)\n>>> zs = np.sqrt(xs**2 + ys**2)\n>>> xs.shape, ys.shape, zs.shape\n((1, 101), (101, 1), (101, 101))\n>>> np.array_equal(zz, zs)\nTrue\n\n>>> h = plt.contourf(x, y, zs)\n>>> plt.axis('scaled')\n>>> plt.colorbar()\n>>> plt.show()"
    },
    {
      "name": "delete",
      "docstring": "Return a new array with sub-arrays along an axis deleted. For a one\ndimensional array, this returns those entries not returned by\n`arr[obj]`.\n\nParameters\n----------\narr : array_like\n    Input array.\nobj : slice, int, array-like of ints or bools\n    Indicate indices of sub-arrays to remove along the specified axis.\n\n    .. versionchanged:: 1.19.0\n        Boolean indices are now treated as a mask of elements to remove,\n        rather than being cast to the integers 0 and 1.\n\naxis : int, optional\n    The axis along which to delete the subarray defined by `obj`.\n    If `axis` is None, `obj` is applied to the flattened array.\n\nReturns\n-------\nout : ndarray\n    A copy of `arr` with the elements specified by `obj` removed. Note\n    that `delete` does not occur in-place. If `axis` is None, `out` is\n    a flattened array.\n\nSee Also\n--------\ninsert : Insert elements into an array.\nappend : Append elements at the end of an array.\n\nNotes\n-----\nOften it is preferable to use a boolean mask. For example:\n\n>>> arr = np.arange(12) + 1\n>>> mask = np.ones(len(arr), dtype=bool)\n>>> mask[[0,2,4]] = False\n>>> result = arr[mask,...]\n\nIs equivalent to ``np.delete(arr, [0,2,4], axis=0)``, but allows further\nuse of `mask`.\n\nExamples\n--------\n>>> import numpy as np\n>>> arr = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])\n>>> arr\narray([[ 1,  2,  3,  4],\n       [ 5,  6,  7,  8],\n       [ 9, 10, 11, 12]])\n>>> np.delete(arr, 1, 0)\narray([[ 1,  2,  3,  4],\n       [ 9, 10, 11, 12]])\n\n>>> np.delete(arr, np.s_[::2], 1)\narray([[ 2,  4],\n       [ 6,  8],\n       [10, 12]])\n>>> np.delete(arr, [1,3,5], None)\narray([ 1,  3,  5,  7,  8,  9, 10, 11, 12])"
    },
    {
      "name": "insert",
      "docstring": "Insert values along the given axis before the given indices.\n\nParameters\n----------\narr : array_like\n    Input array.\nobj : slice, int, array-like of ints or bools\n    Object that defines the index or indices before which `values` is\n    inserted.\n\n    .. versionchanged:: 2.1.2\n        Boolean indices are now treated as a mask of elements to insert,\n        rather than being cast to the integers 0 and 1.\n\n    Support for multiple insertions when `obj` is a single scalar or a\n    sequence with one element (similar to calling insert multiple\n    times).\nvalues : array_like\n    Values to insert into `arr`. If the type of `values` is different\n    from that of `arr`, `values` is converted to the type of `arr`.\n    `values` should be shaped so that ``arr[...,obj,...] = values``\n    is legal.\naxis : int, optional\n    Axis along which to insert `values`.  If `axis` is None then `arr`\n    is flattened first.\n\nReturns\n-------\nout : ndarray\n    A copy of `arr` with `values` inserted.  Note that `insert`\n    does not occur in-place: a new array is returned. If\n    `axis` is None, `out` is a flattened array.\n\nSee Also\n--------\nappend : Append elements at the end of an array.\nconcatenate : Join a sequence of arrays along an existing axis.\ndelete : Delete elements from an array.\n\nNotes\n-----\nNote that for higher dimensional inserts ``obj=0`` behaves very different\nfrom ``obj=[0]`` just like ``arr[:,0,:] = values`` is different from\n``arr[:,[0],:] = values``. This is because of the difference between basic\nand advanced :ref:`indexing <basics.indexing>`.\n\nExamples\n--------\n>>> import numpy as np\n>>> a = np.arange(6).reshape(3, 2)\n>>> a\narray([[0, 1],\n       [2, 3],\n       [4, 5]])\n>>> np.insert(a, 1, 6)\narray([0, 6, 1, 2, 3, 4, 5])\n>>> np.insert(a, 1, 6, axis=1)\narray([[0, 6, 1],\n       [2, 6, 3],\n       [4, 6, 5]])\n\nDifference between sequence and scalars,\nshowing how ``obj=[1]`` behaves different from ``obj=1``:\n\n>>> np.insert(a, [1], [[7],[8],[9]], axis=1)\narray([[0, 7, 1],\n       [2, 8, 3],\n       [4, 9, 5]])\n>>> np.insert(a, 1, [[7],[8],[9]], axis=1)\narray([[0, 7, 8, 9, 1],\n       [2, 7, 8, 9, 3],\n       [4, 7, 8, 9, 5]])\n>>> np.array_equal(np.insert(a, 1, [7, 8, 9], axis=1),\n...                np.insert(a, [1], [[7],[8],[9]], axis=1))\nTrue\n\n>>> b = a.flatten()\n>>> b\narray([0, 1, 2, 3, 4, 5])\n>>> np.insert(b, [2, 2], [6, 7])\narray([0, 1, 6, 7, 2, 3, 4, 5])\n\n>>> np.insert(b, slice(2, 4), [7, 8])\narray([0, 1, 7, 2, 8, 3, 4, 5])\n\n>>> np.insert(b, [2, 2], [7.13, False]) # type casting\narray([0, 1, 7, 0, 2, 3, 4, 5])\n\n>>> x = np.arange(8).reshape(2, 4)\n>>> idx = (1, 3)\n>>> np.insert(x, idx, 999, axis=1)\narray([[  0, 999,   1,   2, 999,   3],\n       [  4, 999,   5,   6, 999,   7]])"
    },
    {
      "name": "append",
      "docstring": "Append values to the end of an array.\n\nParameters\n----------\narr : array_like\n    Values are appended to a copy of this array.\nvalues : array_like\n    These values are appended to a copy of `arr`.  It must be of the\n    correct shape (the same shape as `arr`, excluding `axis`).  If\n    `axis` is not specified, `values` can be any shape and will be\n    flattened before use.\naxis : int, optional\n    The axis along which `values` are appended.  If `axis` is not\n    given, both `arr` and `values` are flattened before use.\n\nReturns\n-------\nappend : ndarray\n    A copy of `arr` with `values` appended to `axis`.  Note that\n    `append` does not occur in-place: a new array is allocated and\n    filled.  If `axis` is None, `out` is a flattened array.\n\nSee Also\n--------\ninsert : Insert elements into an array.\ndelete : Delete elements from an array.\n\nExamples\n--------\n>>> import numpy as np\n>>> np.append([1, 2, 3], [[4, 5, 6], [7, 8, 9]])\narray([1, 2, 3, ..., 7, 8, 9])\n\nWhen `axis` is specified, `values` must have the correct shape.\n\n>>> np.append([[1, 2, 3], [4, 5, 6]], [[7, 8, 9]], axis=0)\narray([[1, 2, 3],\n       [4, 5, 6],\n       [7, 8, 9]])\n\n>>> np.append([[1, 2, 3], [4, 5, 6]], [7, 8, 9], axis=0)\nTraceback (most recent call last):\n    ...\nValueError: all the input arrays must have same number of dimensions, but\nthe array at index 0 has 2 dimension(s) and the array at index 1 has 1\ndimension(s)\n\n>>> a = np.array([1, 2], dtype=int)\n>>> c = np.append(a, [])\n>>> c\narray([1., 2.])\n>>> c.dtype\nfloat64\n\nDefault dtype for empty ndarrays is `float64` thus making the output of dtype\n`float64` when appended with dtype `int64`"
    },
    {
      "name": "digitize",
      "docstring": "Return the indices of the bins to which each value in input array belongs.\n\n=========  =============  ============================\n`right`    order of bins  returned index `i` satisfies\n=========  =============  ============================\n``False``  increasing     ``bins[i-1] <= x < bins[i]``\n``True``   increasing     ``bins[i-1] < x <= bins[i]``\n``False``  decreasing     ``bins[i-1] > x >= bins[i]``\n``True``   decreasing     ``bins[i-1] >= x > bins[i]``\n=========  =============  ============================\n\nIf values in `x` are beyond the bounds of `bins`, 0 or ``len(bins)`` is\nreturned as appropriate.\n\nParameters\n----------\nx : array_like\n    Input array to be binned. Prior to NumPy 1.10.0, this array had to\n    be 1-dimensional, but can now have any shape.\nbins : array_like\n    Array of bins. It has to be 1-dimensional and monotonic.\nright : bool, optional\n    Indicating whether the intervals include the right or the left bin\n    edge. Default behavior is (right==False) indicating that the interval\n    does not include the right edge. The left bin end is open in this\n    case, i.e., bins[i-1] <= x < bins[i] is the default behavior for\n    monotonically increasing bins.\n\nReturns\n-------\nindices : ndarray of ints\n    Output array of indices, of same shape as `x`.\n\nRaises\n------\nValueError\n    If `bins` is not monotonic.\nTypeError\n    If the type of the input is complex.\n\nSee Also\n--------\nbincount, histogram, unique, searchsorted\n\nNotes\n-----\nIf values in `x` are such that they fall outside the bin range,\nattempting to index `bins` with the indices that `digitize` returns\nwill result in an IndexError.\n\n.. versionadded:: 1.10.0\n\n`numpy.digitize` is  implemented in terms of `numpy.searchsorted`.\nThis means that a binary search is used to bin the values, which scales\nmuch better for larger number of bins than the previous linear search.\nIt also removes the requirement for the input array to be 1-dimensional.\n\nFor monotonically *increasing* `bins`, the following are equivalent::\n\n    np.digitize(x, bins, right=True)\n    np.searchsorted(bins, x, side='left')\n\nNote that as the order of the arguments are reversed, the side must be too.\nThe `searchsorted` call is marginally faster, as it does not do any\nmonotonicity checks. Perhaps more importantly, it supports all dtypes.\n\nExamples\n--------\n>>> import numpy as np\n>>> x = np.array([0.2, 6.4, 3.0, 1.6])\n>>> bins = np.array([0.0, 1.0, 2.5, 4.0, 10.0])\n>>> inds = np.digitize(x, bins)\n>>> inds\narray([1, 4, 3, 2])\n>>> for n in range(x.size):\n...   print(bins[inds[n]-1], \"<=\", x[n], \"<\", bins[inds[n]])\n...\n0.0 <= 0.2 < 1.0\n4.0 <= 6.4 < 10.0\n2.5 <= 3.0 < 4.0\n1.0 <= 1.6 < 2.5\n\n>>> x = np.array([1.2, 10.0, 12.4, 15.5, 20.])\n>>> bins = np.array([0, 5, 10, 15, 20])\n>>> np.digitize(x,bins,right=True)\narray([1, 2, 3, 4, 4])\n>>> np.digitize(x,bins,right=False)\narray([1, 3, 3, 4, 5])"
    },
    {
      "name": "find_cdf_1d",
      "docstring": null
    },
    {
      "name": "func",
      "docstring": null
    }
  ],
  "innovations": [
    {
      "type": "potential_innovation",
      "marker": "optimization",
      "context": "            single_value = True\n\n    if single_value:\n        # optimization for a single value\n        if (obj < -N or obj >= N):\n            raise IndexError(\n                \"index %i is out of bounds for axis %i with \""
    }
  ]
}