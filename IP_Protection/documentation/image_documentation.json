{
  "file_path": "c:\\Users\\sgbil\\OneDrive\\Desktop\\Negative_Space_Imaging_Project\\.venv\\Lib\\site-packages\\PIL\\Image.py",
  "classes": [
    {
      "name": "DecompressionBombWarning",
      "docstring": null,
      "methods": []
    },
    {
      "name": "DecompressionBombError",
      "docstring": null,
      "methods": []
    },
    {
      "name": "Transpose",
      "docstring": null,
      "methods": []
    },
    {
      "name": "Transform",
      "docstring": null,
      "methods": []
    },
    {
      "name": "Resampling",
      "docstring": null,
      "methods": []
    },
    {
      "name": "Dither",
      "docstring": null,
      "methods": []
    },
    {
      "name": "Palette",
      "docstring": null,
      "methods": []
    },
    {
      "name": "Quantize",
      "docstring": null,
      "methods": []
    },
    {
      "name": "ImagePointTransform",
      "docstring": "Used with :py:meth:`~PIL.Image.Image.point` for single band images with more than\n8 bits, this represents an affine transformation, where the value is multiplied by\n``scale`` and ``offset`` is added.",
      "methods": [
        {
          "name": "__init__",
          "docstring": null
        }
      ]
    },
    {
      "name": "SupportsGetData",
      "docstring": null,
      "methods": [
        {
          "name": "getdata",
          "docstring": null
        }
      ]
    },
    {
      "name": "Image",
      "docstring": "This class represents an image object.  To create\n:py:class:`~PIL.Image.Image` objects, use the appropriate factory\nfunctions.  There's hardly ever any reason to call the Image constructor\ndirectly.\n\n* :py:func:`~PIL.Image.open`\n* :py:func:`~PIL.Image.new`\n* :py:func:`~PIL.Image.frombytes`",
      "methods": [
        {
          "name": "__init__",
          "docstring": null
        },
        {
          "name": "im",
          "docstring": null
        },
        {
          "name": "im",
          "docstring": null
        },
        {
          "name": "width",
          "docstring": null
        },
        {
          "name": "height",
          "docstring": null
        },
        {
          "name": "size",
          "docstring": null
        },
        {
          "name": "mode",
          "docstring": null
        },
        {
          "name": "readonly",
          "docstring": null
        },
        {
          "name": "readonly",
          "docstring": null
        },
        {
          "name": "close",
          "docstring": "This operation will destroy the image core and release its memory.\nThe image data will be unusable afterward.\n\nThis function is required to close images that have multiple frames or\nhave not had their file read and closed by the\n:py:meth:`~PIL.Image.Image.load` method. See :ref:`file-handling` for\nmore information."
        },
        {
          "name": "tobytes",
          "docstring": "Return image as a bytes object.\n\n.. warning::\n\n    This method returns raw image data derived from Pillow's internal\n    storage. For compressed image data (e.g. PNG, JPEG) use\n    :meth:`~.save`, with a BytesIO parameter for in-memory data.\n\n:param encoder_name: What encoder to use.\n\n                     The default is to use the standard \"raw\" encoder.\n                     To see how this packs pixel data into the returned\n                     bytes, see :file:`libImaging/Pack.c`.\n\n                     A list of C encoders can be seen under codecs\n                     section of the function array in\n                     :file:`_imaging.c`. Python encoders are registered\n                     within the relevant plugins.\n:param args: Extra arguments to the encoder.\n:returns: A :py:class:`bytes` object."
        },
        {
          "name": "tobitmap",
          "docstring": "Returns the image converted to an X11 bitmap.\n\n.. note:: This method only works for mode \"1\" images.\n\n:param name: The name prefix to use for the bitmap variables.\n:returns: A string containing an X11 bitmap.\n:raises ValueError: If the mode is not \"1\""
        },
        {
          "name": "frombytes",
          "docstring": "Loads this image with pixel data from a bytes object.\n\nThis method is similar to the :py:func:`~PIL.Image.frombytes` function,\nbut loads data into this image instead of creating a new image object."
        },
        {
          "name": "load",
          "docstring": "Allocates storage for the image and loads the pixel data.  In\nnormal cases, you don't need to call this method, since the\nImage class automatically loads an opened image when it is\naccessed for the first time.\n\nIf the file associated with the image was opened by Pillow, then this\nmethod will close it. The exception to this is if the image has\nmultiple frames, in which case the file will be left open for seek\noperations. See :ref:`file-handling` for more information.\n\n:returns: An image access object.\n:rtype: :py:class:`.PixelAccess`"
        },
        {
          "name": "verify",
          "docstring": "Verifies the contents of a file. For data read from a file, this\nmethod attempts to determine if the file is broken, without\nactually decoding the image data.  If this method finds any\nproblems, it raises suitable exceptions.  If you need to load\nthe image after using this method, you must reopen the image\nfile."
        },
        {
          "name": "convert",
          "docstring": "Returns a converted copy of this image. For the \"P\" mode, this\nmethod translates pixels through the palette.  If mode is\nomitted, a mode is chosen so that all information in the image\nand the palette can be represented without a palette.\n\nThis supports all possible conversions between \"L\", \"RGB\" and \"CMYK\". The\n``matrix`` argument only supports \"L\" and \"RGB\".\n\nWhen translating a color image to grayscale (mode \"L\"),\nthe library uses the ITU-R 601-2 luma transform::\n\n    L = R * 299/1000 + G * 587/1000 + B * 114/1000\n\nThe default method of converting a grayscale (\"L\") or \"RGB\"\nimage into a bilevel (mode \"1\") image uses Floyd-Steinberg\ndither to approximate the original image luminosity levels. If\ndither is ``None``, all values larger than 127 are set to 255 (white),\nall other values to 0 (black). To use other thresholds, use the\n:py:meth:`~PIL.Image.Image.point` method.\n\nWhen converting from \"RGBA\" to \"P\" without a ``matrix`` argument,\nthis passes the operation to :py:meth:`~PIL.Image.Image.quantize`,\nand ``dither`` and ``palette`` are ignored.\n\nWhen converting from \"PA\", if an \"RGBA\" palette is present, the alpha\nchannel from the image will be used instead of the values from the palette.\n\n:param mode: The requested mode. See: :ref:`concept-modes`.\n:param matrix: An optional conversion matrix.  If given, this\n   should be 4- or 12-tuple containing floating point values.\n:param dither: Dithering method, used when converting from\n   mode \"RGB\" to \"P\" or from \"RGB\" or \"L\" to \"1\".\n   Available methods are :data:`Dither.NONE` or :data:`Dither.FLOYDSTEINBERG`\n   (default). Note that this is not used when ``matrix`` is supplied.\n:param palette: Palette to use when converting from mode \"RGB\"\n   to \"P\".  Available palettes are :data:`Palette.WEB` or\n   :data:`Palette.ADAPTIVE`.\n:param colors: Number of colors to use for the :data:`Palette.ADAPTIVE`\n   palette. Defaults to 256.\n:rtype: :py:class:`~PIL.Image.Image`\n:returns: An :py:class:`~PIL.Image.Image` object."
        },
        {
          "name": "quantize",
          "docstring": "Convert the image to 'P' mode with the specified number\nof colors.\n\n:param colors: The desired number of colors, <= 256\n:param method: :data:`Quantize.MEDIANCUT` (median cut),\n               :data:`Quantize.MAXCOVERAGE` (maximum coverage),\n               :data:`Quantize.FASTOCTREE` (fast octree),\n               :data:`Quantize.LIBIMAGEQUANT` (libimagequant; check support\n               using :py:func:`PIL.features.check_feature` with\n               ``feature=\"libimagequant\"``).\n\n               By default, :data:`Quantize.MEDIANCUT` will be used.\n\n               The exception to this is RGBA images. :data:`Quantize.MEDIANCUT`\n               and :data:`Quantize.MAXCOVERAGE` do not support RGBA images, so\n               :data:`Quantize.FASTOCTREE` is used by default instead.\n:param kmeans: Integer greater than or equal to zero.\n:param palette: Quantize to the palette of given\n                :py:class:`PIL.Image.Image`.\n:param dither: Dithering method, used when converting from\n   mode \"RGB\" to \"P\" or from \"RGB\" or \"L\" to \"1\".\n   Available methods are :data:`Dither.NONE` or :data:`Dither.FLOYDSTEINBERG`\n   (default).\n:returns: A new image"
        },
        {
          "name": "copy",
          "docstring": "Copies this image. Use this method if you wish to paste things\ninto an image, but still retain the original.\n\n:rtype: :py:class:`~PIL.Image.Image`\n:returns: An :py:class:`~PIL.Image.Image` object."
        },
        {
          "name": "crop",
          "docstring": "Returns a rectangular region from this image. The box is a\n4-tuple defining the left, upper, right, and lower pixel\ncoordinate. See :ref:`coordinate-system`.\n\nNote: Prior to Pillow 3.4.0, this was a lazy operation.\n\n:param box: The crop rectangle, as a (left, upper, right, lower)-tuple.\n:rtype: :py:class:`~PIL.Image.Image`\n:returns: An :py:class:`~PIL.Image.Image` object."
        },
        {
          "name": "draft",
          "docstring": "Configures the image file loader so it returns a version of the\nimage that as closely as possible matches the given mode and\nsize. For example, you can use this method to convert a color\nJPEG to grayscale while loading it.\n\nIf any changes are made, returns a tuple with the chosen ``mode`` and\n``box`` with coordinates of the original image within the altered one.\n\nNote that this method modifies the :py:class:`~PIL.Image.Image` object\nin place. If the image has already been loaded, this method has no\neffect.\n\nNote: This method is not implemented for most images. It is\ncurrently implemented only for JPEG and MPO images.\n\n:param mode: The requested mode.\n:param size: The requested size in pixels, as a 2-tuple:\n   (width, height)."
        },
        {
          "name": "filter",
          "docstring": "Filters this image using the given filter.  For a list of\navailable filters, see the :py:mod:`~PIL.ImageFilter` module.\n\n:param filter: Filter kernel.\n:returns: An :py:class:`~PIL.Image.Image` object."
        },
        {
          "name": "getbands",
          "docstring": "Returns a tuple containing the name of each band in this image.\nFor example, ``getbands`` on an RGB image returns (\"R\", \"G\", \"B\").\n\n:returns: A tuple containing band names.\n:rtype: tuple"
        },
        {
          "name": "getbbox",
          "docstring": "Calculates the bounding box of the non-zero regions in the\nimage.\n\n:param alpha_only: Optional flag, defaulting to ``True``.\n   If ``True`` and the image has an alpha channel, trim transparent pixels.\n   Otherwise, trim pixels when all channels are zero.\n   Keyword-only argument.\n:returns: The bounding box is returned as a 4-tuple defining the\n   left, upper, right, and lower pixel coordinate. See\n   :ref:`coordinate-system`. If the image is completely empty, this\n   method returns None."
        },
        {
          "name": "getcolors",
          "docstring": "Returns a list of colors used in this image.\n\nThe colors will be in the image's mode. For example, an RGB image will\nreturn a tuple of (red, green, blue) color values, and a P image will\nreturn the index of the color in the palette.\n\n:param maxcolors: Maximum number of colors.  If this number is\n   exceeded, this method returns None.  The default limit is\n   256 colors.\n:returns: An unsorted list of (count, pixel) values."
        },
        {
          "name": "getdata",
          "docstring": "Returns the contents of this image as a sequence object\ncontaining pixel values.  The sequence object is flattened, so\nthat values for line one follow directly after the values of\nline zero, and so on.\n\nNote that the sequence object returned by this method is an\ninternal PIL data type, which only supports certain sequence\noperations.  To convert it to an ordinary sequence (e.g. for\nprinting), use ``list(im.getdata())``.\n\n:param band: What band to return.  The default is to return\n   all bands.  To return a single band, pass in the index\n   value (e.g. 0 to get the \"R\" band from an \"RGB\" image).\n:returns: A sequence-like object."
        },
        {
          "name": "getextrema",
          "docstring": "Gets the minimum and maximum pixel values for each band in\nthe image.\n\n:returns: For a single-band image, a 2-tuple containing the\n   minimum and maximum pixel value.  For a multi-band image,\n   a tuple containing one 2-tuple for each band."
        },
        {
          "name": "getxmp",
          "docstring": "Returns a dictionary containing the XMP tags.\nRequires defusedxml to be installed.\n\n:returns: XMP tags in a dictionary."
        },
        {
          "name": "getexif",
          "docstring": "Gets EXIF data from the image.\n\n:returns: an :py:class:`~PIL.Image.Exif` object."
        },
        {
          "name": "get_child_images",
          "docstring": null
        },
        {
          "name": "getim",
          "docstring": "Returns a capsule that points to the internal image memory.\n\n:returns: A capsule object."
        },
        {
          "name": "getpalette",
          "docstring": "Returns the image palette as a list.\n\n:param rawmode: The mode in which to return the palette. ``None`` will\n   return the palette in its current mode.\n\n   .. versionadded:: 9.1.0\n\n:returns: A list of color values [r, g, b, ...], or None if the\n   image has no palette."
        },
        {
          "name": "has_transparency_data",
          "docstring": "Determine if an image has transparency data, whether in the form of an\nalpha channel, a palette with an alpha channel, or a \"transparency\" key\nin the info dictionary.\n\nNote the image might still appear solid, if all of the values shown\nwithin are opaque.\n\n:returns: A boolean."
        },
        {
          "name": "apply_transparency",
          "docstring": "If a P mode image has a \"transparency\" key in the info dictionary,\nremove the key and instead apply the transparency to the palette.\nOtherwise, the image is unchanged."
        },
        {
          "name": "getpixel",
          "docstring": "Returns the pixel value at a given position.\n\n:param xy: The coordinate, given as (x, y). See\n   :ref:`coordinate-system`.\n:returns: The pixel value.  If the image is a multi-layer image,\n   this method returns a tuple."
        },
        {
          "name": "getprojection",
          "docstring": "Get projection to x and y axes\n\n:returns: Two sequences, indicating where there are non-zero\n    pixels along the X-axis and the Y-axis, respectively."
        },
        {
          "name": "histogram",
          "docstring": "Returns a histogram for the image. The histogram is returned as a\nlist of pixel counts, one for each pixel value in the source\nimage. Counts are grouped into 256 bins for each band, even if\nthe image has more than 8 bits per band. If the image has more\nthan one band, the histograms for all bands are concatenated (for\nexample, the histogram for an \"RGB\" image contains 768 values).\n\nA bilevel image (mode \"1\") is treated as a grayscale (\"L\") image\nby this method.\n\nIf a mask is provided, the method returns a histogram for those\nparts of the image where the mask image is non-zero. The mask\nimage must have the same size as the image, and be either a\nbi-level image (mode \"1\") or a grayscale image (\"L\").\n\n:param mask: An optional mask.\n:param extrema: An optional tuple of manually-specified extrema.\n:returns: A list containing pixel counts."
        },
        {
          "name": "entropy",
          "docstring": "Calculates and returns the entropy for the image.\n\nA bilevel image (mode \"1\") is treated as a grayscale (\"L\")\nimage by this method.\n\nIf a mask is provided, the method employs the histogram for\nthose parts of the image where the mask image is non-zero.\nThe mask image must have the same size as the image, and be\neither a bi-level image (mode \"1\") or a grayscale image (\"L\").\n\n:param mask: An optional mask.\n:param extrema: An optional tuple of manually-specified extrema.\n:returns: A float value representing the image entropy"
        },
        {
          "name": "paste",
          "docstring": "Pastes another image into this image. The box argument is either\na 2-tuple giving the upper left corner, a 4-tuple defining the\nleft, upper, right, and lower pixel coordinate, or None (same as\n(0, 0)). See :ref:`coordinate-system`. If a 4-tuple is given, the size\nof the pasted image must match the size of the region.\n\nIf the modes don't match, the pasted image is converted to the mode of\nthis image (see the :py:meth:`~PIL.Image.Image.convert` method for\ndetails).\n\nInstead of an image, the source can be a integer or tuple\ncontaining pixel values.  The method then fills the region\nwith the given color.  When creating RGB images, you can\nalso use color strings as supported by the ImageColor module.\n\nIf a mask is given, this method updates only the regions\nindicated by the mask. You can use either \"1\", \"L\", \"LA\", \"RGBA\"\nor \"RGBa\" images (if present, the alpha band is used as mask).\nWhere the mask is 255, the given image is copied as is.  Where\nthe mask is 0, the current value is preserved.  Intermediate\nvalues will mix the two images together, including their alpha\nchannels if they have them.\n\nSee :py:meth:`~PIL.Image.Image.alpha_composite` if you want to\ncombine images with respect to their alpha channels.\n\n:param im: Source image or pixel value (integer, float or tuple).\n:param box: An optional 4-tuple giving the region to paste into.\n   If a 2-tuple is used instead, it's treated as the upper left\n   corner.  If omitted or None, the source is pasted into the\n   upper left corner.\n\n   If an image is given as the second argument and there is no\n   third, the box defaults to (0, 0), and the second argument\n   is interpreted as a mask image.\n:param mask: An optional mask image."
        },
        {
          "name": "alpha_composite",
          "docstring": "'In-place' analog of Image.alpha_composite. Composites an image\nonto this image.\n\n:param im: image to composite over this one\n:param dest: Optional 2 tuple (left, top) specifying the upper\n  left corner in this (destination) image.\n:param source: Optional 2 (left, top) tuple for the upper left\n  corner in the overlay source image, or 4 tuple (left, top, right,\n  bottom) for the bounds of the source rectangle\n\nPerformance Note: Not currently implemented in-place in the core layer."
        },
        {
          "name": "point",
          "docstring": "Maps this image through a lookup table or function.\n\n:param lut: A lookup table, containing 256 (or 65536 if\n   self.mode==\"I\" and mode == \"L\") values per band in the\n   image.  A function can be used instead, it should take a\n   single argument. The function is called once for each\n   possible pixel value, and the resulting table is applied to\n   all bands of the image.\n\n   It may also be an :py:class:`~PIL.Image.ImagePointHandler`\n   object::\n\n       class Example(Image.ImagePointHandler):\n         def point(self, im: Image) -> Image:\n           # Return result\n:param mode: Output mode (default is same as input). This can only be used if\n   the source image has mode \"L\" or \"P\", and the output has mode \"1\" or the\n   source image mode is \"I\" and the output mode is \"L\".\n:returns: An :py:class:`~PIL.Image.Image` object."
        },
        {
          "name": "putalpha",
          "docstring": "Adds or replaces the alpha layer in this image.  If the image\ndoes not have an alpha layer, it's converted to \"LA\" or \"RGBA\".\nThe new layer must be either \"L\" or \"1\".\n\n:param alpha: The new alpha layer.  This can either be an \"L\" or \"1\"\n   image having the same size as this image, or an integer."
        },
        {
          "name": "putdata",
          "docstring": "Copies pixel data from a flattened sequence object into the image. The\nvalues should start at the upper left corner (0, 0), continue to the\nend of the line, followed directly by the first value of the second\nline, and so on. Data will be read until either the image or the\nsequence ends. The scale and offset values are used to adjust the\nsequence values: **pixel = value*scale + offset**.\n\n:param data: A flattened sequence object.\n:param scale: An optional scale value.  The default is 1.0.\n:param offset: An optional offset value.  The default is 0.0."
        },
        {
          "name": "putpalette",
          "docstring": "Attaches a palette to this image.  The image must be a \"P\", \"PA\", \"L\"\nor \"LA\" image.\n\nThe palette sequence must contain at most 256 colors, made up of one\ninteger value for each channel in the raw mode.\nFor example, if the raw mode is \"RGB\", then it can contain at most 768\nvalues, made up of red, green and blue values for the corresponding pixel\nindex in the 256 colors.\nIf the raw mode is \"RGBA\", then it can contain at most 1024 values,\ncontaining red, green, blue and alpha values.\n\nAlternatively, an 8-bit string may be used instead of an integer sequence.\n\n:param data: A palette sequence (either a list or a string).\n:param rawmode: The raw mode of the palette. Either \"RGB\", \"RGBA\", or a mode\n   that can be transformed to \"RGB\" or \"RGBA\" (e.g. \"R\", \"BGR;15\", \"RGBA;L\")."
        },
        {
          "name": "putpixel",
          "docstring": "Modifies the pixel at the given position. The color is given as\na single numerical value for single-band images, and a tuple for\nmulti-band images. In addition to this, RGB and RGBA tuples are\naccepted for P and PA images.\n\nNote that this method is relatively slow.  For more extensive changes,\nuse :py:meth:`~PIL.Image.Image.paste` or the :py:mod:`~PIL.ImageDraw`\nmodule instead.\n\nSee:\n\n* :py:meth:`~PIL.Image.Image.paste`\n* :py:meth:`~PIL.Image.Image.putdata`\n* :py:mod:`~PIL.ImageDraw`\n\n:param xy: The pixel coordinate, given as (x, y). See\n   :ref:`coordinate-system`.\n:param value: The pixel value."
        },
        {
          "name": "remap_palette",
          "docstring": "Rewrites the image to reorder the palette.\n\n:param dest_map: A list of indexes into the original palette.\n   e.g. ``[1,0]`` would swap a two item palette, and ``list(range(256))``\n   is the identity transform.\n:param source_palette: Bytes or None.\n:returns:  An :py:class:`~PIL.Image.Image` object."
        },
        {
          "name": "resize",
          "docstring": "Returns a resized copy of this image.\n\n:param size: The requested size in pixels, as a tuple or array:\n   (width, height).\n:param resample: An optional resampling filter.  This can be\n   one of :py:data:`Resampling.NEAREST`, :py:data:`Resampling.BOX`,\n   :py:data:`Resampling.BILINEAR`, :py:data:`Resampling.HAMMING`,\n   :py:data:`Resampling.BICUBIC` or :py:data:`Resampling.LANCZOS`.\n   If the image has mode \"1\" or \"P\", it is always set to\n   :py:data:`Resampling.NEAREST`. If the image mode is \"BGR;15\",\n   \"BGR;16\" or \"BGR;24\", then the default filter is\n   :py:data:`Resampling.NEAREST`. Otherwise, the default filter is\n   :py:data:`Resampling.BICUBIC`. See: :ref:`concept-filters`.\n:param box: An optional 4-tuple of floats providing\n   the source image region to be scaled.\n   The values must be within (0, 0, width, height) rectangle.\n   If omitted or None, the entire source is used.\n:param reducing_gap: Apply optimization by resizing the image\n   in two steps. First, reducing the image by integer times\n   using :py:meth:`~PIL.Image.Image.reduce`.\n   Second, resizing using regular resampling. The last step\n   changes size no less than by ``reducing_gap`` times.\n   ``reducing_gap`` may be None (no first step is performed)\n   or should be greater than 1.0. The bigger ``reducing_gap``,\n   the closer the result to the fair resampling.\n   The smaller ``reducing_gap``, the faster resizing.\n   With ``reducing_gap`` greater or equal to 3.0, the result is\n   indistinguishable from fair resampling in most cases.\n   The default value is None (no optimization).\n:returns: An :py:class:`~PIL.Image.Image` object."
        },
        {
          "name": "reduce",
          "docstring": "Returns a copy of the image reduced ``factor`` times.\nIf the size of the image is not dividable by ``factor``,\nthe resulting size will be rounded up.\n\n:param factor: A greater than 0 integer or tuple of two integers\n   for width and height separately.\n:param box: An optional 4-tuple of ints providing\n   the source image region to be reduced.\n   The values must be within ``(0, 0, width, height)`` rectangle.\n   If omitted or ``None``, the entire source is used."
        },
        {
          "name": "rotate",
          "docstring": "Returns a rotated copy of this image.  This method returns a\ncopy of this image, rotated the given number of degrees counter\nclockwise around its centre.\n\n:param angle: In degrees counter clockwise.\n:param resample: An optional resampling filter.  This can be\n   one of :py:data:`Resampling.NEAREST` (use nearest neighbour),\n   :py:data:`Resampling.BILINEAR` (linear interpolation in a 2x2\n   environment), or :py:data:`Resampling.BICUBIC` (cubic spline\n   interpolation in a 4x4 environment). If omitted, or if the image has\n   mode \"1\" or \"P\", it is set to :py:data:`Resampling.NEAREST`.\n   See :ref:`concept-filters`.\n:param expand: Optional expansion flag.  If true, expands the output\n   image to make it large enough to hold the entire rotated image.\n   If false or omitted, make the output image the same size as the\n   input image.  Note that the expand flag assumes rotation around\n   the center and no translation.\n:param center: Optional center of rotation (a 2-tuple).  Origin is\n   the upper left corner.  Default is the center of the image.\n:param translate: An optional post-rotate translation (a 2-tuple).\n:param fillcolor: An optional color for area outside the rotated image.\n:returns: An :py:class:`~PIL.Image.Image` object."
        },
        {
          "name": "save",
          "docstring": "Saves this image under the given filename.  If no format is\nspecified, the format to use is determined from the filename\nextension, if possible.\n\nKeyword options can be used to provide additional instructions\nto the writer. If a writer doesn't recognise an option, it is\nsilently ignored. The available options are described in the\n:doc:`image format documentation\n<../handbook/image-file-formats>` for each writer.\n\nYou can use a file object instead of a filename. In this case,\nyou must always specify the format. The file object must\nimplement the ``seek``, ``tell``, and ``write``\nmethods, and be opened in binary mode.\n\n:param fp: A filename (string), os.PathLike object or file object.\n:param format: Optional format override.  If omitted, the\n   format to use is determined from the filename extension.\n   If a file object was used instead of a filename, this\n   parameter should always be used.\n:param params: Extra parameters to the image writer. These can also be\n   set on the image itself through ``encoderinfo``. This is useful when\n   saving multiple images::\n\n     # Saving XMP data to a single image\n     from PIL import Image\n     red = Image.new(\"RGB\", (1, 1), \"#f00\")\n     red.save(\"out.mpo\", xmp=b\"test\")\n\n     # Saving XMP data to the second frame of an image\n     from PIL import Image\n     black = Image.new(\"RGB\", (1, 1))\n     red = Image.new(\"RGB\", (1, 1), \"#f00\")\n     red.encoderinfo = {\"xmp\": b\"test\"}\n     black.save(\"out.mpo\", save_all=True, append_images=[red])\n:returns: None\n:exception ValueError: If the output format could not be determined\n   from the file name.  Use the format option to solve this.\n:exception OSError: If the file could not be written.  The file\n   may have been created, and may contain partial data."
        },
        {
          "name": "seek",
          "docstring": "Seeks to the given frame in this sequence file. If you seek\nbeyond the end of the sequence, the method raises an\n``EOFError`` exception. When a sequence file is opened, the\nlibrary automatically seeks to frame 0.\n\nSee :py:meth:`~PIL.Image.Image.tell`.\n\nIf defined, :attr:`~PIL.Image.Image.n_frames` refers to the\nnumber of available frames.\n\n:param frame: Frame number, starting at 0.\n:exception EOFError: If the call attempts to seek beyond the end\n    of the sequence."
        },
        {
          "name": "show",
          "docstring": "Displays this image. This method is mainly intended for debugging purposes.\n\nThis method calls :py:func:`PIL.ImageShow.show` internally. You can use\n:py:func:`PIL.ImageShow.register` to override its default behaviour.\n\nThe image is first saved to a temporary file. By default, it will be in\nPNG format.\n\nOn Unix, the image is then opened using the **xdg-open**, **display**,\n**gm**, **eog** or **xv** utility, depending on which one can be found.\n\nOn macOS, the image is opened with the native Preview application.\n\nOn Windows, the image is opened with the standard PNG display utility.\n\n:param title: Optional title to use for the image window, where possible."
        },
        {
          "name": "split",
          "docstring": "Split this image into individual bands. This method returns a\ntuple of individual image bands from an image. For example,\nsplitting an \"RGB\" image creates three new images each\ncontaining a copy of one of the original bands (red, green,\nblue).\n\nIf you need only one band, :py:meth:`~PIL.Image.Image.getchannel`\nmethod can be more convenient and faster.\n\n:returns: A tuple containing bands."
        },
        {
          "name": "getchannel",
          "docstring": "Returns an image containing a single channel of the source image.\n\n:param channel: What channel to return. Could be index\n  (0 for \"R\" channel of \"RGB\") or channel name\n  (\"A\" for alpha channel of \"RGBA\").\n:returns: An image in \"L\" mode.\n\n.. versionadded:: 4.3.0"
        },
        {
          "name": "tell",
          "docstring": "Returns the current frame number. See :py:meth:`~PIL.Image.Image.seek`.\n\nIf defined, :attr:`~PIL.Image.Image.n_frames` refers to the\nnumber of available frames.\n\n:returns: Frame number, starting with 0."
        },
        {
          "name": "thumbnail",
          "docstring": "Make this image into a thumbnail.  This method modifies the\nimage to contain a thumbnail version of itself, no larger than\nthe given size.  This method calculates an appropriate thumbnail\nsize to preserve the aspect of the image, calls the\n:py:meth:`~PIL.Image.Image.draft` method to configure the file reader\n(where applicable), and finally resizes the image.\n\nNote that this function modifies the :py:class:`~PIL.Image.Image`\nobject in place.  If you need to use the full resolution image as well,\napply this method to a :py:meth:`~PIL.Image.Image.copy` of the original\nimage.\n\n:param size: The requested size in pixels, as a 2-tuple:\n   (width, height).\n:param resample: Optional resampling filter.  This can be one\n   of :py:data:`Resampling.NEAREST`, :py:data:`Resampling.BOX`,\n   :py:data:`Resampling.BILINEAR`, :py:data:`Resampling.HAMMING`,\n   :py:data:`Resampling.BICUBIC` or :py:data:`Resampling.LANCZOS`.\n   If omitted, it defaults to :py:data:`Resampling.BICUBIC`.\n   (was :py:data:`Resampling.NEAREST` prior to version 2.5.0).\n   See: :ref:`concept-filters`.\n:param reducing_gap: Apply optimization by resizing the image\n   in two steps. First, reducing the image by integer times\n   using :py:meth:`~PIL.Image.Image.reduce` or\n   :py:meth:`~PIL.Image.Image.draft` for JPEG images.\n   Second, resizing using regular resampling. The last step\n   changes size no less than by ``reducing_gap`` times.\n   ``reducing_gap`` may be None (no first step is performed)\n   or should be greater than 1.0. The bigger ``reducing_gap``,\n   the closer the result to the fair resampling.\n   The smaller ``reducing_gap``, the faster resizing.\n   With ``reducing_gap`` greater or equal to 3.0, the result is\n   indistinguishable from fair resampling in most cases.\n   The default value is 2.0 (very close to fair resampling\n   while still being faster in many cases).\n:returns: None"
        },
        {
          "name": "transform",
          "docstring": "Transforms this image.  This method creates a new image with the\ngiven size, and the same mode as the original, and copies data\nto the new image using the given transform.\n\n:param size: The output size in pixels, as a 2-tuple:\n   (width, height).\n:param method: The transformation method.  This is one of\n  :py:data:`Transform.EXTENT` (cut out a rectangular subregion),\n  :py:data:`Transform.AFFINE` (affine transform),\n  :py:data:`Transform.PERSPECTIVE` (perspective transform),\n  :py:data:`Transform.QUAD` (map a quadrilateral to a rectangle), or\n  :py:data:`Transform.MESH` (map a number of source quadrilaterals\n  in one operation).\n\n  It may also be an :py:class:`~PIL.Image.ImageTransformHandler`\n  object::\n\n    class Example(Image.ImageTransformHandler):\n        def transform(self, size, data, resample, fill=1):\n            # Return result\n\n  Implementations of :py:class:`~PIL.Image.ImageTransformHandler`\n  for some of the :py:class:`Transform` methods are provided\n  in :py:mod:`~PIL.ImageTransform`.\n\n  It may also be an object with a ``method.getdata`` method\n  that returns a tuple supplying new ``method`` and ``data`` values::\n\n    class Example:\n        def getdata(self):\n            method = Image.Transform.EXTENT\n            data = (0, 0, 100, 100)\n            return method, data\n:param data: Extra data to the transformation method.\n:param resample: Optional resampling filter.  It can be one of\n   :py:data:`Resampling.NEAREST` (use nearest neighbour),\n   :py:data:`Resampling.BILINEAR` (linear interpolation in a 2x2\n   environment), or :py:data:`Resampling.BICUBIC` (cubic spline\n   interpolation in a 4x4 environment). If omitted, or if the image\n   has mode \"1\" or \"P\", it is set to :py:data:`Resampling.NEAREST`.\n   See: :ref:`concept-filters`.\n:param fill: If ``method`` is an\n  :py:class:`~PIL.Image.ImageTransformHandler` object, this is one of\n  the arguments passed to it. Otherwise, it is unused.\n:param fillcolor: Optional fill color for the area outside the\n   transform in the output image.\n:returns: An :py:class:`~PIL.Image.Image` object."
        },
        {
          "name": "transpose",
          "docstring": "Transpose image (flip or rotate in 90 degree steps)\n\n:param method: One of :py:data:`Transpose.FLIP_LEFT_RIGHT`,\n  :py:data:`Transpose.FLIP_TOP_BOTTOM`, :py:data:`Transpose.ROTATE_90`,\n  :py:data:`Transpose.ROTATE_180`, :py:data:`Transpose.ROTATE_270`,\n  :py:data:`Transpose.TRANSPOSE` or :py:data:`Transpose.TRANSVERSE`.\n:returns: Returns a flipped or rotated copy of this image."
        },
        {
          "name": "effect_spread",
          "docstring": "Randomly spread pixels in an image.\n\n:param distance: Distance to spread pixels."
        },
        {
          "name": "toqimage",
          "docstring": "Returns a QImage copy of this image"
        },
        {
          "name": "toqpixmap",
          "docstring": "Returns a QPixmap copy of this image"
        }
      ]
    },
    {
      "name": "ImagePointHandler",
      "docstring": "Used as a mixin by point transforms\n(for use with :py:meth:`~PIL.Image.Image.point`)",
      "methods": [
        {
          "name": "point",
          "docstring": null
        }
      ]
    },
    {
      "name": "ImageTransformHandler",
      "docstring": "Used as a mixin by geometry transforms\n(for use with :py:meth:`~PIL.Image.Image.transform`)",
      "methods": [
        {
          "name": "transform",
          "docstring": null
        }
      ]
    },
    {
      "name": "SupportsArrayInterface",
      "docstring": "An object that has an ``__array_interface__`` dictionary.",
      "methods": []
    },
    {
      "name": "SupportsArrowArrayInterface",
      "docstring": "An object that has an ``__arrow_c_array__`` method corresponding to the arrow c\ndata interface.",
      "methods": []
    },
    {
      "name": "Exif",
      "docstring": "This class provides read and write access to EXIF image data::\n\n  from PIL import Image\n  im = Image.open(\"exif.png\")\n  exif = im.getexif()  # Returns an instance of this class\n\nInformation can be read and written, iterated over or deleted::\n\n  print(exif[274])  # 1\n  exif[274] = 2\n  for k, v in exif.items():\n    print(\"Tag\", k, \"Value\", v)  # Tag 274 Value 2\n  del exif[274]\n\nTo access information beyond IFD0, :py:meth:`~PIL.Image.Exif.get_ifd`\nreturns a dictionary::\n\n  from PIL import ExifTags\n  im = Image.open(\"exif_gps.jpg\")\n  exif = im.getexif()\n  gps_ifd = exif.get_ifd(ExifTags.IFD.GPSInfo)\n  print(gps_ifd)\n\nOther IFDs include ``ExifTags.IFD.Exif``, ``ExifTags.IFD.MakerNote``,\n``ExifTags.IFD.Interop`` and ``ExifTags.IFD.IFD1``.\n\n:py:mod:`~PIL.ExifTags` also has enum classes to provide names for data::\n\n  print(exif[ExifTags.Base.Software])  # PIL\n  print(gps_ifd[ExifTags.GPS.GPSDateStamp])  # 1999:99:99 99:99:99",
      "methods": [
        {
          "name": "__init__",
          "docstring": null
        },
        {
          "name": "load",
          "docstring": null
        },
        {
          "name": "load_from_fp",
          "docstring": null
        },
        {
          "name": "tobytes",
          "docstring": null
        },
        {
          "name": "get_ifd",
          "docstring": null
        },
        {
          "name": "hide_offsets",
          "docstring": null
        }
      ]
    }
  ],
  "functions": [
    {
      "name": "isImageType",
      "docstring": "Checks if an object is an image object.\n\n.. warning::\n\n   This function is for internal use only.\n\n:param t: object to check if it's an image\n:returns: True if the object is an image"
    },
    {
      "name": "getmodebase",
      "docstring": "Gets the \"base\" mode for given mode.  This function returns \"L\" for\nimages that contain grayscale data, and \"RGB\" for images that\ncontain color data.\n\n:param mode: Input mode.\n:returns: \"L\" or \"RGB\".\n:exception KeyError: If the input mode was not a standard mode."
    },
    {
      "name": "getmodetype",
      "docstring": "Gets the storage type mode.  Given a mode, this function returns a\nsingle-layer mode suitable for storing individual bands.\n\n:param mode: Input mode.\n:returns: \"L\", \"I\", or \"F\".\n:exception KeyError: If the input mode was not a standard mode."
    },
    {
      "name": "getmodebandnames",
      "docstring": "Gets a list of individual band names.  Given a mode, this function returns\na tuple containing the names of individual bands (use\n:py:method:`~PIL.Image.getmodetype` to get the mode used to store each\nindividual band.\n\n:param mode: Input mode.\n:returns: A tuple containing band names.  The length of the tuple\n    gives the number of bands in an image of the given mode.\n:exception KeyError: If the input mode was not a standard mode."
    },
    {
      "name": "getmodebands",
      "docstring": "Gets the number of individual bands for this mode.\n\n:param mode: Input mode.\n:returns: The number of bands in this mode.\n:exception KeyError: If the input mode was not a standard mode."
    },
    {
      "name": "preinit",
      "docstring": "Explicitly loads BMP, GIF, JPEG, PPM and PPM file format drivers.\n\nIt is called when opening or saving images."
    },
    {
      "name": "init",
      "docstring": "Explicitly initializes the Python Imaging Library. This function\nloads all available file format drivers.\n\nIt is called when opening or saving images if :py:meth:`~preinit()` is\ninsufficient, and by :py:meth:`~PIL.features.pilinfo`."
    },
    {
      "name": "new",
      "docstring": "Creates a new image with the given mode and size.\n\n:param mode: The mode to use for the new image. See:\n   :ref:`concept-modes`.\n:param size: A 2-tuple, containing (width, height) in pixels.\n:param color: What color to use for the image.  Default is black.\n   If given, this should be a single integer or floating point value\n   for single-band modes, and a tuple for multi-band modes (one value\n   per band).  When creating RGB or HSV images, you can also use color\n   strings as supported by the ImageColor module.  If the color is\n   None, the image is not initialised.\n:returns: An :py:class:`~PIL.Image.Image` object."
    },
    {
      "name": "frombytes",
      "docstring": "Creates a copy of an image memory from pixel data in a buffer.\n\nIn its simplest form, this function takes three arguments\n(mode, size, and unpacked pixel data).\n\nYou can also use any pixel decoder supported by PIL. For more\ninformation on available decoders, see the section\n:ref:`Writing Your Own File Codec <file-codecs>`.\n\nNote that this function decodes pixel data only, not entire images.\nIf you have an entire image in a string, wrap it in a\n:py:class:`~io.BytesIO` object, and use :py:func:`~PIL.Image.open` to load\nit.\n\n:param mode: The image mode. See: :ref:`concept-modes`.\n:param size: The image size.\n:param data: A byte buffer containing raw data for the given mode.\n:param decoder_name: What decoder to use.\n:param args: Additional parameters for the given decoder.\n:returns: An :py:class:`~PIL.Image.Image` object."
    },
    {
      "name": "frombuffer",
      "docstring": "Creates an image memory referencing pixel data in a byte buffer.\n\nThis function is similar to :py:func:`~PIL.Image.frombytes`, but uses data\nin the byte buffer, where possible.  This means that changes to the\noriginal buffer object are reflected in this image).  Not all modes can\nshare memory; supported modes include \"L\", \"RGBX\", \"RGBA\", and \"CMYK\".\n\nNote that this function decodes pixel data only, not entire images.\nIf you have an entire image file in a string, wrap it in a\n:py:class:`~io.BytesIO` object, and use :py:func:`~PIL.Image.open` to load it.\n\nThe default parameters used for the \"raw\" decoder differs from that used for\n:py:func:`~PIL.Image.frombytes`. This is a bug, and will probably be fixed in a\nfuture release. The current release issues a warning if you do this; to disable\nthe warning, you should provide the full set of parameters. See below for details.\n\n:param mode: The image mode. See: :ref:`concept-modes`.\n:param size: The image size.\n:param data: A bytes or other buffer object containing raw\n    data for the given mode.\n:param decoder_name: What decoder to use.\n:param args: Additional parameters for the given decoder.  For the\n    default encoder (\"raw\"), it's recommended that you provide the\n    full set of parameters::\n\n        frombuffer(mode, size, data, \"raw\", mode, 0, 1)\n\n:returns: An :py:class:`~PIL.Image.Image` object.\n\n.. versionadded:: 1.1.4"
    },
    {
      "name": "fromarray",
      "docstring": "Creates an image memory from an object exporting the array interface\n(using the buffer protocol)::\n\n  from PIL import Image\n  import numpy as np\n  a = np.zeros((5, 5))\n  im = Image.fromarray(a)\n\nIf ``obj`` is not contiguous, then the ``tobytes`` method is called\nand :py:func:`~PIL.Image.frombuffer` is used.\n\nIn the case of NumPy, be aware that Pillow modes do not always correspond\nto NumPy dtypes. Pillow modes only offer 1-bit pixels, 8-bit pixels,\n32-bit signed integer pixels, and 32-bit floating point pixels.\n\nPillow images can also be converted to arrays::\n\n  from PIL import Image\n  import numpy as np\n  im = Image.open(\"hopper.jpg\")\n  a = np.asarray(im)\n\nWhen converting Pillow images to arrays however, only pixel values are\ntransferred. This means that P and PA mode images will lose their palette.\n\n:param obj: Object with array interface\n:param mode: Optional mode to use when reading ``obj``. Will be determined from\n  type if ``None``. Deprecated.\n\n  This will not be used to convert the data after reading, but will be used to\n  change how the data is read::\n\n    from PIL import Image\n    import numpy as np\n    a = np.full((1, 1), 300)\n    im = Image.fromarray(a, mode=\"L\")\n    im.getpixel((0, 0))  # 44\n    im = Image.fromarray(a, mode=\"RGB\")\n    im.getpixel((0, 0))  # (44, 1, 0)\n\n  See: :ref:`concept-modes` for general information about modes.\n:returns: An image object.\n\n.. versionadded:: 1.1.6"
    },
    {
      "name": "fromarrow",
      "docstring": "Creates an image with zero-copy shared memory from an object exporting\nthe arrow_c_array interface protocol::\n\n  from PIL import Image\n  import pyarrow as pa\n  arr = pa.array([0]*(5*5*4), type=pa.uint8())\n  im = Image.fromarrow(arr, 'RGBA', (5, 5))\n\nIf the data representation of the ``obj`` is not compatible with\nPillow internal storage, a ValueError is raised.\n\nPillow images can also be converted to Arrow objects::\n\n  from PIL import Image\n  import pyarrow as pa\n  im = Image.open('hopper.jpg')\n  arr = pa.array(im)\n\nAs with array support, when converting Pillow images to arrays,\nonly pixel values are transferred. This means that P and PA mode\nimages will lose their palette.\n\n:param obj: Object with an arrow_c_array interface\n:param mode: Image mode.\n:param size: Image size. This must match the storage of the arrow object.\n:returns: An Image object\n\nNote that according to the Arrow spec, both the producer and the\nconsumer should consider the exported array to be immutable, as\nunsynchronized updates will potentially cause inconsistent data.\n\nSee: :ref:`arrow-support` for more detailed information\n\n.. versionadded:: 11.2.1"
    },
    {
      "name": "fromqimage",
      "docstring": "Creates an image instance from a QImage image"
    },
    {
      "name": "fromqpixmap",
      "docstring": "Creates an image instance from a QPixmap image"
    },
    {
      "name": "open",
      "docstring": "Opens and identifies the given image file.\n\nThis is a lazy operation; this function identifies the file, but\nthe file remains open and the actual image data is not read from\nthe file until you try to process the data (or call the\n:py:meth:`~PIL.Image.Image.load` method).  See\n:py:func:`~PIL.Image.new`. See :ref:`file-handling`.\n\n:param fp: A filename (string), os.PathLike object or a file object.\n   The file object must implement ``file.read``,\n   ``file.seek``, and ``file.tell`` methods,\n   and be opened in binary mode. The file object will also seek to zero\n   before reading.\n:param mode: The mode.  If given, this argument must be \"r\".\n:param formats: A list or tuple of formats to attempt to load the file in.\n   This can be used to restrict the set of formats checked.\n   Pass ``None`` to try all supported formats. You can print the set of\n   available formats by running ``python3 -m PIL`` or using\n   the :py:func:`PIL.features.pilinfo` function.\n:returns: An :py:class:`~PIL.Image.Image` object.\n:exception FileNotFoundError: If the file cannot be found.\n:exception PIL.UnidentifiedImageError: If the image cannot be opened and\n   identified.\n:exception ValueError: If the ``mode`` is not \"r\", or if a ``StringIO``\n   instance is used for ``fp``.\n:exception TypeError: If ``formats`` is not ``None``, a list or a tuple."
    },
    {
      "name": "alpha_composite",
      "docstring": "Alpha composite im2 over im1.\n\n:param im1: The first image. Must have mode RGBA.\n:param im2: The second image.  Must have mode RGBA, and the same size as\n   the first image.\n:returns: An :py:class:`~PIL.Image.Image` object."
    },
    {
      "name": "blend",
      "docstring": "Creates a new image by interpolating between two input images, using\na constant alpha::\n\n    out = image1 * (1.0 - alpha) + image2 * alpha\n\n:param im1: The first image.\n:param im2: The second image.  Must have the same mode and size as\n   the first image.\n:param alpha: The interpolation alpha factor.  If alpha is 0.0, a\n   copy of the first image is returned. If alpha is 1.0, a copy of\n   the second image is returned. There are no restrictions on the\n   alpha value. If necessary, the result is clipped to fit into\n   the allowed output range.\n:returns: An :py:class:`~PIL.Image.Image` object."
    },
    {
      "name": "composite",
      "docstring": "Create composite image by blending images using a transparency mask.\n\n:param image1: The first image.\n:param image2: The second image.  Must have the same mode and\n   size as the first image.\n:param mask: A mask image.  This image can have mode\n   \"1\", \"L\", or \"RGBA\", and must have the same size as the\n   other two images."
    },
    {
      "name": "eval",
      "docstring": "Applies the function (which should take one argument) to each pixel\nin the given image. If the image has more than one band, the same\nfunction is applied to each band. Note that the function is\nevaluated once for each possible pixel value, so you cannot use\nrandom components or other generators.\n\n:param image: The input image.\n:param function: A function object, taking one integer argument.\n:returns: An :py:class:`~PIL.Image.Image` object."
    },
    {
      "name": "merge",
      "docstring": "Merge a set of single band images into a new multiband image.\n\n:param mode: The mode to use for the output image. See:\n    :ref:`concept-modes`.\n:param bands: A sequence containing one single-band image for\n    each band in the output image.  All bands must have the\n    same size.\n:returns: An :py:class:`~PIL.Image.Image` object."
    },
    {
      "name": "register_open",
      "docstring": "Register an image file plugin.  This function should not be used\nin application code.\n\n:param id: An image format identifier.\n:param factory: An image file factory method.\n:param accept: An optional function that can be used to quickly\n   reject images having another format."
    },
    {
      "name": "register_mime",
      "docstring": "Registers an image MIME type by populating ``Image.MIME``. This function\nshould not be used in application code.\n\n``Image.MIME`` provides a mapping from image format identifiers to mime\nformats, but :py:meth:`~PIL.ImageFile.ImageFile.get_format_mimetype` can\nprovide a different result for specific images.\n\n:param id: An image format identifier.\n:param mimetype: The image MIME type for this format."
    },
    {
      "name": "register_save",
      "docstring": "Registers an image save function.  This function should not be\nused in application code.\n\n:param id: An image format identifier.\n:param driver: A function to save images in this format."
    },
    {
      "name": "register_save_all",
      "docstring": "Registers an image function to save all the frames\nof a multiframe format.  This function should not be\nused in application code.\n\n:param id: An image format identifier.\n:param driver: A function to save images in this format."
    },
    {
      "name": "register_extension",
      "docstring": "Registers an image extension.  This function should not be\nused in application code.\n\n:param id: An image format identifier.\n:param extension: An extension used for this format."
    },
    {
      "name": "register_extensions",
      "docstring": "Registers image extensions.  This function should not be\nused in application code.\n\n:param id: An image format identifier.\n:param extensions: A list of extensions used for this format."
    },
    {
      "name": "registered_extensions",
      "docstring": "Returns a dictionary containing all file extensions belonging\nto registered plugins"
    },
    {
      "name": "register_decoder",
      "docstring": "Registers an image decoder.  This function should not be\nused in application code.\n\n:param name: The name of the decoder\n:param decoder: An ImageFile.PyDecoder object\n\n.. versionadded:: 4.1.0"
    },
    {
      "name": "register_encoder",
      "docstring": "Registers an image encoder.  This function should not be\nused in application code.\n\n:param name: The name of the encoder\n:param encoder: An ImageFile.PyEncoder object\n\n.. versionadded:: 4.1.0"
    },
    {
      "name": "effect_mandelbrot",
      "docstring": "Generate a Mandelbrot set covering the given extent.\n\n:param size: The requested size in pixels, as a 2-tuple:\n   (width, height).\n:param extent: The extent to cover, as a 4-tuple:\n   (x0, y0, x1, y1).\n:param quality: Quality."
    },
    {
      "name": "effect_noise",
      "docstring": "Generate Gaussian noise centered around 128.\n\n:param size: The requested size in pixels, as a 2-tuple:\n   (width, height).\n:param sigma: Standard deviation of noise."
    },
    {
      "name": "linear_gradient",
      "docstring": "Generate 256x256 linear gradient from black to white, top to bottom.\n\n:param mode: Input mode."
    },
    {
      "name": "radial_gradient",
      "docstring": "Generate 256x256 radial gradient from black to white, centre to edge.\n\n:param mode: Input mode."
    },
    {
      "name": "getdata",
      "docstring": null
    },
    {
      "name": "im",
      "docstring": null
    },
    {
      "name": "im",
      "docstring": null
    },
    {
      "name": "width",
      "docstring": null
    },
    {
      "name": "height",
      "docstring": null
    },
    {
      "name": "size",
      "docstring": null
    },
    {
      "name": "mode",
      "docstring": null
    },
    {
      "name": "readonly",
      "docstring": null
    },
    {
      "name": "readonly",
      "docstring": null
    },
    {
      "name": "close",
      "docstring": "This operation will destroy the image core and release its memory.\nThe image data will be unusable afterward.\n\nThis function is required to close images that have multiple frames or\nhave not had their file read and closed by the\n:py:meth:`~PIL.Image.Image.load` method. See :ref:`file-handling` for\nmore information."
    },
    {
      "name": "tobytes",
      "docstring": "Return image as a bytes object.\n\n.. warning::\n\n    This method returns raw image data derived from Pillow's internal\n    storage. For compressed image data (e.g. PNG, JPEG) use\n    :meth:`~.save`, with a BytesIO parameter for in-memory data.\n\n:param encoder_name: What encoder to use.\n\n                     The default is to use the standard \"raw\" encoder.\n                     To see how this packs pixel data into the returned\n                     bytes, see :file:`libImaging/Pack.c`.\n\n                     A list of C encoders can be seen under codecs\n                     section of the function array in\n                     :file:`_imaging.c`. Python encoders are registered\n                     within the relevant plugins.\n:param args: Extra arguments to the encoder.\n:returns: A :py:class:`bytes` object."
    },
    {
      "name": "tobitmap",
      "docstring": "Returns the image converted to an X11 bitmap.\n\n.. note:: This method only works for mode \"1\" images.\n\n:param name: The name prefix to use for the bitmap variables.\n:returns: A string containing an X11 bitmap.\n:raises ValueError: If the mode is not \"1\""
    },
    {
      "name": "frombytes",
      "docstring": "Loads this image with pixel data from a bytes object.\n\nThis method is similar to the :py:func:`~PIL.Image.frombytes` function,\nbut loads data into this image instead of creating a new image object."
    },
    {
      "name": "load",
      "docstring": "Allocates storage for the image and loads the pixel data.  In\nnormal cases, you don't need to call this method, since the\nImage class automatically loads an opened image when it is\naccessed for the first time.\n\nIf the file associated with the image was opened by Pillow, then this\nmethod will close it. The exception to this is if the image has\nmultiple frames, in which case the file will be left open for seek\noperations. See :ref:`file-handling` for more information.\n\n:returns: An image access object.\n:rtype: :py:class:`.PixelAccess`"
    },
    {
      "name": "verify",
      "docstring": "Verifies the contents of a file. For data read from a file, this\nmethod attempts to determine if the file is broken, without\nactually decoding the image data.  If this method finds any\nproblems, it raises suitable exceptions.  If you need to load\nthe image after using this method, you must reopen the image\nfile."
    },
    {
      "name": "convert",
      "docstring": "Returns a converted copy of this image. For the \"P\" mode, this\nmethod translates pixels through the palette.  If mode is\nomitted, a mode is chosen so that all information in the image\nand the palette can be represented without a palette.\n\nThis supports all possible conversions between \"L\", \"RGB\" and \"CMYK\". The\n``matrix`` argument only supports \"L\" and \"RGB\".\n\nWhen translating a color image to grayscale (mode \"L\"),\nthe library uses the ITU-R 601-2 luma transform::\n\n    L = R * 299/1000 + G * 587/1000 + B * 114/1000\n\nThe default method of converting a grayscale (\"L\") or \"RGB\"\nimage into a bilevel (mode \"1\") image uses Floyd-Steinberg\ndither to approximate the original image luminosity levels. If\ndither is ``None``, all values larger than 127 are set to 255 (white),\nall other values to 0 (black). To use other thresholds, use the\n:py:meth:`~PIL.Image.Image.point` method.\n\nWhen converting from \"RGBA\" to \"P\" without a ``matrix`` argument,\nthis passes the operation to :py:meth:`~PIL.Image.Image.quantize`,\nand ``dither`` and ``palette`` are ignored.\n\nWhen converting from \"PA\", if an \"RGBA\" palette is present, the alpha\nchannel from the image will be used instead of the values from the palette.\n\n:param mode: The requested mode. See: :ref:`concept-modes`.\n:param matrix: An optional conversion matrix.  If given, this\n   should be 4- or 12-tuple containing floating point values.\n:param dither: Dithering method, used when converting from\n   mode \"RGB\" to \"P\" or from \"RGB\" or \"L\" to \"1\".\n   Available methods are :data:`Dither.NONE` or :data:`Dither.FLOYDSTEINBERG`\n   (default). Note that this is not used when ``matrix`` is supplied.\n:param palette: Palette to use when converting from mode \"RGB\"\n   to \"P\".  Available palettes are :data:`Palette.WEB` or\n   :data:`Palette.ADAPTIVE`.\n:param colors: Number of colors to use for the :data:`Palette.ADAPTIVE`\n   palette. Defaults to 256.\n:rtype: :py:class:`~PIL.Image.Image`\n:returns: An :py:class:`~PIL.Image.Image` object."
    },
    {
      "name": "quantize",
      "docstring": "Convert the image to 'P' mode with the specified number\nof colors.\n\n:param colors: The desired number of colors, <= 256\n:param method: :data:`Quantize.MEDIANCUT` (median cut),\n               :data:`Quantize.MAXCOVERAGE` (maximum coverage),\n               :data:`Quantize.FASTOCTREE` (fast octree),\n               :data:`Quantize.LIBIMAGEQUANT` (libimagequant; check support\n               using :py:func:`PIL.features.check_feature` with\n               ``feature=\"libimagequant\"``).\n\n               By default, :data:`Quantize.MEDIANCUT` will be used.\n\n               The exception to this is RGBA images. :data:`Quantize.MEDIANCUT`\n               and :data:`Quantize.MAXCOVERAGE` do not support RGBA images, so\n               :data:`Quantize.FASTOCTREE` is used by default instead.\n:param kmeans: Integer greater than or equal to zero.\n:param palette: Quantize to the palette of given\n                :py:class:`PIL.Image.Image`.\n:param dither: Dithering method, used when converting from\n   mode \"RGB\" to \"P\" or from \"RGB\" or \"L\" to \"1\".\n   Available methods are :data:`Dither.NONE` or :data:`Dither.FLOYDSTEINBERG`\n   (default).\n:returns: A new image"
    },
    {
      "name": "copy",
      "docstring": "Copies this image. Use this method if you wish to paste things\ninto an image, but still retain the original.\n\n:rtype: :py:class:`~PIL.Image.Image`\n:returns: An :py:class:`~PIL.Image.Image` object."
    },
    {
      "name": "crop",
      "docstring": "Returns a rectangular region from this image. The box is a\n4-tuple defining the left, upper, right, and lower pixel\ncoordinate. See :ref:`coordinate-system`.\n\nNote: Prior to Pillow 3.4.0, this was a lazy operation.\n\n:param box: The crop rectangle, as a (left, upper, right, lower)-tuple.\n:rtype: :py:class:`~PIL.Image.Image`\n:returns: An :py:class:`~PIL.Image.Image` object."
    },
    {
      "name": "draft",
      "docstring": "Configures the image file loader so it returns a version of the\nimage that as closely as possible matches the given mode and\nsize. For example, you can use this method to convert a color\nJPEG to grayscale while loading it.\n\nIf any changes are made, returns a tuple with the chosen ``mode`` and\n``box`` with coordinates of the original image within the altered one.\n\nNote that this method modifies the :py:class:`~PIL.Image.Image` object\nin place. If the image has already been loaded, this method has no\neffect.\n\nNote: This method is not implemented for most images. It is\ncurrently implemented only for JPEG and MPO images.\n\n:param mode: The requested mode.\n:param size: The requested size in pixels, as a 2-tuple:\n   (width, height)."
    },
    {
      "name": "filter",
      "docstring": "Filters this image using the given filter.  For a list of\navailable filters, see the :py:mod:`~PIL.ImageFilter` module.\n\n:param filter: Filter kernel.\n:returns: An :py:class:`~PIL.Image.Image` object."
    },
    {
      "name": "getbands",
      "docstring": "Returns a tuple containing the name of each band in this image.\nFor example, ``getbands`` on an RGB image returns (\"R\", \"G\", \"B\").\n\n:returns: A tuple containing band names.\n:rtype: tuple"
    },
    {
      "name": "getbbox",
      "docstring": "Calculates the bounding box of the non-zero regions in the\nimage.\n\n:param alpha_only: Optional flag, defaulting to ``True``.\n   If ``True`` and the image has an alpha channel, trim transparent pixels.\n   Otherwise, trim pixels when all channels are zero.\n   Keyword-only argument.\n:returns: The bounding box is returned as a 4-tuple defining the\n   left, upper, right, and lower pixel coordinate. See\n   :ref:`coordinate-system`. If the image is completely empty, this\n   method returns None."
    },
    {
      "name": "getcolors",
      "docstring": "Returns a list of colors used in this image.\n\nThe colors will be in the image's mode. For example, an RGB image will\nreturn a tuple of (red, green, blue) color values, and a P image will\nreturn the index of the color in the palette.\n\n:param maxcolors: Maximum number of colors.  If this number is\n   exceeded, this method returns None.  The default limit is\n   256 colors.\n:returns: An unsorted list of (count, pixel) values."
    },
    {
      "name": "getdata",
      "docstring": "Returns the contents of this image as a sequence object\ncontaining pixel values.  The sequence object is flattened, so\nthat values for line one follow directly after the values of\nline zero, and so on.\n\nNote that the sequence object returned by this method is an\ninternal PIL data type, which only supports certain sequence\noperations.  To convert it to an ordinary sequence (e.g. for\nprinting), use ``list(im.getdata())``.\n\n:param band: What band to return.  The default is to return\n   all bands.  To return a single band, pass in the index\n   value (e.g. 0 to get the \"R\" band from an \"RGB\" image).\n:returns: A sequence-like object."
    },
    {
      "name": "getextrema",
      "docstring": "Gets the minimum and maximum pixel values for each band in\nthe image.\n\n:returns: For a single-band image, a 2-tuple containing the\n   minimum and maximum pixel value.  For a multi-band image,\n   a tuple containing one 2-tuple for each band."
    },
    {
      "name": "getxmp",
      "docstring": "Returns a dictionary containing the XMP tags.\nRequires defusedxml to be installed.\n\n:returns: XMP tags in a dictionary."
    },
    {
      "name": "getexif",
      "docstring": "Gets EXIF data from the image.\n\n:returns: an :py:class:`~PIL.Image.Exif` object."
    },
    {
      "name": "get_child_images",
      "docstring": null
    },
    {
      "name": "getim",
      "docstring": "Returns a capsule that points to the internal image memory.\n\n:returns: A capsule object."
    },
    {
      "name": "getpalette",
      "docstring": "Returns the image palette as a list.\n\n:param rawmode: The mode in which to return the palette. ``None`` will\n   return the palette in its current mode.\n\n   .. versionadded:: 9.1.0\n\n:returns: A list of color values [r, g, b, ...], or None if the\n   image has no palette."
    },
    {
      "name": "has_transparency_data",
      "docstring": "Determine if an image has transparency data, whether in the form of an\nalpha channel, a palette with an alpha channel, or a \"transparency\" key\nin the info dictionary.\n\nNote the image might still appear solid, if all of the values shown\nwithin are opaque.\n\n:returns: A boolean."
    },
    {
      "name": "apply_transparency",
      "docstring": "If a P mode image has a \"transparency\" key in the info dictionary,\nremove the key and instead apply the transparency to the palette.\nOtherwise, the image is unchanged."
    },
    {
      "name": "getpixel",
      "docstring": "Returns the pixel value at a given position.\n\n:param xy: The coordinate, given as (x, y). See\n   :ref:`coordinate-system`.\n:returns: The pixel value.  If the image is a multi-layer image,\n   this method returns a tuple."
    },
    {
      "name": "getprojection",
      "docstring": "Get projection to x and y axes\n\n:returns: Two sequences, indicating where there are non-zero\n    pixels along the X-axis and the Y-axis, respectively."
    },
    {
      "name": "histogram",
      "docstring": "Returns a histogram for the image. The histogram is returned as a\nlist of pixel counts, one for each pixel value in the source\nimage. Counts are grouped into 256 bins for each band, even if\nthe image has more than 8 bits per band. If the image has more\nthan one band, the histograms for all bands are concatenated (for\nexample, the histogram for an \"RGB\" image contains 768 values).\n\nA bilevel image (mode \"1\") is treated as a grayscale (\"L\") image\nby this method.\n\nIf a mask is provided, the method returns a histogram for those\nparts of the image where the mask image is non-zero. The mask\nimage must have the same size as the image, and be either a\nbi-level image (mode \"1\") or a grayscale image (\"L\").\n\n:param mask: An optional mask.\n:param extrema: An optional tuple of manually-specified extrema.\n:returns: A list containing pixel counts."
    },
    {
      "name": "entropy",
      "docstring": "Calculates and returns the entropy for the image.\n\nA bilevel image (mode \"1\") is treated as a grayscale (\"L\")\nimage by this method.\n\nIf a mask is provided, the method employs the histogram for\nthose parts of the image where the mask image is non-zero.\nThe mask image must have the same size as the image, and be\neither a bi-level image (mode \"1\") or a grayscale image (\"L\").\n\n:param mask: An optional mask.\n:param extrema: An optional tuple of manually-specified extrema.\n:returns: A float value representing the image entropy"
    },
    {
      "name": "paste",
      "docstring": "Pastes another image into this image. The box argument is either\na 2-tuple giving the upper left corner, a 4-tuple defining the\nleft, upper, right, and lower pixel coordinate, or None (same as\n(0, 0)). See :ref:`coordinate-system`. If a 4-tuple is given, the size\nof the pasted image must match the size of the region.\n\nIf the modes don't match, the pasted image is converted to the mode of\nthis image (see the :py:meth:`~PIL.Image.Image.convert` method for\ndetails).\n\nInstead of an image, the source can be a integer or tuple\ncontaining pixel values.  The method then fills the region\nwith the given color.  When creating RGB images, you can\nalso use color strings as supported by the ImageColor module.\n\nIf a mask is given, this method updates only the regions\nindicated by the mask. You can use either \"1\", \"L\", \"LA\", \"RGBA\"\nor \"RGBa\" images (if present, the alpha band is used as mask).\nWhere the mask is 255, the given image is copied as is.  Where\nthe mask is 0, the current value is preserved.  Intermediate\nvalues will mix the two images together, including their alpha\nchannels if they have them.\n\nSee :py:meth:`~PIL.Image.Image.alpha_composite` if you want to\ncombine images with respect to their alpha channels.\n\n:param im: Source image or pixel value (integer, float or tuple).\n:param box: An optional 4-tuple giving the region to paste into.\n   If a 2-tuple is used instead, it's treated as the upper left\n   corner.  If omitted or None, the source is pasted into the\n   upper left corner.\n\n   If an image is given as the second argument and there is no\n   third, the box defaults to (0, 0), and the second argument\n   is interpreted as a mask image.\n:param mask: An optional mask image."
    },
    {
      "name": "alpha_composite",
      "docstring": "'In-place' analog of Image.alpha_composite. Composites an image\nonto this image.\n\n:param im: image to composite over this one\n:param dest: Optional 2 tuple (left, top) specifying the upper\n  left corner in this (destination) image.\n:param source: Optional 2 (left, top) tuple for the upper left\n  corner in the overlay source image, or 4 tuple (left, top, right,\n  bottom) for the bounds of the source rectangle\n\nPerformance Note: Not currently implemented in-place in the core layer."
    },
    {
      "name": "point",
      "docstring": "Maps this image through a lookup table or function.\n\n:param lut: A lookup table, containing 256 (or 65536 if\n   self.mode==\"I\" and mode == \"L\") values per band in the\n   image.  A function can be used instead, it should take a\n   single argument. The function is called once for each\n   possible pixel value, and the resulting table is applied to\n   all bands of the image.\n\n   It may also be an :py:class:`~PIL.Image.ImagePointHandler`\n   object::\n\n       class Example(Image.ImagePointHandler):\n         def point(self, im: Image) -> Image:\n           # Return result\n:param mode: Output mode (default is same as input). This can only be used if\n   the source image has mode \"L\" or \"P\", and the output has mode \"1\" or the\n   source image mode is \"I\" and the output mode is \"L\".\n:returns: An :py:class:`~PIL.Image.Image` object."
    },
    {
      "name": "putalpha",
      "docstring": "Adds or replaces the alpha layer in this image.  If the image\ndoes not have an alpha layer, it's converted to \"LA\" or \"RGBA\".\nThe new layer must be either \"L\" or \"1\".\n\n:param alpha: The new alpha layer.  This can either be an \"L\" or \"1\"\n   image having the same size as this image, or an integer."
    },
    {
      "name": "putdata",
      "docstring": "Copies pixel data from a flattened sequence object into the image. The\nvalues should start at the upper left corner (0, 0), continue to the\nend of the line, followed directly by the first value of the second\nline, and so on. Data will be read until either the image or the\nsequence ends. The scale and offset values are used to adjust the\nsequence values: **pixel = value*scale + offset**.\n\n:param data: A flattened sequence object.\n:param scale: An optional scale value.  The default is 1.0.\n:param offset: An optional offset value.  The default is 0.0."
    },
    {
      "name": "putpalette",
      "docstring": "Attaches a palette to this image.  The image must be a \"P\", \"PA\", \"L\"\nor \"LA\" image.\n\nThe palette sequence must contain at most 256 colors, made up of one\ninteger value for each channel in the raw mode.\nFor example, if the raw mode is \"RGB\", then it can contain at most 768\nvalues, made up of red, green and blue values for the corresponding pixel\nindex in the 256 colors.\nIf the raw mode is \"RGBA\", then it can contain at most 1024 values,\ncontaining red, green, blue and alpha values.\n\nAlternatively, an 8-bit string may be used instead of an integer sequence.\n\n:param data: A palette sequence (either a list or a string).\n:param rawmode: The raw mode of the palette. Either \"RGB\", \"RGBA\", or a mode\n   that can be transformed to \"RGB\" or \"RGBA\" (e.g. \"R\", \"BGR;15\", \"RGBA;L\")."
    },
    {
      "name": "putpixel",
      "docstring": "Modifies the pixel at the given position. The color is given as\na single numerical value for single-band images, and a tuple for\nmulti-band images. In addition to this, RGB and RGBA tuples are\naccepted for P and PA images.\n\nNote that this method is relatively slow.  For more extensive changes,\nuse :py:meth:`~PIL.Image.Image.paste` or the :py:mod:`~PIL.ImageDraw`\nmodule instead.\n\nSee:\n\n* :py:meth:`~PIL.Image.Image.paste`\n* :py:meth:`~PIL.Image.Image.putdata`\n* :py:mod:`~PIL.ImageDraw`\n\n:param xy: The pixel coordinate, given as (x, y). See\n   :ref:`coordinate-system`.\n:param value: The pixel value."
    },
    {
      "name": "remap_palette",
      "docstring": "Rewrites the image to reorder the palette.\n\n:param dest_map: A list of indexes into the original palette.\n   e.g. ``[1,0]`` would swap a two item palette, and ``list(range(256))``\n   is the identity transform.\n:param source_palette: Bytes or None.\n:returns:  An :py:class:`~PIL.Image.Image` object."
    },
    {
      "name": "resize",
      "docstring": "Returns a resized copy of this image.\n\n:param size: The requested size in pixels, as a tuple or array:\n   (width, height).\n:param resample: An optional resampling filter.  This can be\n   one of :py:data:`Resampling.NEAREST`, :py:data:`Resampling.BOX`,\n   :py:data:`Resampling.BILINEAR`, :py:data:`Resampling.HAMMING`,\n   :py:data:`Resampling.BICUBIC` or :py:data:`Resampling.LANCZOS`.\n   If the image has mode \"1\" or \"P\", it is always set to\n   :py:data:`Resampling.NEAREST`. If the image mode is \"BGR;15\",\n   \"BGR;16\" or \"BGR;24\", then the default filter is\n   :py:data:`Resampling.NEAREST`. Otherwise, the default filter is\n   :py:data:`Resampling.BICUBIC`. See: :ref:`concept-filters`.\n:param box: An optional 4-tuple of floats providing\n   the source image region to be scaled.\n   The values must be within (0, 0, width, height) rectangle.\n   If omitted or None, the entire source is used.\n:param reducing_gap: Apply optimization by resizing the image\n   in two steps. First, reducing the image by integer times\n   using :py:meth:`~PIL.Image.Image.reduce`.\n   Second, resizing using regular resampling. The last step\n   changes size no less than by ``reducing_gap`` times.\n   ``reducing_gap`` may be None (no first step is performed)\n   or should be greater than 1.0. The bigger ``reducing_gap``,\n   the closer the result to the fair resampling.\n   The smaller ``reducing_gap``, the faster resizing.\n   With ``reducing_gap`` greater or equal to 3.0, the result is\n   indistinguishable from fair resampling in most cases.\n   The default value is None (no optimization).\n:returns: An :py:class:`~PIL.Image.Image` object."
    },
    {
      "name": "reduce",
      "docstring": "Returns a copy of the image reduced ``factor`` times.\nIf the size of the image is not dividable by ``factor``,\nthe resulting size will be rounded up.\n\n:param factor: A greater than 0 integer or tuple of two integers\n   for width and height separately.\n:param box: An optional 4-tuple of ints providing\n   the source image region to be reduced.\n   The values must be within ``(0, 0, width, height)`` rectangle.\n   If omitted or ``None``, the entire source is used."
    },
    {
      "name": "rotate",
      "docstring": "Returns a rotated copy of this image.  This method returns a\ncopy of this image, rotated the given number of degrees counter\nclockwise around its centre.\n\n:param angle: In degrees counter clockwise.\n:param resample: An optional resampling filter.  This can be\n   one of :py:data:`Resampling.NEAREST` (use nearest neighbour),\n   :py:data:`Resampling.BILINEAR` (linear interpolation in a 2x2\n   environment), or :py:data:`Resampling.BICUBIC` (cubic spline\n   interpolation in a 4x4 environment). If omitted, or if the image has\n   mode \"1\" or \"P\", it is set to :py:data:`Resampling.NEAREST`.\n   See :ref:`concept-filters`.\n:param expand: Optional expansion flag.  If true, expands the output\n   image to make it large enough to hold the entire rotated image.\n   If false or omitted, make the output image the same size as the\n   input image.  Note that the expand flag assumes rotation around\n   the center and no translation.\n:param center: Optional center of rotation (a 2-tuple).  Origin is\n   the upper left corner.  Default is the center of the image.\n:param translate: An optional post-rotate translation (a 2-tuple).\n:param fillcolor: An optional color for area outside the rotated image.\n:returns: An :py:class:`~PIL.Image.Image` object."
    },
    {
      "name": "save",
      "docstring": "Saves this image under the given filename.  If no format is\nspecified, the format to use is determined from the filename\nextension, if possible.\n\nKeyword options can be used to provide additional instructions\nto the writer. If a writer doesn't recognise an option, it is\nsilently ignored. The available options are described in the\n:doc:`image format documentation\n<../handbook/image-file-formats>` for each writer.\n\nYou can use a file object instead of a filename. In this case,\nyou must always specify the format. The file object must\nimplement the ``seek``, ``tell``, and ``write``\nmethods, and be opened in binary mode.\n\n:param fp: A filename (string), os.PathLike object or file object.\n:param format: Optional format override.  If omitted, the\n   format to use is determined from the filename extension.\n   If a file object was used instead of a filename, this\n   parameter should always be used.\n:param params: Extra parameters to the image writer. These can also be\n   set on the image itself through ``encoderinfo``. This is useful when\n   saving multiple images::\n\n     # Saving XMP data to a single image\n     from PIL import Image\n     red = Image.new(\"RGB\", (1, 1), \"#f00\")\n     red.save(\"out.mpo\", xmp=b\"test\")\n\n     # Saving XMP data to the second frame of an image\n     from PIL import Image\n     black = Image.new(\"RGB\", (1, 1))\n     red = Image.new(\"RGB\", (1, 1), \"#f00\")\n     red.encoderinfo = {\"xmp\": b\"test\"}\n     black.save(\"out.mpo\", save_all=True, append_images=[red])\n:returns: None\n:exception ValueError: If the output format could not be determined\n   from the file name.  Use the format option to solve this.\n:exception OSError: If the file could not be written.  The file\n   may have been created, and may contain partial data."
    },
    {
      "name": "seek",
      "docstring": "Seeks to the given frame in this sequence file. If you seek\nbeyond the end of the sequence, the method raises an\n``EOFError`` exception. When a sequence file is opened, the\nlibrary automatically seeks to frame 0.\n\nSee :py:meth:`~PIL.Image.Image.tell`.\n\nIf defined, :attr:`~PIL.Image.Image.n_frames` refers to the\nnumber of available frames.\n\n:param frame: Frame number, starting at 0.\n:exception EOFError: If the call attempts to seek beyond the end\n    of the sequence."
    },
    {
      "name": "show",
      "docstring": "Displays this image. This method is mainly intended for debugging purposes.\n\nThis method calls :py:func:`PIL.ImageShow.show` internally. You can use\n:py:func:`PIL.ImageShow.register` to override its default behaviour.\n\nThe image is first saved to a temporary file. By default, it will be in\nPNG format.\n\nOn Unix, the image is then opened using the **xdg-open**, **display**,\n**gm**, **eog** or **xv** utility, depending on which one can be found.\n\nOn macOS, the image is opened with the native Preview application.\n\nOn Windows, the image is opened with the standard PNG display utility.\n\n:param title: Optional title to use for the image window, where possible."
    },
    {
      "name": "split",
      "docstring": "Split this image into individual bands. This method returns a\ntuple of individual image bands from an image. For example,\nsplitting an \"RGB\" image creates three new images each\ncontaining a copy of one of the original bands (red, green,\nblue).\n\nIf you need only one band, :py:meth:`~PIL.Image.Image.getchannel`\nmethod can be more convenient and faster.\n\n:returns: A tuple containing bands."
    },
    {
      "name": "getchannel",
      "docstring": "Returns an image containing a single channel of the source image.\n\n:param channel: What channel to return. Could be index\n  (0 for \"R\" channel of \"RGB\") or channel name\n  (\"A\" for alpha channel of \"RGBA\").\n:returns: An image in \"L\" mode.\n\n.. versionadded:: 4.3.0"
    },
    {
      "name": "tell",
      "docstring": "Returns the current frame number. See :py:meth:`~PIL.Image.Image.seek`.\n\nIf defined, :attr:`~PIL.Image.Image.n_frames` refers to the\nnumber of available frames.\n\n:returns: Frame number, starting with 0."
    },
    {
      "name": "thumbnail",
      "docstring": "Make this image into a thumbnail.  This method modifies the\nimage to contain a thumbnail version of itself, no larger than\nthe given size.  This method calculates an appropriate thumbnail\nsize to preserve the aspect of the image, calls the\n:py:meth:`~PIL.Image.Image.draft` method to configure the file reader\n(where applicable), and finally resizes the image.\n\nNote that this function modifies the :py:class:`~PIL.Image.Image`\nobject in place.  If you need to use the full resolution image as well,\napply this method to a :py:meth:`~PIL.Image.Image.copy` of the original\nimage.\n\n:param size: The requested size in pixels, as a 2-tuple:\n   (width, height).\n:param resample: Optional resampling filter.  This can be one\n   of :py:data:`Resampling.NEAREST`, :py:data:`Resampling.BOX`,\n   :py:data:`Resampling.BILINEAR`, :py:data:`Resampling.HAMMING`,\n   :py:data:`Resampling.BICUBIC` or :py:data:`Resampling.LANCZOS`.\n   If omitted, it defaults to :py:data:`Resampling.BICUBIC`.\n   (was :py:data:`Resampling.NEAREST` prior to version 2.5.0).\n   See: :ref:`concept-filters`.\n:param reducing_gap: Apply optimization by resizing the image\n   in two steps. First, reducing the image by integer times\n   using :py:meth:`~PIL.Image.Image.reduce` or\n   :py:meth:`~PIL.Image.Image.draft` for JPEG images.\n   Second, resizing using regular resampling. The last step\n   changes size no less than by ``reducing_gap`` times.\n   ``reducing_gap`` may be None (no first step is performed)\n   or should be greater than 1.0. The bigger ``reducing_gap``,\n   the closer the result to the fair resampling.\n   The smaller ``reducing_gap``, the faster resizing.\n   With ``reducing_gap`` greater or equal to 3.0, the result is\n   indistinguishable from fair resampling in most cases.\n   The default value is 2.0 (very close to fair resampling\n   while still being faster in many cases).\n:returns: None"
    },
    {
      "name": "transform",
      "docstring": "Transforms this image.  This method creates a new image with the\ngiven size, and the same mode as the original, and copies data\nto the new image using the given transform.\n\n:param size: The output size in pixels, as a 2-tuple:\n   (width, height).\n:param method: The transformation method.  This is one of\n  :py:data:`Transform.EXTENT` (cut out a rectangular subregion),\n  :py:data:`Transform.AFFINE` (affine transform),\n  :py:data:`Transform.PERSPECTIVE` (perspective transform),\n  :py:data:`Transform.QUAD` (map a quadrilateral to a rectangle), or\n  :py:data:`Transform.MESH` (map a number of source quadrilaterals\n  in one operation).\n\n  It may also be an :py:class:`~PIL.Image.ImageTransformHandler`\n  object::\n\n    class Example(Image.ImageTransformHandler):\n        def transform(self, size, data, resample, fill=1):\n            # Return result\n\n  Implementations of :py:class:`~PIL.Image.ImageTransformHandler`\n  for some of the :py:class:`Transform` methods are provided\n  in :py:mod:`~PIL.ImageTransform`.\n\n  It may also be an object with a ``method.getdata`` method\n  that returns a tuple supplying new ``method`` and ``data`` values::\n\n    class Example:\n        def getdata(self):\n            method = Image.Transform.EXTENT\n            data = (0, 0, 100, 100)\n            return method, data\n:param data: Extra data to the transformation method.\n:param resample: Optional resampling filter.  It can be one of\n   :py:data:`Resampling.NEAREST` (use nearest neighbour),\n   :py:data:`Resampling.BILINEAR` (linear interpolation in a 2x2\n   environment), or :py:data:`Resampling.BICUBIC` (cubic spline\n   interpolation in a 4x4 environment). If omitted, or if the image\n   has mode \"1\" or \"P\", it is set to :py:data:`Resampling.NEAREST`.\n   See: :ref:`concept-filters`.\n:param fill: If ``method`` is an\n  :py:class:`~PIL.Image.ImageTransformHandler` object, this is one of\n  the arguments passed to it. Otherwise, it is unused.\n:param fillcolor: Optional fill color for the area outside the\n   transform in the output image.\n:returns: An :py:class:`~PIL.Image.Image` object."
    },
    {
      "name": "transpose",
      "docstring": "Transpose image (flip or rotate in 90 degree steps)\n\n:param method: One of :py:data:`Transpose.FLIP_LEFT_RIGHT`,\n  :py:data:`Transpose.FLIP_TOP_BOTTOM`, :py:data:`Transpose.ROTATE_90`,\n  :py:data:`Transpose.ROTATE_180`, :py:data:`Transpose.ROTATE_270`,\n  :py:data:`Transpose.TRANSPOSE` or :py:data:`Transpose.TRANSVERSE`.\n:returns: Returns a flipped or rotated copy of this image."
    },
    {
      "name": "effect_spread",
      "docstring": "Randomly spread pixels in an image.\n\n:param distance: Distance to spread pixels."
    },
    {
      "name": "toqimage",
      "docstring": "Returns a QImage copy of this image"
    },
    {
      "name": "toqpixmap",
      "docstring": "Returns a QPixmap copy of this image"
    },
    {
      "name": "point",
      "docstring": null
    },
    {
      "name": "transform",
      "docstring": null
    },
    {
      "name": "load",
      "docstring": null
    },
    {
      "name": "load_from_fp",
      "docstring": null
    },
    {
      "name": "tobytes",
      "docstring": null
    },
    {
      "name": "get_ifd",
      "docstring": null
    },
    {
      "name": "hide_offsets",
      "docstring": null
    },
    {
      "name": "get_name",
      "docstring": null
    },
    {
      "name": "get_value",
      "docstring": null
    },
    {
      "name": "transform",
      "docstring": null
    },
    {
      "name": "preserve_aspect_ratio",
      "docstring": null
    },
    {
      "name": "round_aspect",
      "docstring": null
    },
    {
      "name": "convert_transparency",
      "docstring": null
    }
  ],
  "innovations": [
    {
      "type": "potential_innovation",
      "marker": "optimization",
      "context": "        # assigning the optimized RGB palette.\n\n        # perf reference, 9500x4000 gif, w/~135 colors\n        # 14 sec prepatch, 1 sec postpatch with optimization forced.\n\n        mapping_palette = bytearray(new_positions)\n"
    }
  ]
}