{
  "file_path": "c:\\Users\\sgbil\\OneDrive\\Desktop\\Negative_Space_Imaging_Project\\.venv\\Lib\\site-packages\\matplotlib\\streamplot.py",
  "classes": [
    {
      "name": "StreamplotSet",
      "docstring": null,
      "methods": [
        {
          "name": "__init__",
          "docstring": null
        }
      ]
    },
    {
      "name": "DomainMap",
      "docstring": "Map representing different coordinate systems.\n\nCoordinate definitions:\n\n* axes-coordinates goes from 0 to 1 in the domain.\n* data-coordinates are specified by the input x-y coordinates.\n* grid-coordinates goes from 0 to N and 0 to M for an N x M grid,\n  where N and M match the shape of the input data.\n* mask-coordinates goes from 0 to N and 0 to M for an N x M mask,\n  where N and M are user-specified to control the density of streamlines.\n\nThis class also has methods for adding trajectories to the StreamMask.\nBefore adding a trajectory, run `start_trajectory` to keep track of regions\ncrossed by a given trajectory. Later, if you decide the trajectory is bad\n(e.g., if the trajectory is very short) just call `undo_trajectory`.",
      "methods": [
        {
          "name": "__init__",
          "docstring": null
        },
        {
          "name": "grid2mask",
          "docstring": "Return nearest space in mask-coords from given grid-coords."
        },
        {
          "name": "mask2grid",
          "docstring": null
        },
        {
          "name": "data2grid",
          "docstring": null
        },
        {
          "name": "grid2data",
          "docstring": null
        },
        {
          "name": "start_trajectory",
          "docstring": null
        },
        {
          "name": "reset_start_point",
          "docstring": null
        },
        {
          "name": "update_trajectory",
          "docstring": null
        },
        {
          "name": "undo_trajectory",
          "docstring": null
        }
      ]
    },
    {
      "name": "Grid",
      "docstring": "Grid of data.",
      "methods": [
        {
          "name": "__init__",
          "docstring": null
        },
        {
          "name": "shape",
          "docstring": null
        },
        {
          "name": "within_grid",
          "docstring": "Return whether (*xi*, *yi*) is a valid index of the grid."
        }
      ]
    },
    {
      "name": "StreamMask",
      "docstring": "Mask to keep track of discrete regions crossed by streamlines.\n\nThe resolution of this grid determines the approximate spacing between\ntrajectories. Streamlines are only allowed to pass through zeroed cells:\nWhen a streamline enters a cell, that cell is set to 1, and no new\nstreamlines are allowed to enter.",
      "methods": [
        {
          "name": "__init__",
          "docstring": null
        }
      ]
    },
    {
      "name": "InvalidIndexError",
      "docstring": null,
      "methods": []
    },
    {
      "name": "TerminateTrajectory",
      "docstring": null,
      "methods": []
    },
    {
      "name": "OutOfBounds",
      "docstring": null,
      "methods": []
    }
  ],
  "functions": [
    {
      "name": "streamplot",
      "docstring": "Draw streamlines of a vector flow.\n\nParameters\n----------\nx, y : 1D/2D arrays\n    Evenly spaced strictly increasing arrays to make a grid.  If 2D, all\n    rows of *x* must be equal and all columns of *y* must be equal; i.e.,\n    they must be as if generated by ``np.meshgrid(x_1d, y_1d)``.\nu, v : 2D arrays\n    *x* and *y*-velocities. The number of rows and columns must match\n    the length of *y* and *x*, respectively.\ndensity : float or (float, float)\n    Controls the closeness of streamlines. When ``density = 1``, the domain\n    is divided into a 30x30 grid. *density* linearly scales this grid.\n    Each cell in the grid can have, at most, one traversing streamline.\n    For different densities in each direction, use a tuple\n    (density_x, density_y).\nlinewidth : float or 2D array\n    The width of the streamlines. With a 2D array the line width can be\n    varied across the grid. The array must have the same shape as *u*\n    and *v*.\ncolor : :mpltype:`color` or 2D array\n    The streamline color. If given an array, its values are converted to\n    colors using *cmap* and *norm*.  The array must have the same shape\n    as *u* and *v*.\ncmap, norm\n    Data normalization and colormapping parameters for *color*; only used\n    if *color* is an array of floats. See `~.Axes.imshow` for a detailed\n    description.\narrowsize : float\n    Scaling factor for the arrow size.\narrowstyle : str\n    Arrow style specification.\n    See `~matplotlib.patches.FancyArrowPatch`.\nminlength : float\n    Minimum length of streamline in axes coordinates.\nstart_points : (N, 2) array\n    Coordinates of starting points for the streamlines in data coordinates\n    (the same coordinates as the *x* and *y* arrays).\nzorder : float\n    The zorder of the streamlines and arrows.\n    Artists with lower zorder values are drawn first.\nmaxlength : float\n    Maximum length of streamline in axes coordinates.\nintegration_direction : {'forward', 'backward', 'both'}, default: 'both'\n    Integrate the streamline in forward, backward or both directions.\ndata : indexable object, optional\n    DATA_PARAMETER_PLACEHOLDER\nbroken_streamlines : boolean, default: True\n    If False, forces streamlines to continue until they\n    leave the plot domain.  If True, they may be terminated if they\n    come too close to another streamline.\n\nReturns\n-------\nStreamplotSet\n    Container object with attributes\n\n    - ``lines``: `.LineCollection` of streamlines\n\n    - ``arrows``: `.PatchCollection` containing `.FancyArrowPatch`\n      objects representing the arrows half-way along streamlines.\n\n    This container will probably change in the future to allow changes\n    to the colormap, alpha, etc. for both lines and arrows, but these\n    changes should be backward compatible."
    },
    {
      "name": "interpgrid",
      "docstring": "Fast 2D, linear interpolation on an integer grid"
    },
    {
      "name": "grid2mask",
      "docstring": "Return nearest space in mask-coords from given grid-coords."
    },
    {
      "name": "mask2grid",
      "docstring": null
    },
    {
      "name": "data2grid",
      "docstring": null
    },
    {
      "name": "grid2data",
      "docstring": null
    },
    {
      "name": "start_trajectory",
      "docstring": null
    },
    {
      "name": "reset_start_point",
      "docstring": null
    },
    {
      "name": "update_trajectory",
      "docstring": null
    },
    {
      "name": "undo_trajectory",
      "docstring": null
    },
    {
      "name": "shape",
      "docstring": null
    },
    {
      "name": "within_grid",
      "docstring": "Return whether (*xi*, *yi*) is a valid index of the grid."
    },
    {
      "name": "forward_time",
      "docstring": null
    },
    {
      "name": "backward_time",
      "docstring": null
    },
    {
      "name": "integrate",
      "docstring": "Return x, y grid-coordinates of trajectory based on starting point.\n\nIntegrate both forward and backward in time from starting point in\ngrid coordinates.\n\nIntegration is terminated when a trajectory reaches a domain boundary\nor when it crosses into an already occupied cell in the StreamMask. The\nresulting trajectory is None if it is shorter than `minlength`."
    }
  ],
  "innovations": []
}