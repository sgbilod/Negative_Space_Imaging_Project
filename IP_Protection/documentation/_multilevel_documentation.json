{
  "file_path": "c:\\Users\\sgbil\\OneDrive\\Desktop\\Negative_Space_Imaging_Project\\.venv\\Lib\\site-packages\\pywt\\_multilevel.py",
  "classes": [
    {
      "name": "FswavedecnResult",
      "docstring": "Object representing fully separable wavelet transform coefficients.\n\nParameters\n----------\ncoeffs : ndarray\n    The coefficient array.\ncoeff_slices : list\n    List of slices corresponding to each detail or approximation\n    coefficient array.\nwavelets : list of pywt.DiscreteWavelet objects\n    The wavelets used.  Will be a list with length equal to\n    ``len(axes)``.\nmode_enums : list of int\n    The border modes used.  Will be a list with length equal to\n    ``len(axes)``.\naxes : tuple of int\n    The set of axes over which the transform was performed.",
      "methods": [
        {
          "name": "__init__",
          "docstring": null
        },
        {
          "name": "coeffs",
          "docstring": "ndarray: All coefficients stacked into a single array."
        },
        {
          "name": "coeffs",
          "docstring": null
        },
        {
          "name": "coeff_slices",
          "docstring": "List: List of coefficient slices."
        },
        {
          "name": "ndim",
          "docstring": "int: Number of data dimensions."
        },
        {
          "name": "ndim_transform",
          "docstring": "int: Number of axes transformed."
        },
        {
          "name": "axes",
          "docstring": "List of str: The axes the transform was performed along."
        },
        {
          "name": "levels",
          "docstring": "List of int: Levels of decomposition along each transformed axis."
        },
        {
          "name": "wavelets",
          "docstring": "List of pywt.DiscreteWavelet: wavelet for each transformed axis."
        },
        {
          "name": "wavelet_names",
          "docstring": "List of pywt.DiscreteWavelet: wavelet for each transformed axis."
        },
        {
          "name": "modes",
          "docstring": "List of str: The border mode used along each transformed axis."
        },
        {
          "name": "approx",
          "docstring": "ndarray: The approximation coefficients."
        },
        {
          "name": "approx",
          "docstring": null
        },
        {
          "name": "detail_keys",
          "docstring": "Return a list of all detail coefficient keys.\n\nReturns\n-------\nkeys : list of str\n    List of all detail coefficient keys."
        }
      ]
    }
  ],
  "functions": [
    {
      "name": "wavedec",
      "docstring": "Multilevel 1D Discrete Wavelet Transform of data.\n\nParameters\n----------\ndata: array_like\n    Input data\nwavelet : Wavelet object or name string\n    Wavelet to use\nmode : str, optional\n    Signal extension mode, see :ref:`Modes <ref-modes>`.\nlevel : int, optional\n    Decomposition level (must be >= 0). If level is None (default) then it\n    will be calculated using the ``dwt_max_level`` function.\naxis: int, optional\n    Axis over which to compute the DWT. If not given, the\n    last axis is used.\n\nReturns\n-------\n[cA_n, cD_n, cD_n-1, ..., cD2, cD1] : list\n    Ordered list of coefficients arrays\n    where ``n`` denotes the level of decomposition. The first element\n    (``cA_n``) of the result is approximation coefficients array and the\n    following elements (``cD_n`` - ``cD_1``) are details coefficients\n    arrays.\n\nExamples\n--------\n>>> from pywt import wavedec\n>>> coeffs = wavedec([1,2,3,4,5,6,7,8], 'db1', level=2)\n>>> cA2, cD2, cD1 = coeffs\n>>> cD1\narray([-0.70710678, -0.70710678, -0.70710678, -0.70710678])\n>>> cD2\narray([-2., -2.])\n>>> cA2\narray([  5.,  13.])"
    },
    {
      "name": "waverec",
      "docstring": "Multilevel 1D Inverse Discrete Wavelet Transform.\n\nParameters\n----------\ncoeffs : array_like\n    Coefficients list [cAn, cDn, cDn-1, ..., cD2, cD1]\nwavelet : Wavelet object or name string\n    Wavelet to use\nmode : str, optional\n    Signal extension mode, see :ref:`Modes <ref-modes>`.\naxis: int, optional\n    Axis over which to compute the inverse DWT. If not given, the\n    last axis is used.\n\nNotes\n-----\nIt may sometimes be desired to run ``waverec`` with some sets of\ncoefficients omitted.  This can best be done by setting the corresponding\narrays to zero arrays of matching shape and dtype.  Explicitly removing\nlist entries or setting them to None is not supported.\n\nSpecifically, to ignore detail coefficients at level 2, one could do::\n\n    coeffs[-2] = np.zeros_like(coeffs[-2])\n\nExamples\n--------\n>>> import pywt\n>>> coeffs = pywt.wavedec([1,2,3,4,5,6,7,8], 'db1', level=2)\n>>> pywt.waverec(coeffs, 'db1')\narray([ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.])"
    },
    {
      "name": "wavedec2",
      "docstring": "Multilevel 2D Discrete Wavelet Transform.\n\nParameters\n----------\ndata : ndarray\n    2D input data\nwavelet : Wavelet object or name string, or 2-tuple of wavelets\n    Wavelet to use.  This can also be a tuple containing a wavelet to\n    apply along each axis in ``axes``.\nmode : str or 2-tuple of str, optional\n    Signal extension mode, see :ref:`Modes <ref-modes>`. This can\n    also be a tuple containing a mode to apply along each axis in ``axes``.\nlevel : int, optional\n    Decomposition level (must be >= 0). If level is None (default) then it\n    will be calculated using the ``dwt_max_level`` function.\naxes : 2-tuple of ints, optional\n    Axes over which to compute the DWT. Repeated elements are not allowed.\n\nReturns\n-------\n[cAn, (cHn, cVn, cDn), ... (cH1, cV1, cD1)] : list\n    Coefficients list.  For user-specified ``axes``, ``cH*``\n    corresponds to ``axes[0]`` while ``cV*`` corresponds to ``axes[1]``.\n    The first element returned is the approximation coefficients for the\n    nth level of decomposition.  Remaining elements are tuples of detail\n    coefficients in descending order of decomposition level.\n    (i.e. ``cH1`` are the horizontal detail coefficients at the first\n    level)\n\nExamples\n--------\n>>> import pywt\n>>> import numpy as np\n>>> coeffs = pywt.wavedec2(np.ones((4,4)), 'db1')\n>>> # Levels:\n>>> len(coeffs)-1\n2\n>>> pywt.waverec2(coeffs, 'db1')\narray([[ 1.,  1.,  1.,  1.],\n       [ 1.,  1.,  1.,  1.],\n       [ 1.,  1.,  1.,  1.],\n       [ 1.,  1.,  1.,  1.]])"
    },
    {
      "name": "waverec2",
      "docstring": "Multilevel 2D Inverse Discrete Wavelet Transform.\n\ncoeffs : list or tuple\n    Coefficients list [cAn, (cHn, cVn, cDn), ... (cH1, cV1, cD1)]\nwavelet : Wavelet object or name string, or 2-tuple of wavelets\n    Wavelet to use.  This can also be a tuple containing a wavelet to\n    apply along each axis in ``axes``.\nmode : str or 2-tuple of str, optional\n    Signal extension mode, see :ref:`Modes <ref-modes>`. This can\n    also be a tuple containing a mode to apply along each axis in ``axes``.\naxes : 2-tuple of ints, optional\n    Axes over which to compute the IDWT. Repeated elements are not allowed.\n\nReturns\n-------\n2D array of reconstructed data.\n\nNotes\n-----\nIt may sometimes be desired to run ``waverec2`` with some sets of\ncoefficients omitted.  This can best be done by setting the corresponding\narrays to zero arrays of matching shape and dtype.  Explicitly removing\nlist or tuple entries or setting them to None is not supported.\n\nSpecifically, to ignore all detail coefficients at level 2, one could do::\n\n    coeffs[-2] == tuple([np.zeros_like(v) for v in coeffs[-2]])\n\nExamples\n--------\n>>> import pywt\n>>> import numpy as np\n>>> coeffs = pywt.wavedec2(np.ones((4,4)), 'db1')\n>>> # Levels:\n>>> len(coeffs)-1\n2\n>>> pywt.waverec2(coeffs, 'db1')\narray([[ 1.,  1.,  1.,  1.],\n       [ 1.,  1.,  1.,  1.],\n       [ 1.,  1.,  1.,  1.],\n       [ 1.,  1.,  1.,  1.]])"
    },
    {
      "name": "wavedecn",
      "docstring": "Multilevel nD Discrete Wavelet Transform.\n\nParameters\n----------\ndata : ndarray\n    nD input data\nwavelet : Wavelet object or name string, or tuple of wavelets\n    Wavelet to use.  This can also be a tuple containing a wavelet to\n    apply along each axis in ``axes``.\nmode : str or tuple of str, optional\n    Signal extension mode, see :ref:`Modes <ref-modes>`. This can\n    also be a tuple containing a mode to apply along each axis in ``axes``.\nlevel : int, optional\n    Decomposition level (must be >= 0). If level is None (default) then it\n    will be calculated using the ``dwt_max_level`` function.\naxes : sequence of ints, optional\n    Axes over which to compute the DWT. Axes may not be repeated. The\n    default is None, which means transform all axes\n    (``axes = range(data.ndim)``).\n\nReturns\n-------\n[cAn, {details_level_n}, ... {details_level_1}] : list\n    Coefficients list.  Coefficients are listed in descending order of\n    decomposition level.  ``cAn`` are the approximation coefficients at\n    level ``n``.  Each ``details_level_i`` element is a dictionary\n    containing detail coefficients at level ``i`` of the decomposition. As\n    a concrete example, a 3D decomposition would have the following set of\n    keys in each ``details_level_i`` dictionary::\n\n        {'aad', 'ada', 'daa', 'add', 'dad', 'dda', 'ddd'}\n\n    where the order of the characters in each key map to the specified\n    ``axes``.\n\nExamples\n--------\n>>> import numpy as np\n>>> from pywt import wavedecn, waverecn\n>>> coeffs = wavedecn(np.ones((4, 4, 4)), 'db1')\n>>> # Levels:\n>>> len(coeffs)-1\n2\n>>> waverecn(coeffs, 'db1')\narray([[[ 1.,  1.,  1.,  1.],\n        [ 1.,  1.,  1.,  1.],\n        [ 1.,  1.,  1.,  1.],\n        [ 1.,  1.,  1.,  1.]],\n       [[ 1.,  1.,  1.,  1.],\n        [ 1.,  1.,  1.,  1.],\n        [ 1.,  1.,  1.,  1.],\n        [ 1.,  1.,  1.,  1.]],\n       [[ 1.,  1.,  1.,  1.],\n        [ 1.,  1.,  1.,  1.],\n        [ 1.,  1.,  1.,  1.],\n        [ 1.,  1.,  1.,  1.]],\n       [[ 1.,  1.,  1.,  1.],\n        [ 1.,  1.,  1.,  1.],\n        [ 1.,  1.,  1.,  1.],\n        [ 1.,  1.,  1.,  1.]]])"
    },
    {
      "name": "waverecn",
      "docstring": "Multilevel nD Inverse Discrete Wavelet Transform.\n\ncoeffs : array_like\n    Coefficients list [cAn, {details_level_n}, ... {details_level_1}]\nwavelet : Wavelet object or name string, or tuple of wavelets\n    Wavelet to use.  This can also be a tuple containing a wavelet to\n    apply along each axis in ``axes``.\nmode : str or tuple of str, optional\n    Signal extension mode, see :ref:`Modes <ref-modes>`. This can\n    also be a tuple containing a mode to apply along each axis in ``axes``.\naxes : sequence of ints, optional\n    Axes over which to compute the IDWT.  Axes may not be repeated.\n\nReturns\n-------\nnD array of reconstructed data.\n\nNotes\n-----\nIt may sometimes be desired to run ``waverecn`` with some sets of\ncoefficients omitted.  This can best be done by setting the corresponding\narrays to zero arrays of matching shape and dtype.  Explicitly removing\nlist or dictionary entries or setting them to None is not supported.\n\nSpecifically, to ignore all detail coefficients at level 2, one could do::\n\n    coeffs[-2] = {k: np.zeros_like(v) for k, v in coeffs[-2].items()}\n\nExamples\n--------\n>>> import numpy as np\n>>> from pywt import wavedecn, waverecn\n>>> coeffs = wavedecn(np.ones((4, 4, 4)), 'db1')\n>>> # Levels:\n>>> len(coeffs)-1\n2\n>>> waverecn(coeffs, 'db1')\narray([[[ 1.,  1.,  1.,  1.],\n        [ 1.,  1.,  1.,  1.],\n        [ 1.,  1.,  1.,  1.],\n        [ 1.,  1.,  1.,  1.]],\n       [[ 1.,  1.,  1.,  1.],\n        [ 1.,  1.,  1.,  1.],\n        [ 1.,  1.,  1.,  1.],\n        [ 1.,  1.,  1.,  1.]],\n       [[ 1.,  1.,  1.,  1.],\n        [ 1.,  1.,  1.,  1.],\n        [ 1.,  1.,  1.,  1.],\n        [ 1.,  1.,  1.,  1.]],\n       [[ 1.,  1.,  1.,  1.],\n        [ 1.,  1.,  1.,  1.],\n        [ 1.,  1.,  1.,  1.],\n        [ 1.,  1.,  1.,  1.]]])"
    },
    {
      "name": "coeffs_to_array",
      "docstring": "Arrange a wavelet coefficient list from ``wavedecn`` into a single array.\n\nParameters\n----------\n\ncoeffs : array-like\n    Dictionary of wavelet coefficients as returned by pywt.wavedecn\npadding : float or None, optional\n    The value to use for the background if the coefficients cannot be\n    tightly packed. If None, raise an error if the coefficients cannot be\n    tightly packed.\naxes : sequence of ints, optional\n    Axes over which the DWT that created ``coeffs`` was performed.  The\n    default value of None corresponds to all axes.\n\nReturns\n-------\ncoeff_arr : array-like\n    Wavelet transform coefficient array.\ncoeff_slices : list\n    List of slices corresponding to each coefficient.  As a 2D example,\n    ``coeff_arr[coeff_slices[1]['dd']]`` would extract the first level\n    detail coefficients from ``coeff_arr``.\n\nSee Also\n--------\narray_to_coeffs : the inverse of coeffs_to_array\n\nNotes\n-----\nAssume a 2D coefficient dictionary, c, from a two-level transform.\n\nThen all 2D coefficients will be stacked into a single larger 2D array\nas follows::\n\n    +---------------+---------------+-------------------------------+\n    |               |               |                               |\n    |     c[0]      |  c[1]['da']   |                               |\n    |               |               |                               |\n    +---------------+---------------+           c[2]['da']          |\n    |               |               |                               |\n    | c[1]['ad']    |  c[1]['dd']   |                               |\n    |               |               |                               |\n    +---------------+---------------+ ------------------------------+\n    |                               |                               |\n    |                               |                               |\n    |                               |                               |\n    |          c[2]['ad']           |           c[2]['dd']          |\n    |                               |                               |\n    |                               |                               |\n    |                               |                               |\n    +-------------------------------+-------------------------------+\n\nIf the transform was not performed with mode \"periodization\" or the signal\nlength was not a multiple of ``2**level``, coefficients at each subsequent\nscale will not be exactly 1/2 the size of those at the previous level due\nto additional coefficients retained to handle the boundary condition. In\nthese cases, the default setting of `padding=0` indicates to pad the\nindividual coefficient arrays with 0 as needed so that they can be stacked\ninto a single, contiguous array.\n\nExamples\n--------\n>>> import pywt\n>>> cam = pywt.data.camera()\n>>> coeffs = pywt.wavedecn(cam, wavelet='db2', level=3)\n>>> arr, coeff_slices = pywt.coeffs_to_array(coeffs)"
    },
    {
      "name": "array_to_coeffs",
      "docstring": "Convert a combined array of coefficients back to a list compatible with\n``waverecn``.\n\nParameters\n----------\n\narr : array-like\n    An array containing all wavelet coefficients.  This should have been\n    generated via ``coeffs_to_array``.\ncoeff_slices : list of tuples\n    List of slices corresponding to each coefficient as obtained from\n    ``array_to_coeffs``.\noutput_format : {'wavedec', 'wavedec2', 'wavedecn'}\n    Make the form of the coefficients compatible with this type of\n    multilevel transform.\n\nReturns\n-------\ncoeffs: array-like\n    Wavelet transform coefficient array.\n\nSee Also\n--------\ncoeffs_to_array : the inverse of array_to_coeffs\n\nNotes\n-----\nA single large array containing all coefficients will have subsets stored,\ninto a ``waverecn`` list, c, as indicated below::\n\n    +---------------+---------------+-------------------------------+\n    |               |               |                               |\n    |     c[0]      |  c[1]['da']   |                               |\n    |               |               |                               |\n    +---------------+---------------+           c[2]['da']          |\n    |               |               |                               |\n    | c[1]['ad']    |  c[1]['dd']   |                               |\n    |               |               |                               |\n    +---------------+---------------+ ------------------------------+\n    |                               |                               |\n    |                               |                               |\n    |                               |                               |\n    |          c[2]['ad']           |           c[2]['dd']          |\n    |                               |                               |\n    |                               |                               |\n    |                               |                               |\n    +-------------------------------+-------------------------------+\n\nExamples\n--------\n>>> import pywt\n>>> from numpy.testing import assert_array_almost_equal\n>>> cam = pywt.data.camera()\n>>> coeffs = pywt.wavedecn(cam, wavelet='db2', level=3)\n>>> arr, coeff_slices = pywt.coeffs_to_array(coeffs)\n>>> coeffs_from_arr = pywt.array_to_coeffs(arr, coeff_slices,\n...                                        output_format='wavedecn')\n>>> cam_recon = pywt.waverecn(coeffs_from_arr, wavelet='db2')\n>>> assert_array_almost_equal(cam, cam_recon)"
    },
    {
      "name": "wavedecn_shapes",
      "docstring": "Subband shapes for a multilevel nD discrete wavelet transform.\n\nParameters\n----------\nshape : sequence of ints\n    The shape of the data to be transformed.\nwavelet : Wavelet object or name string, or tuple of wavelets\n    Wavelet to use.  This can also be a tuple containing a wavelet to\n    apply along each axis in ``axes``.\nmode : str or tuple of str, optional\n    Signal extension mode, see :ref:`Modes <ref-modes>`. This can\n    also be a tuple containing a mode to apply along each axis in ``axes``.\nlevel : int, optional\n    Decomposition level (must be >= 0). If level is None (default) then it\n    will be calculated using the ``dwt_max_level`` function.\naxes : sequence of ints, optional\n    Axes over which to compute the DWT. Axes may not be repeated. The\n    default is None, which means transform all axes\n    (``axes = range(data.ndim)``).\n\nReturns\n-------\nshapes : [cAn, {details_level_n}, ... {details_level_1}] : list\n    Coefficients shape list.  Mirrors the output of ``wavedecn``, except\n    it contains only the shapes of the coefficient arrays rather than the\n    arrays themselves.\n\nExamples\n--------\n>>> import pywt\n>>> pywt.wavedecn_shapes((64, 32), wavelet='db2', level=3, axes=(0, ))\n[(10, 32), {'d': (10, 32)}, {'d': (18, 32)}, {'d': (33, 32)}]"
    },
    {
      "name": "wavedecn_size",
      "docstring": "Compute the total number of wavedecn coefficients.\n\nParameters\n----------\nshapes : list of coefficient shapes\n    A set of coefficient shapes as returned by ``wavedecn_shapes``.\n    Alternatively, the user can specify a set of coefficients as returned\n    by ``wavedecn``.\n\nReturns\n-------\nsize : int\n    The total number of coefficients.\n\nExamples\n--------\n>>> import numpy as np\n>>> import pywt\n>>> data_shape = (64, 32)\n>>> shapes = pywt.wavedecn_shapes(data_shape, 'db2', mode='periodization')\n>>> pywt.wavedecn_size(shapes)\n2048\n>>> coeffs = pywt.wavedecn(np.ones(data_shape), 'sym4', mode='symmetric')\n>>> pywt.wavedecn_size(coeffs)\n3087"
    },
    {
      "name": "dwtn_max_level",
      "docstring": "Compute the maximum level of decomposition for n-dimensional data.\n\nThis returns the maximum number of levels of decomposition suitable for use\nwith ``wavedec``, ``wavedec2`` or ``wavedecn``.\n\nParameters\n----------\nshape : sequence of ints\n    Input data shape.\nwavelet : Wavelet object or name string, or tuple of wavelets\n    Wavelet to use. This can also be a tuple containing a wavelet to\n    apply along each axis in ``axes``.\naxes : sequence of ints, optional\n    Axes over which to compute the DWT. Axes may not be repeated.\n\nReturns\n-------\nlevel : int\n    Maximum level.\n\nNotes\n-----\nThe level returned is the smallest ``dwt_max_level`` over all axes.\n\nExamples\n--------\n>>> import pywt\n>>> pywt.dwtn_max_level((64, 32), 'db2')\n3"
    },
    {
      "name": "ravel_coeffs",
      "docstring": "Ravel a set of multilevel wavelet coefficients into a single 1D array.\n\nParameters\n----------\ncoeffs : array-like\n    A list of multilevel wavelet coefficients as returned by\n    ``wavedec``, ``wavedec2`` or ``wavedecn``. This function is also\n    compatible with the output of ``swt``, ``swt2`` and ``swtn`` if those\n    functions were called with ``trim_approx=True``.\naxes : sequence of ints, optional\n    Axes over which the DWT that created ``coeffs`` was performed. The\n    default value of None corresponds to all axes.\n\nReturns\n-------\ncoeff_arr : array-like\n    Wavelet transform coefficient array. All coefficients have been\n    concatenated into a single array.\ncoeff_slices : list\n    List of slices corresponding to each coefficient. As a 2D example,\n    ``coeff_arr[coeff_slices[1]['dd']]`` would extract the first level\n    detail coefficients from ``coeff_arr``.\ncoeff_shapes : list\n    List of shapes corresponding to each coefficient. For example, in 2D,\n    ``coeff_shapes[1]['dd']`` would contain the original shape of the first\n    level detail coefficients array.\n\nSee Also\n--------\nunravel_coeffs : the inverse of ravel_coeffs\n\nExamples\n--------\n>>> import pywt\n>>> cam = pywt.data.camera()\n>>> coeffs = pywt.wavedecn(cam, wavelet='db2', level=3)\n>>> arr, coeff_slices, coeff_shapes = pywt.ravel_coeffs(coeffs)"
    },
    {
      "name": "unravel_coeffs",
      "docstring": "Unravel a raveled array of multilevel wavelet coefficients.\n\nParameters\n----------\narr : array-like\n    An array containing all wavelet coefficients. This should have been\n    generated by applying ``ravel_coeffs`` to the output of ``wavedec``,\n    ``wavedec2`` or ``wavedecn`` (or via ``swt``, ``swt2`` or ``swtn``\n    with ``trim_approx=True``).\ncoeff_slices : list of tuples\n    List of slices corresponding to each coefficient as obtained from\n    ``ravel_coeffs``.\ncoeff_shapes : list of tuples\n    List of shapes corresponding to each coefficient as obtained from\n    ``ravel_coeffs``.\noutput_format : {'wavedec', 'wavedec2', 'wavedecn', 'swt', 'swt2', 'swtn'}, optional\n    Make the form of the unraveled coefficients compatible with this type\n    of multilevel transform. The default is ``'wavedecn'``.\n\nReturns\n-------\ncoeffs: list\n    List of wavelet transform coefficients. The specific format of the list\n    elements is determined by ``output_format``.\n\nSee Also\n--------\nravel_coeffs : the inverse of unravel_coeffs\n\nExamples\n--------\n>>> import pywt\n>>> from numpy.testing import assert_array_almost_equal\n>>> cam = pywt.data.camera()\n>>> coeffs = pywt.wavedecn(cam, wavelet='db2', level=3)\n>>> arr, coeff_slices, coeff_shapes = pywt.ravel_coeffs(coeffs)\n>>> coeffs_from_arr = pywt.unravel_coeffs(arr, coeff_slices, coeff_shapes,\n...                                       output_format='wavedecn')\n>>> cam_recon = pywt.waverecn(coeffs_from_arr, wavelet='db2')\n>>> assert_array_almost_equal(cam, cam_recon)"
    },
    {
      "name": "fswavedecn",
      "docstring": "Fully Separable Wavelet Decomposition.\n\nThis is a variant of the multilevel discrete wavelet transform where all\nlevels of decomposition are performed along a single axis prior to moving\nonto the next axis.  Unlike in ``wavedecn``, the number of levels of\ndecomposition are not required to be the same along each axis which can be\na benefit for anisotropic data.\n\nParameters\n----------\ndata: array_like\n    Input data\nwavelet : Wavelet object or name string, or tuple of wavelets\n    Wavelet to use.  This can also be a tuple containing a wavelet to\n    apply along each axis in ``axes``.\nmode : str or tuple of str, optional\n    Signal extension mode, see :ref:`Modes <ref-modes>`. This can\n    also be a tuple containing a mode to apply along each axis in ``axes``.\nlevels : int or sequence of ints, optional\n    Decomposition levels along each axis (must be >= 0). If an integer is\n    provided, the same number of levels are used for all axes. If\n    ``levels`` is None (default), ``dwt_max_level`` will be used to compute\n    the maximum number of levels possible for each axis.\naxes : sequence of ints, optional\n    Axes over which to compute the transform. Axes may not be repeated. The\n    default is to transform along all axes.\n\nReturns\n-------\nfswavedecn_result : FswavedecnResult object\n    Contains the wavelet coefficients, slice objects to allow obtaining\n    the coefficients per detail or approximation level, and more.\n    See ``FswavedecnResult`` for details.\n\nExamples\n--------\n>>> import numpy as np\n>>> from pywt import fswavedecn\n>>> fs_result = fswavedecn(np.ones((32, 32)), 'sym2', levels=(1, 3))\n>>> print(fs_result.detail_keys())\n[(0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (1, 3)]\n>>> approx_coeffs = fs_result.approx\n>>> detail_1_2 = fs_result[(1, 2)]\n\n\nNotes\n-----\nThis transformation has been variously referred to as the (fully) separable\nwavelet transform (e.g. refs [1]_, [3]_), the tensor-product wavelet\n([2]_) or the hyperbolic wavelet transform ([4]_).  It is well suited to\ndata with anisotropic smoothness.\n\nIn [2]_ it was demonstrated that fully separable transform performs at\nleast as well as the DWT for image compression.  Computation time is a\nfactor 2 larger than that for the DWT.\n\nSee Also\n--------\nfswaverecn : inverse of fswavedecn\n\nReferences\n----------\n.. [1] PH Westerink. Subband Coding of Images. Ph.D. dissertation, Dept.\n   Elect. Eng., Inf. Theory Group, Delft Univ. Technol., Delft, The\n   Netherlands, 1989.  (see Section 2.3)\n   http://resolver.tudelft.nl/uuid:a4d195c3-1f89-4d66-913d-db9af0969509\n\n.. [2] CP Rosiene and TQ Nguyen. Tensor-product wavelet vs. Mallat\n   decomposition: A comparative analysis, in Proc. IEEE Int. Symp.\n   Circuits and Systems, Orlando, FL, Jun. 1999, pp. 431-434.\n\n.. [3] V Velisavljevic, B Beferull-Lozano, M Vetterli and PL Dragotti.\n   Directionlets: Anisotropic Multidirectional Representation With\n   Separable Filtering. IEEE Transactions on Image Processing, Vol. 15,\n   No. 7, July 2006.\n\n.. [4] RA DeVore, SV Konyagin and VN Temlyakov. \"Hyperbolic wavelet\n   approximation,\" Constr. Approx. 14 (1998), 1-26."
    },
    {
      "name": "fswaverecn",
      "docstring": "Fully Separable Inverse Wavelet Reconstruction.\n\nParameters\n----------\nfswavedecn_result : FswavedecnResult object\n    FswavedecnResult object from ``fswavedecn``.\n\nReturns\n-------\nreconstructed : ndarray\n    Array of reconstructed data.\n\nNotes\n-----\nThis transformation has been variously referred to as the (fully) separable\nwavelet transform (e.g. refs [1]_, [3]_), the tensor-product wavelet\n([2]_) or the hyperbolic wavelet transform ([4]_).  It is well suited to\ndata with anisotropic smoothness.\n\nIn [2]_ it was demonstrated that the fully separable transform performs at\nleast as well as the DWT for image compression. Computation time is a\nfactor 2 larger than that for the DWT.\n\nSee Also\n--------\nfswavedecn : inverse of fswaverecn\n\nReferences\n----------\n.. [1] PH Westerink. Subband Coding of Images. Ph.D. dissertation, Dept.\n   Elect. Eng., Inf. Theory Group, Delft Univ. Technol., Delft, The\n   Netherlands, 1989.  (see Section 2.3)\n   http://resolver.tudelft.nl/uuid:a4d195c3-1f89-4d66-913d-db9af0969509\n\n.. [2] CP Rosiene and TQ Nguyen. Tensor-product wavelet vs. Mallat\n   decomposition: A comparative analysis, in Proc. IEEE Int. Symp.\n   Circuits and Systems, Orlando, FL, Jun. 1999, pp. 431-434.\n\n.. [3] V Velisavljevic, B Beferull-Lozano, M Vetterli and PL Dragotti.\n   Directionlets: Anisotropic Multidirectional Representation With\n   Separable Filtering. IEEE Transactions on Image Processing, Vol. 15,\n   No. 7, July 2006.\n\n.. [4] RA DeVore, SV Konyagin and VN Temlyakov. \"Hyperbolic wavelet\n   approximation,\" Constr. Approx. 14 (1998), 1-26."
    },
    {
      "name": "coeffs",
      "docstring": "ndarray: All coefficients stacked into a single array."
    },
    {
      "name": "coeffs",
      "docstring": null
    },
    {
      "name": "coeff_slices",
      "docstring": "List: List of coefficient slices."
    },
    {
      "name": "ndim",
      "docstring": "int: Number of data dimensions."
    },
    {
      "name": "ndim_transform",
      "docstring": "int: Number of axes transformed."
    },
    {
      "name": "axes",
      "docstring": "List of str: The axes the transform was performed along."
    },
    {
      "name": "levels",
      "docstring": "List of int: Levels of decomposition along each transformed axis."
    },
    {
      "name": "wavelets",
      "docstring": "List of pywt.DiscreteWavelet: wavelet for each transformed axis."
    },
    {
      "name": "wavelet_names",
      "docstring": "List of pywt.DiscreteWavelet: wavelet for each transformed axis."
    },
    {
      "name": "modes",
      "docstring": "List of str: The border mode used along each transformed axis."
    },
    {
      "name": "approx",
      "docstring": "ndarray: The approximation coefficients."
    },
    {
      "name": "approx",
      "docstring": null
    },
    {
      "name": "detail_keys",
      "docstring": "Return a list of all detail coefficient keys.\n\nReturns\n-------\nkeys : list of str\n    List of all detail coefficient keys."
    }
  ],
  "innovations": []
}