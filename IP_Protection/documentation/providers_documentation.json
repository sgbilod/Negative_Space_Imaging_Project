{
  "file_path": "c:\\Users\\sgbil\\OneDrive\\Desktop\\Negative_Space_Imaging_Project\\.venv\\Lib\\site-packages\\pip\\_vendor\\resolvelib\\providers.py",
  "classes": [
    {
      "name": "AbstractProvider",
      "docstring": "Delegate class to provide the required interface for the resolver.",
      "methods": [
        {
          "name": "identify",
          "docstring": "Given a requirement or candidate, return an identifier for it.\n\nThis is used to identify, e.g. whether two requirements\nshould have their specifier parts merged or a candidate matches a\nrequirement via ``find_matches()``."
        },
        {
          "name": "get_preference",
          "docstring": "Produce a sort key for given requirement based on preference.\n\nAs this is a sort key it will be called O(n) times per backtrack\nstep, where n is the number of `identifier`s, if you have a check\nwhich is expensive in some sense. E.g. It needs to make O(n) checks\nper call or takes significant wall clock time, consider using\n`narrow_requirement_selection` to filter the `identifier`s, which\nis applied before this sort key is called.\n\nThe preference is defined as \"I think this requirement should be\nresolved first\". The lower the return value is, the more preferred\nthis group of arguments is.\n\n:param identifier: An identifier as returned by ``identify()``. This\n    identifies the requirement being considered.\n:param resolutions: Mapping of candidates currently pinned by the\n    resolver. Each key is an identifier, and the value is a candidate.\n    The candidate may conflict with requirements from ``information``.\n:param candidates: Mapping of each dependency's possible candidates.\n    Each value is an iterator of candidates.\n:param information: Mapping of requirement information of each package.\n    Each value is an iterator of *requirement information*.\n:param backtrack_causes: Sequence of *requirement information* that are\n    the requirements that caused the resolver to most recently\n    backtrack.\n\nA *requirement information* instance is a named tuple with two members:\n\n* ``requirement`` specifies a requirement contributing to the current\n  list of candidates.\n* ``parent`` specifies the candidate that provides (depended on) the\n  requirement, or ``None`` to indicate a root requirement.\n\nThe preference could depend on various issues, including (not\nnecessarily in this order):\n\n* Is this package pinned in the current resolution result?\n* How relaxed is the requirement? Stricter ones should probably be\n  worked on first? (I don't know, actually.)\n* How many possibilities are there to satisfy this requirement? Those\n  with few left should likely be worked on first, I guess?\n* Are there any known conflicts for this requirement? We should\n  probably work on those with the most known conflicts.\n\nA sortable value should be returned (this will be used as the ``key``\nparameter of the built-in sorting function). The smaller the value is,\nthe more preferred this requirement is (i.e. the sorting function\nis called with ``reverse=False``)."
        },
        {
          "name": "find_matches",
          "docstring": "Find all possible candidates that satisfy the given constraints.\n\n:param identifier: An identifier as returned by ``identify()``. All\n    candidates returned by this method should produce the same\n    identifier.\n:param requirements: A mapping of requirements that all returned\n    candidates must satisfy. Each key is an identifier, and the value\n    an iterator of requirements for that dependency.\n:param incompatibilities: A mapping of known incompatibile candidates of\n    each dependency. Each key is an identifier, and the value an\n    iterator of incompatibilities known to the resolver. All\n    incompatibilities *must* be excluded from the return value.\n\nThis should try to get candidates based on the requirements' types.\nFor VCS, local, and archive requirements, the one-and-only match is\nreturned, and for a \"named\" requirement, the index(es) should be\nconsulted to find concrete candidates for this requirement.\n\nThe return value should produce candidates ordered by preference; the\nmost preferred candidate should come first. The return type may be one\nof the following:\n\n* A callable that returns an iterator that yields candidates.\n* An collection of candidates.\n* An iterable of candidates. This will be consumed immediately into a\n  list of candidates."
        },
        {
          "name": "is_satisfied_by",
          "docstring": "Whether the given requirement can be satisfied by a candidate.\n\nThe candidate is guaranteed to have been generated from the\nrequirement.\n\nA boolean should be returned to indicate whether ``candidate`` is a\nviable solution to the requirement."
        },
        {
          "name": "get_dependencies",
          "docstring": "Get dependencies of a candidate.\n\nThis should return a collection of requirements that `candidate`\nspecifies as its dependencies."
        },
        {
          "name": "narrow_requirement_selection",
          "docstring": "An optional method to narrow the selection of requirements being\nconsidered during resolution. This method is called O(1) time per\nbacktrack step.\n\n:param identifiers: An iterable of `identifiers` as returned by\n    ``identify()``. These identify all requirements currently being\n    considered.\n:param resolutions: A mapping of candidates currently pinned by the\n    resolver. Each key is an identifier, and the value is a candidate\n    that may conflict with requirements from ``information``.\n:param candidates: A mapping of each dependency's possible candidates.\n    Each value is an iterator of candidates.\n:param information: A mapping of requirement information for each package.\n    Each value is an iterator of *requirement information*.\n:param backtrack_causes: A sequence of *requirement information* that are\n    the requirements causing the resolver to most recently\n    backtrack.\n\nA *requirement information* instance is a named tuple with two members:\n\n* ``requirement`` specifies a requirement contributing to the current\n  list of candidates.\n* ``parent`` specifies the candidate that provides (is depended on for)\n  the requirement, or ``None`` to indicate a root requirement.\n\nMust return a non-empty subset of `identifiers`, with the default\nimplementation being to return `identifiers` unchanged. Those `identifiers`\nwill then be passed to the sort key `get_preference` to pick the most\nprefered requirement to attempt to pin, unless `narrow_requirement_selection`\nreturns only 1 requirement, in which case that will be used without\ncalling the sort key `get_preference`.\n\nThis method is designed to be used by the provider to optimize the\ndependency resolution, e.g. if a check cost is O(m) and it can be done\nagainst all identifiers at once then filtering the requirement selection\nhere will cost O(m) but making it part of the sort key in `get_preference`\nwill cost O(m*n), where n is the number of `identifiers`.\n\nReturns:\n    Iterable[KT]: A non-empty subset of `identifiers`."
        }
      ]
    },
    {
      "name": "Preference",
      "docstring": null,
      "methods": []
    }
  ],
  "functions": [
    {
      "name": "identify",
      "docstring": "Given a requirement or candidate, return an identifier for it.\n\nThis is used to identify, e.g. whether two requirements\nshould have their specifier parts merged or a candidate matches a\nrequirement via ``find_matches()``."
    },
    {
      "name": "get_preference",
      "docstring": "Produce a sort key for given requirement based on preference.\n\nAs this is a sort key it will be called O(n) times per backtrack\nstep, where n is the number of `identifier`s, if you have a check\nwhich is expensive in some sense. E.g. It needs to make O(n) checks\nper call or takes significant wall clock time, consider using\n`narrow_requirement_selection` to filter the `identifier`s, which\nis applied before this sort key is called.\n\nThe preference is defined as \"I think this requirement should be\nresolved first\". The lower the return value is, the more preferred\nthis group of arguments is.\n\n:param identifier: An identifier as returned by ``identify()``. This\n    identifies the requirement being considered.\n:param resolutions: Mapping of candidates currently pinned by the\n    resolver. Each key is an identifier, and the value is a candidate.\n    The candidate may conflict with requirements from ``information``.\n:param candidates: Mapping of each dependency's possible candidates.\n    Each value is an iterator of candidates.\n:param information: Mapping of requirement information of each package.\n    Each value is an iterator of *requirement information*.\n:param backtrack_causes: Sequence of *requirement information* that are\n    the requirements that caused the resolver to most recently\n    backtrack.\n\nA *requirement information* instance is a named tuple with two members:\n\n* ``requirement`` specifies a requirement contributing to the current\n  list of candidates.\n* ``parent`` specifies the candidate that provides (depended on) the\n  requirement, or ``None`` to indicate a root requirement.\n\nThe preference could depend on various issues, including (not\nnecessarily in this order):\n\n* Is this package pinned in the current resolution result?\n* How relaxed is the requirement? Stricter ones should probably be\n  worked on first? (I don't know, actually.)\n* How many possibilities are there to satisfy this requirement? Those\n  with few left should likely be worked on first, I guess?\n* Are there any known conflicts for this requirement? We should\n  probably work on those with the most known conflicts.\n\nA sortable value should be returned (this will be used as the ``key``\nparameter of the built-in sorting function). The smaller the value is,\nthe more preferred this requirement is (i.e. the sorting function\nis called with ``reverse=False``)."
    },
    {
      "name": "find_matches",
      "docstring": "Find all possible candidates that satisfy the given constraints.\n\n:param identifier: An identifier as returned by ``identify()``. All\n    candidates returned by this method should produce the same\n    identifier.\n:param requirements: A mapping of requirements that all returned\n    candidates must satisfy. Each key is an identifier, and the value\n    an iterator of requirements for that dependency.\n:param incompatibilities: A mapping of known incompatibile candidates of\n    each dependency. Each key is an identifier, and the value an\n    iterator of incompatibilities known to the resolver. All\n    incompatibilities *must* be excluded from the return value.\n\nThis should try to get candidates based on the requirements' types.\nFor VCS, local, and archive requirements, the one-and-only match is\nreturned, and for a \"named\" requirement, the index(es) should be\nconsulted to find concrete candidates for this requirement.\n\nThe return value should produce candidates ordered by preference; the\nmost preferred candidate should come first. The return type may be one\nof the following:\n\n* A callable that returns an iterator that yields candidates.\n* An collection of candidates.\n* An iterable of candidates. This will be consumed immediately into a\n  list of candidates."
    },
    {
      "name": "is_satisfied_by",
      "docstring": "Whether the given requirement can be satisfied by a candidate.\n\nThe candidate is guaranteed to have been generated from the\nrequirement.\n\nA boolean should be returned to indicate whether ``candidate`` is a\nviable solution to the requirement."
    },
    {
      "name": "get_dependencies",
      "docstring": "Get dependencies of a candidate.\n\nThis should return a collection of requirements that `candidate`\nspecifies as its dependencies."
    },
    {
      "name": "narrow_requirement_selection",
      "docstring": "An optional method to narrow the selection of requirements being\nconsidered during resolution. This method is called O(1) time per\nbacktrack step.\n\n:param identifiers: An iterable of `identifiers` as returned by\n    ``identify()``. These identify all requirements currently being\n    considered.\n:param resolutions: A mapping of candidates currently pinned by the\n    resolver. Each key is an identifier, and the value is a candidate\n    that may conflict with requirements from ``information``.\n:param candidates: A mapping of each dependency's possible candidates.\n    Each value is an iterator of candidates.\n:param information: A mapping of requirement information for each package.\n    Each value is an iterator of *requirement information*.\n:param backtrack_causes: A sequence of *requirement information* that are\n    the requirements causing the resolver to most recently\n    backtrack.\n\nA *requirement information* instance is a named tuple with two members:\n\n* ``requirement`` specifies a requirement contributing to the current\n  list of candidates.\n* ``parent`` specifies the candidate that provides (is depended on for)\n  the requirement, or ``None`` to indicate a root requirement.\n\nMust return a non-empty subset of `identifiers`, with the default\nimplementation being to return `identifiers` unchanged. Those `identifiers`\nwill then be passed to the sort key `get_preference` to pick the most\nprefered requirement to attempt to pin, unless `narrow_requirement_selection`\nreturns only 1 requirement, in which case that will be used without\ncalling the sort key `get_preference`.\n\nThis method is designed to be used by the provider to optimize the\ndependency resolution, e.g. if a check cost is O(m) and it can be done\nagainst all identifiers at once then filtering the requirement selection\nhere will cost O(m) but making it part of the sort key in `get_preference`\nwill cost O(m*n), where n is the number of `identifiers`.\n\nReturns:\n    Iterable[KT]: A non-empty subset of `identifiers`."
    }
  ],
  "innovations": []
}