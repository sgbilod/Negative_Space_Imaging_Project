{
  "file_path": "c:\\Users\\sgbil\\OneDrive\\Desktop\\Negative_Space_Imaging_Project\\.venv\\Lib\\site-packages\\numpy\\fft\\_pocketfft.py",
  "classes": [],
  "functions": [
    {
      "name": "fft",
      "docstring": "Compute the one-dimensional discrete Fourier Transform.\n\nThis function computes the one-dimensional *n*-point discrete Fourier\nTransform (DFT) with the efficient Fast Fourier Transform (FFT)\nalgorithm [CT].\n\nParameters\n----------\na : array_like\n    Input array, can be complex.\nn : int, optional\n    Length of the transformed axis of the output.\n    If `n` is smaller than the length of the input, the input is cropped.\n    If it is larger, the input is padded with zeros.  If `n` is not given,\n    the length of the input along the axis specified by `axis` is used.\naxis : int, optional\n    Axis over which to compute the FFT.  If not given, the last axis is\n    used.\nnorm : {\"backward\", \"ortho\", \"forward\"}, optional\n    Normalization mode (see `numpy.fft`). Default is \"backward\".\n    Indicates which direction of the forward/backward pair of transforms\n    is scaled and with what normalization factor.\n\n    .. versionadded:: 1.20.0\n\n        The \"backward\", \"forward\" values were added.\nout : complex ndarray, optional\n    If provided, the result will be placed in this array. It should be\n    of the appropriate shape and dtype.\n\n    .. versionadded:: 2.0.0\n\nReturns\n-------\nout : complex ndarray\n    The truncated or zero-padded input, transformed along the axis\n    indicated by `axis`, or the last one if `axis` is not specified.\n\nRaises\n------\nIndexError\n    If `axis` is not a valid axis of `a`.\n\nSee Also\n--------\nnumpy.fft : for definition of the DFT and conventions used.\nifft : The inverse of `fft`.\nfft2 : The two-dimensional FFT.\nfftn : The *n*-dimensional FFT.\nrfftn : The *n*-dimensional FFT of real input.\nfftfreq : Frequency bins for given FFT parameters.\n\nNotes\n-----\nFFT (Fast Fourier Transform) refers to a way the discrete Fourier\nTransform (DFT) can be calculated efficiently, by using symmetries in the\ncalculated terms.  The symmetry is highest when `n` is a power of 2, and\nthe transform is therefore most efficient for these sizes.\n\nThe DFT is defined, with the conventions used in this implementation, in\nthe documentation for the `numpy.fft` module.\n\nReferences\n----------\n.. [CT] Cooley, James W., and John W. Tukey, 1965, \"An algorithm for the\n        machine calculation of complex Fourier series,\" *Math. Comput.*\n        19: 297-301.\n\nExamples\n--------\n>>> import numpy as np\n>>> np.fft.fft(np.exp(2j * np.pi * np.arange(8) / 8))\narray([-2.33486982e-16+1.14423775e-17j,  8.00000000e+00-1.25557246e-15j,\n        2.33486982e-16+2.33486982e-16j,  0.00000000e+00+1.22464680e-16j,\n       -1.14423775e-17+2.33486982e-16j,  0.00000000e+00+5.20784380e-16j,\n        1.14423775e-17+1.14423775e-17j,  0.00000000e+00+1.22464680e-16j])\n\nIn this example, real input has an FFT which is Hermitian, i.e., symmetric\nin the real part and anti-symmetric in the imaginary part, as described in\nthe `numpy.fft` documentation:\n\n>>> import matplotlib.pyplot as plt\n>>> t = np.arange(256)\n>>> sp = np.fft.fft(np.sin(t))\n>>> freq = np.fft.fftfreq(t.shape[-1])\n>>> plt.plot(freq, sp.real, freq, sp.imag)\n[<matplotlib.lines.Line2D object at 0x...>, <matplotlib.lines.Line2D object at 0x...>]\n>>> plt.show()"
    },
    {
      "name": "ifft",
      "docstring": "Compute the one-dimensional inverse discrete Fourier Transform.\n\nThis function computes the inverse of the one-dimensional *n*-point\ndiscrete Fourier transform computed by `fft`.  In other words,\n``ifft(fft(a)) == a`` to within numerical accuracy.\nFor a general description of the algorithm and definitions,\nsee `numpy.fft`.\n\nThe input should be ordered in the same way as is returned by `fft`,\ni.e.,\n\n* ``a[0]`` should contain the zero frequency term,\n* ``a[1:n//2]`` should contain the positive-frequency terms,\n* ``a[n//2 + 1:]`` should contain the negative-frequency terms, in\n  increasing order starting from the most negative frequency.\n\nFor an even number of input points, ``A[n//2]`` represents the sum of\nthe values at the positive and negative Nyquist frequencies, as the two\nare aliased together. See `numpy.fft` for details.\n\nParameters\n----------\na : array_like\n    Input array, can be complex.\nn : int, optional\n    Length of the transformed axis of the output.\n    If `n` is smaller than the length of the input, the input is cropped.\n    If it is larger, the input is padded with zeros.  If `n` is not given,\n    the length of the input along the axis specified by `axis` is used.\n    See notes about padding issues.\naxis : int, optional\n    Axis over which to compute the inverse DFT.  If not given, the last\n    axis is used.\nnorm : {\"backward\", \"ortho\", \"forward\"}, optional\n    Normalization mode (see `numpy.fft`). Default is \"backward\".\n    Indicates which direction of the forward/backward pair of transforms\n    is scaled and with what normalization factor.\n\n    .. versionadded:: 1.20.0\n\n        The \"backward\", \"forward\" values were added.\n\nout : complex ndarray, optional\n    If provided, the result will be placed in this array. It should be\n    of the appropriate shape and dtype.\n\n    .. versionadded:: 2.0.0\n\nReturns\n-------\nout : complex ndarray\n    The truncated or zero-padded input, transformed along the axis\n    indicated by `axis`, or the last one if `axis` is not specified.\n\nRaises\n------\nIndexError\n    If `axis` is not a valid axis of `a`.\n\nSee Also\n--------\nnumpy.fft : An introduction, with definitions and general explanations.\nfft : The one-dimensional (forward) FFT, of which `ifft` is the inverse\nifft2 : The two-dimensional inverse FFT.\nifftn : The n-dimensional inverse FFT.\n\nNotes\n-----\nIf the input parameter `n` is larger than the size of the input, the input\nis padded by appending zeros at the end.  Even though this is the common\napproach, it might lead to surprising results.  If a different padding is\ndesired, it must be performed before calling `ifft`.\n\nExamples\n--------\n>>> import numpy as np\n>>> np.fft.ifft([0, 4, 0, 0])\narray([ 1.+0.j,  0.+1.j, -1.+0.j,  0.-1.j]) # may vary\n\nCreate and plot a band-limited signal with random phases:\n\n>>> import matplotlib.pyplot as plt\n>>> t = np.arange(400)\n>>> n = np.zeros((400,), dtype=complex)\n>>> n[40:60] = np.exp(1j*np.random.uniform(0, 2*np.pi, (20,)))\n>>> s = np.fft.ifft(n)\n>>> plt.plot(t, s.real, label='real')\n[<matplotlib.lines.Line2D object at ...>]\n>>> plt.plot(t, s.imag, '--', label='imaginary')\n[<matplotlib.lines.Line2D object at ...>]\n>>> plt.legend()\n<matplotlib.legend.Legend object at ...>\n>>> plt.show()"
    },
    {
      "name": "rfft",
      "docstring": "Compute the one-dimensional discrete Fourier Transform for real input.\n\nThis function computes the one-dimensional *n*-point discrete Fourier\nTransform (DFT) of a real-valued array by means of an efficient algorithm\ncalled the Fast Fourier Transform (FFT).\n\nParameters\n----------\na : array_like\n    Input array\nn : int, optional\n    Number of points along transformation axis in the input to use.\n    If `n` is smaller than the length of the input, the input is cropped.\n    If it is larger, the input is padded with zeros. If `n` is not given,\n    the length of the input along the axis specified by `axis` is used.\naxis : int, optional\n    Axis over which to compute the FFT. If not given, the last axis is\n    used.\nnorm : {\"backward\", \"ortho\", \"forward\"}, optional\n    Normalization mode (see `numpy.fft`). Default is \"backward\".\n    Indicates which direction of the forward/backward pair of transforms\n    is scaled and with what normalization factor.\n\n    .. versionadded:: 1.20.0\n\n        The \"backward\", \"forward\" values were added.\n\nout : complex ndarray, optional\n    If provided, the result will be placed in this array. It should be\n    of the appropriate shape and dtype.\n\n    .. versionadded:: 2.0.0\n\nReturns\n-------\nout : complex ndarray\n    The truncated or zero-padded input, transformed along the axis\n    indicated by `axis`, or the last one if `axis` is not specified.\n    If `n` is even, the length of the transformed axis is ``(n/2)+1``.\n    If `n` is odd, the length is ``(n+1)/2``.\n\nRaises\n------\nIndexError\n    If `axis` is not a valid axis of `a`.\n\nSee Also\n--------\nnumpy.fft : For definition of the DFT and conventions used.\nirfft : The inverse of `rfft`.\nfft : The one-dimensional FFT of general (complex) input.\nfftn : The *n*-dimensional FFT.\nrfftn : The *n*-dimensional FFT of real input.\n\nNotes\n-----\nWhen the DFT is computed for purely real input, the output is\nHermitian-symmetric, i.e. the negative frequency terms are just the complex\nconjugates of the corresponding positive-frequency terms, and the\nnegative-frequency terms are therefore redundant.  This function does not\ncompute the negative frequency terms, and the length of the transformed\naxis of the output is therefore ``n//2 + 1``.\n\nWhen ``A = rfft(a)`` and fs is the sampling frequency, ``A[0]`` contains\nthe zero-frequency term 0*fs, which is real due to Hermitian symmetry.\n\nIf `n` is even, ``A[-1]`` contains the term representing both positive\nand negative Nyquist frequency (+fs/2 and -fs/2), and must also be purely\nreal. If `n` is odd, there is no term at fs/2; ``A[-1]`` contains\nthe largest positive frequency (fs/2*(n-1)/n), and is complex in the\ngeneral case.\n\nIf the input `a` contains an imaginary part, it is silently discarded.\n\nExamples\n--------\n>>> import numpy as np\n>>> np.fft.fft([0, 1, 0, 0])\narray([ 1.+0.j,  0.-1.j, -1.+0.j,  0.+1.j]) # may vary\n>>> np.fft.rfft([0, 1, 0, 0])\narray([ 1.+0.j,  0.-1.j, -1.+0.j]) # may vary\n\nNotice how the final element of the `fft` output is the complex conjugate\nof the second element, for real input. For `rfft`, this symmetry is\nexploited to compute only the non-negative frequency terms."
    },
    {
      "name": "irfft",
      "docstring": "Computes the inverse of `rfft`.\n\nThis function computes the inverse of the one-dimensional *n*-point\ndiscrete Fourier Transform of real input computed by `rfft`.\nIn other words, ``irfft(rfft(a), len(a)) == a`` to within numerical\naccuracy. (See Notes below for why ``len(a)`` is necessary here.)\n\nThe input is expected to be in the form returned by `rfft`, i.e. the\nreal zero-frequency term followed by the complex positive frequency terms\nin order of increasing frequency.  Since the discrete Fourier Transform of\nreal input is Hermitian-symmetric, the negative frequency terms are taken\nto be the complex conjugates of the corresponding positive frequency terms.\n\nParameters\n----------\na : array_like\n    The input array.\nn : int, optional\n    Length of the transformed axis of the output.\n    For `n` output points, ``n//2+1`` input points are necessary.  If the\n    input is longer than this, it is cropped.  If it is shorter than this,\n    it is padded with zeros.  If `n` is not given, it is taken to be\n    ``2*(m-1)`` where ``m`` is the length of the input along the axis\n    specified by `axis`.\naxis : int, optional\n    Axis over which to compute the inverse FFT. If not given, the last\n    axis is used.\nnorm : {\"backward\", \"ortho\", \"forward\"}, optional\n    Normalization mode (see `numpy.fft`). Default is \"backward\".\n    Indicates which direction of the forward/backward pair of transforms\n    is scaled and with what normalization factor.\n\n    .. versionadded:: 1.20.0\n\n        The \"backward\", \"forward\" values were added.\n\nout : ndarray, optional\n    If provided, the result will be placed in this array. It should be\n    of the appropriate shape and dtype.\n\n    .. versionadded:: 2.0.0\n\nReturns\n-------\nout : ndarray\n    The truncated or zero-padded input, transformed along the axis\n    indicated by `axis`, or the last one if `axis` is not specified.\n    The length of the transformed axis is `n`, or, if `n` is not given,\n    ``2*(m-1)`` where ``m`` is the length of the transformed axis of the\n    input. To get an odd number of output points, `n` must be specified.\n\nRaises\n------\nIndexError\n    If `axis` is not a valid axis of `a`.\n\nSee Also\n--------\nnumpy.fft : For definition of the DFT and conventions used.\nrfft : The one-dimensional FFT of real input, of which `irfft` is inverse.\nfft : The one-dimensional FFT.\nirfft2 : The inverse of the two-dimensional FFT of real input.\nirfftn : The inverse of the *n*-dimensional FFT of real input.\n\nNotes\n-----\nReturns the real valued `n`-point inverse discrete Fourier transform\nof `a`, where `a` contains the non-negative frequency terms of a\nHermitian-symmetric sequence. `n` is the length of the result, not the\ninput.\n\nIf you specify an `n` such that `a` must be zero-padded or truncated, the\nextra/removed values will be added/removed at high frequencies. One can\nthus resample a series to `m` points via Fourier interpolation by:\n``a_resamp = irfft(rfft(a), m)``.\n\nThe correct interpretation of the hermitian input depends on the length of\nthe original data, as given by `n`. This is because each input shape could\ncorrespond to either an odd or even length signal. By default, `irfft`\nassumes an even output length which puts the last entry at the Nyquist\nfrequency; aliasing with its symmetric counterpart. By Hermitian symmetry,\nthe value is thus treated as purely real. To avoid losing information, the\ncorrect length of the real input **must** be given.\n\nExamples\n--------\n>>> import numpy as np\n>>> np.fft.ifft([1, -1j, -1, 1j])\narray([0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]) # may vary\n>>> np.fft.irfft([1, -1j, -1])\narray([0.,  1.,  0.,  0.])\n\nNotice how the last term in the input to the ordinary `ifft` is the\ncomplex conjugate of the second term, and the output has zero imaginary\npart everywhere.  When calling `irfft`, the negative frequencies are not\nspecified, and the output array is purely real."
    },
    {
      "name": "hfft",
      "docstring": "Compute the FFT of a signal that has Hermitian symmetry, i.e., a real\nspectrum.\n\nParameters\n----------\na : array_like\n    The input array.\nn : int, optional\n    Length of the transformed axis of the output. For `n` output\n    points, ``n//2 + 1`` input points are necessary.  If the input is\n    longer than this, it is cropped.  If it is shorter than this, it is\n    padded with zeros.  If `n` is not given, it is taken to be ``2*(m-1)``\n    where ``m`` is the length of the input along the axis specified by\n    `axis`.\naxis : int, optional\n    Axis over which to compute the FFT. If not given, the last\n    axis is used.\nnorm : {\"backward\", \"ortho\", \"forward\"}, optional\n    Normalization mode (see `numpy.fft`). Default is \"backward\".\n    Indicates which direction of the forward/backward pair of transforms\n    is scaled and with what normalization factor.\n\n    .. versionadded:: 1.20.0\n\n        The \"backward\", \"forward\" values were added.\n\nout : ndarray, optional\n    If provided, the result will be placed in this array. It should be\n    of the appropriate shape and dtype.\n\n    .. versionadded:: 2.0.0\n\nReturns\n-------\nout : ndarray\n    The truncated or zero-padded input, transformed along the axis\n    indicated by `axis`, or the last one if `axis` is not specified.\n    The length of the transformed axis is `n`, or, if `n` is not given,\n    ``2*m - 2`` where ``m`` is the length of the transformed axis of\n    the input. To get an odd number of output points, `n` must be\n    specified, for instance as ``2*m - 1`` in the typical case,\n\nRaises\n------\nIndexError\n    If `axis` is not a valid axis of `a`.\n\nSee also\n--------\nrfft : Compute the one-dimensional FFT for real input.\nihfft : The inverse of `hfft`.\n\nNotes\n-----\n`hfft`/`ihfft` are a pair analogous to `rfft`/`irfft`, but for the\nopposite case: here the signal has Hermitian symmetry in the time\ndomain and is real in the frequency domain. So here it's `hfft` for\nwhich you must supply the length of the result if it is to be odd.\n\n* even: ``ihfft(hfft(a, 2*len(a) - 2)) == a``, within roundoff error,\n* odd: ``ihfft(hfft(a, 2*len(a) - 1)) == a``, within roundoff error.\n\nThe correct interpretation of the hermitian input depends on the length of\nthe original data, as given by `n`. This is because each input shape could\ncorrespond to either an odd or even length signal. By default, `hfft`\nassumes an even output length which puts the last entry at the Nyquist\nfrequency; aliasing with its symmetric counterpart. By Hermitian symmetry,\nthe value is thus treated as purely real. To avoid losing information, the\nshape of the full signal **must** be given.\n\nExamples\n--------\n>>> import numpy as np\n>>> signal = np.array([1, 2, 3, 4, 3, 2])\n>>> np.fft.fft(signal)\narray([15.+0.j,  -4.+0.j,   0.+0.j,  -1.-0.j,   0.+0.j,  -4.+0.j]) # may vary\n>>> np.fft.hfft(signal[:4]) # Input first half of signal\narray([15.,  -4.,   0.,  -1.,   0.,  -4.])\n>>> np.fft.hfft(signal, 6)  # Input entire signal and truncate\narray([15.,  -4.,   0.,  -1.,   0.,  -4.])\n\n\n>>> signal = np.array([[1, 1.j], [-1.j, 2]])\n>>> np.conj(signal.T) - signal   # check Hermitian symmetry\narray([[ 0.-0.j,  -0.+0.j], # may vary\n       [ 0.+0.j,  0.-0.j]])\n>>> freq_spectrum = np.fft.hfft(signal)\n>>> freq_spectrum\narray([[ 1.,  1.],\n       [ 2., -2.]])"
    },
    {
      "name": "ihfft",
      "docstring": "Compute the inverse FFT of a signal that has Hermitian symmetry.\n\nParameters\n----------\na : array_like\n    Input array.\nn : int, optional\n    Length of the inverse FFT, the number of points along\n    transformation axis in the input to use.  If `n` is smaller than\n    the length of the input, the input is cropped.  If it is larger,\n    the input is padded with zeros. If `n` is not given, the length of\n    the input along the axis specified by `axis` is used.\naxis : int, optional\n    Axis over which to compute the inverse FFT. If not given, the last\n    axis is used.\nnorm : {\"backward\", \"ortho\", \"forward\"}, optional\n    Normalization mode (see `numpy.fft`). Default is \"backward\".\n    Indicates which direction of the forward/backward pair of transforms\n    is scaled and with what normalization factor.\n\n    .. versionadded:: 1.20.0\n\n        The \"backward\", \"forward\" values were added.\n\nout : complex ndarray, optional\n    If provided, the result will be placed in this array. It should be\n    of the appropriate shape and dtype.\n\n    .. versionadded:: 2.0.0\n\nReturns\n-------\nout : complex ndarray\n    The truncated or zero-padded input, transformed along the axis\n    indicated by `axis`, or the last one if `axis` is not specified.\n    The length of the transformed axis is ``n//2 + 1``.\n\nSee also\n--------\nhfft, irfft\n\nNotes\n-----\n`hfft`/`ihfft` are a pair analogous to `rfft`/`irfft`, but for the\nopposite case: here the signal has Hermitian symmetry in the time\ndomain and is real in the frequency domain. So here it's `hfft` for\nwhich you must supply the length of the result if it is to be odd:\n\n* even: ``ihfft(hfft(a, 2*len(a) - 2)) == a``, within roundoff error,\n* odd: ``ihfft(hfft(a, 2*len(a) - 1)) == a``, within roundoff error.\n\nExamples\n--------\n>>> import numpy as np\n>>> spectrum = np.array([ 15, -4, 0, -1, 0, -4])\n>>> np.fft.ifft(spectrum)\narray([1.+0.j,  2.+0.j,  3.+0.j,  4.+0.j,  3.+0.j,  2.+0.j]) # may vary\n>>> np.fft.ihfft(spectrum)\narray([ 1.-0.j,  2.-0.j,  3.-0.j,  4.-0.j]) # may vary"
    },
    {
      "name": "fftn",
      "docstring": "Compute the N-dimensional discrete Fourier Transform.\n\nThis function computes the *N*-dimensional discrete Fourier Transform over\nany number of axes in an *M*-dimensional array by means of the Fast Fourier\nTransform (FFT).\n\nParameters\n----------\na : array_like\n    Input array, can be complex.\ns : sequence of ints, optional\n    Shape (length of each transformed axis) of the output\n    (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.).\n    This corresponds to ``n`` for ``fft(x, n)``.\n    Along any axis, if the given shape is smaller than that of the input,\n    the input is cropped. If it is larger, the input is padded with zeros.\n\n    .. versionchanged:: 2.0\n\n        If it is ``-1``, the whole input is used (no padding/trimming).\n\n    If `s` is not given, the shape of the input along the axes specified\n    by `axes` is used.\n\n    .. deprecated:: 2.0\n\n        If `s` is not ``None``, `axes` must not be ``None`` either.\n\n    .. deprecated:: 2.0\n\n        `s` must contain only ``int`` s, not ``None`` values. ``None``\n        values currently mean that the default value for ``n`` is used\n        in the corresponding 1-D transform, but this behaviour is\n        deprecated.\n\naxes : sequence of ints, optional\n    Axes over which to compute the FFT.  If not given, the last ``len(s)``\n    axes are used, or all axes if `s` is also not specified.\n    Repeated indices in `axes` means that the transform over that axis is\n    performed multiple times.\n\n    .. deprecated:: 2.0\n\n        If `s` is specified, the corresponding `axes` to be transformed\n        must be explicitly specified too.\n\nnorm : {\"backward\", \"ortho\", \"forward\"}, optional\n    Normalization mode (see `numpy.fft`). Default is \"backward\".\n    Indicates which direction of the forward/backward pair of transforms\n    is scaled and with what normalization factor.\n\n    .. versionadded:: 1.20.0\n\n        The \"backward\", \"forward\" values were added.\n\nout : complex ndarray, optional\n    If provided, the result will be placed in this array. It should be\n    of the appropriate shape and dtype for all axes (and hence is\n    incompatible with passing in all but the trivial ``s``).\n\n    .. versionadded:: 2.0.0\n\nReturns\n-------\nout : complex ndarray\n    The truncated or zero-padded input, transformed along the axes\n    indicated by `axes`, or by a combination of `s` and `a`,\n    as explained in the parameters section above.\n\nRaises\n------\nValueError\n    If `s` and `axes` have different length.\nIndexError\n    If an element of `axes` is larger than than the number of axes of `a`.\n\nSee Also\n--------\nnumpy.fft : Overall view of discrete Fourier transforms, with definitions\n    and conventions used.\nifftn : The inverse of `fftn`, the inverse *n*-dimensional FFT.\nfft : The one-dimensional FFT, with definitions and conventions used.\nrfftn : The *n*-dimensional FFT of real input.\nfft2 : The two-dimensional FFT.\nfftshift : Shifts zero-frequency terms to centre of array\n\nNotes\n-----\nThe output, analogously to `fft`, contains the term for zero frequency in\nthe low-order corner of all axes, the positive frequency terms in the\nfirst half of all axes, the term for the Nyquist frequency in the middle\nof all axes and the negative frequency terms in the second half of all\naxes, in order of decreasingly negative frequency.\n\nSee `numpy.fft` for details, definitions and conventions used.\n\nExamples\n--------\n>>> import numpy as np\n>>> a = np.mgrid[:3, :3, :3][0]\n>>> np.fft.fftn(a, axes=(1, 2))\narray([[[ 0.+0.j,   0.+0.j,   0.+0.j], # may vary\n        [ 0.+0.j,   0.+0.j,   0.+0.j],\n        [ 0.+0.j,   0.+0.j,   0.+0.j]],\n       [[ 9.+0.j,   0.+0.j,   0.+0.j],\n        [ 0.+0.j,   0.+0.j,   0.+0.j],\n        [ 0.+0.j,   0.+0.j,   0.+0.j]],\n       [[18.+0.j,   0.+0.j,   0.+0.j],\n        [ 0.+0.j,   0.+0.j,   0.+0.j],\n        [ 0.+0.j,   0.+0.j,   0.+0.j]]])\n>>> np.fft.fftn(a, (2, 2), axes=(0, 1))\narray([[[ 2.+0.j,  2.+0.j,  2.+0.j], # may vary\n        [ 0.+0.j,  0.+0.j,  0.+0.j]],\n       [[-2.+0.j, -2.+0.j, -2.+0.j],\n        [ 0.+0.j,  0.+0.j,  0.+0.j]]])\n\n>>> import matplotlib.pyplot as plt\n>>> [X, Y] = np.meshgrid(2 * np.pi * np.arange(200) / 12,\n...                      2 * np.pi * np.arange(200) / 34)\n>>> S = np.sin(X) + np.cos(Y) + np.random.uniform(0, 1, X.shape)\n>>> FS = np.fft.fftn(S)\n>>> plt.imshow(np.log(np.abs(np.fft.fftshift(FS))**2))\n<matplotlib.image.AxesImage object at 0x...>\n>>> plt.show()"
    },
    {
      "name": "ifftn",
      "docstring": "Compute the N-dimensional inverse discrete Fourier Transform.\n\nThis function computes the inverse of the N-dimensional discrete\nFourier Transform over any number of axes in an M-dimensional array by\nmeans of the Fast Fourier Transform (FFT).  In other words,\n``ifftn(fftn(a)) == a`` to within numerical accuracy.\nFor a description of the definitions and conventions used, see `numpy.fft`.\n\nThe input, analogously to `ifft`, should be ordered in the same way as is\nreturned by `fftn`, i.e. it should have the term for zero frequency\nin all axes in the low-order corner, the positive frequency terms in the\nfirst half of all axes, the term for the Nyquist frequency in the middle\nof all axes and the negative frequency terms in the second half of all\naxes, in order of decreasingly negative frequency.\n\nParameters\n----------\na : array_like\n    Input array, can be complex.\ns : sequence of ints, optional\n    Shape (length of each transformed axis) of the output\n    (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.).\n    This corresponds to ``n`` for ``ifft(x, n)``.\n    Along any axis, if the given shape is smaller than that of the input,\n    the input is cropped. If it is larger, the input is padded with zeros.\n\n    .. versionchanged:: 2.0\n\n        If it is ``-1``, the whole input is used (no padding/trimming).\n\n    If `s` is not given, the shape of the input along the axes specified\n    by `axes` is used. See notes for issue on `ifft` zero padding.\n\n    .. deprecated:: 2.0\n\n        If `s` is not ``None``, `axes` must not be ``None`` either.\n\n    .. deprecated:: 2.0\n\n        `s` must contain only ``int`` s, not ``None`` values. ``None``\n        values currently mean that the default value for ``n`` is used\n        in the corresponding 1-D transform, but this behaviour is\n        deprecated.\n\naxes : sequence of ints, optional\n    Axes over which to compute the IFFT.  If not given, the last ``len(s)``\n    axes are used, or all axes if `s` is also not specified.\n    Repeated indices in `axes` means that the inverse transform over that\n    axis is performed multiple times.\n\n    .. deprecated:: 2.0\n\n        If `s` is specified, the corresponding `axes` to be transformed\n        must be explicitly specified too.\n\nnorm : {\"backward\", \"ortho\", \"forward\"}, optional\n    Normalization mode (see `numpy.fft`). Default is \"backward\".\n    Indicates which direction of the forward/backward pair of transforms\n    is scaled and with what normalization factor.\n\n    .. versionadded:: 1.20.0\n\n        The \"backward\", \"forward\" values were added.\n\nout : complex ndarray, optional\n    If provided, the result will be placed in this array. It should be\n    of the appropriate shape and dtype for all axes (and hence is\n    incompatible with passing in all but the trivial ``s``).\n\n    .. versionadded:: 2.0.0\n\nReturns\n-------\nout : complex ndarray\n    The truncated or zero-padded input, transformed along the axes\n    indicated by `axes`, or by a combination of `s` or `a`,\n    as explained in the parameters section above.\n\nRaises\n------\nValueError\n    If `s` and `axes` have different length.\nIndexError\n    If an element of `axes` is larger than than the number of axes of `a`.\n\nSee Also\n--------\nnumpy.fft : Overall view of discrete Fourier transforms, with definitions\n     and conventions used.\nfftn : The forward *n*-dimensional FFT, of which `ifftn` is the inverse.\nifft : The one-dimensional inverse FFT.\nifft2 : The two-dimensional inverse FFT.\nifftshift : Undoes `fftshift`, shifts zero-frequency terms to beginning\n    of array.\n\nNotes\n-----\nSee `numpy.fft` for definitions and conventions used.\n\nZero-padding, analogously with `ifft`, is performed by appending zeros to\nthe input along the specified dimension.  Although this is the common\napproach, it might lead to surprising results.  If another form of zero\npadding is desired, it must be performed before `ifftn` is called.\n\nExamples\n--------\n>>> import numpy as np\n>>> a = np.eye(4)\n>>> np.fft.ifftn(np.fft.fftn(a, axes=(0,)), axes=(1,))\narray([[1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j], # may vary\n       [0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j],\n       [0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],\n       [0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j]])\n\n\nCreate and plot an image with band-limited frequency content:\n\n>>> import matplotlib.pyplot as plt\n>>> n = np.zeros((200,200), dtype=complex)\n>>> n[60:80, 20:40] = np.exp(1j*np.random.uniform(0, 2*np.pi, (20, 20)))\n>>> im = np.fft.ifftn(n).real\n>>> plt.imshow(im)\n<matplotlib.image.AxesImage object at 0x...>\n>>> plt.show()"
    },
    {
      "name": "fft2",
      "docstring": "Compute the 2-dimensional discrete Fourier Transform.\n\nThis function computes the *n*-dimensional discrete Fourier Transform\nover any axes in an *M*-dimensional array by means of the\nFast Fourier Transform (FFT).  By default, the transform is computed over\nthe last two axes of the input array, i.e., a 2-dimensional FFT.\n\nParameters\n----------\na : array_like\n    Input array, can be complex\ns : sequence of ints, optional\n    Shape (length of each transformed axis) of the output\n    (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.).\n    This corresponds to ``n`` for ``fft(x, n)``.\n    Along each axis, if the given shape is smaller than that of the input,\n    the input is cropped. If it is larger, the input is padded with zeros.\n\n    .. versionchanged:: 2.0\n\n        If it is ``-1``, the whole input is used (no padding/trimming).\n\n    If `s` is not given, the shape of the input along the axes specified\n    by `axes` is used.\n\n    .. deprecated:: 2.0\n\n        If `s` is not ``None``, `axes` must not be ``None`` either.\n\n    .. deprecated:: 2.0\n\n        `s` must contain only ``int`` s, not ``None`` values. ``None``\n        values currently mean that the default value for ``n`` is used\n        in the corresponding 1-D transform, but this behaviour is\n        deprecated.\n\naxes : sequence of ints, optional\n    Axes over which to compute the FFT.  If not given, the last two\n    axes are used.  A repeated index in `axes` means the transform over\n    that axis is performed multiple times.  A one-element sequence means\n    that a one-dimensional FFT is performed. Default: ``(-2, -1)``.\n\n    .. deprecated:: 2.0\n\n        If `s` is specified, the corresponding `axes` to be transformed\n        must not be ``None``.\n\nnorm : {\"backward\", \"ortho\", \"forward\"}, optional\n    Normalization mode (see `numpy.fft`). Default is \"backward\".\n    Indicates which direction of the forward/backward pair of transforms\n    is scaled and with what normalization factor.\n\n    .. versionadded:: 1.20.0\n\n        The \"backward\", \"forward\" values were added.\n\nout : complex ndarray, optional\n    If provided, the result will be placed in this array. It should be\n    of the appropriate shape and dtype for all axes (and hence only the\n    last axis can have ``s`` not equal to the shape at that axis).\n\n    .. versionadded:: 2.0.0\n\nReturns\n-------\nout : complex ndarray\n    The truncated or zero-padded input, transformed along the axes\n    indicated by `axes`, or the last two axes if `axes` is not given.\n\nRaises\n------\nValueError\n    If `s` and `axes` have different length, or `axes` not given and\n    ``len(s) != 2``.\nIndexError\n    If an element of `axes` is larger than than the number of axes of `a`.\n\nSee Also\n--------\nnumpy.fft : Overall view of discrete Fourier transforms, with definitions\n     and conventions used.\nifft2 : The inverse two-dimensional FFT.\nfft : The one-dimensional FFT.\nfftn : The *n*-dimensional FFT.\nfftshift : Shifts zero-frequency terms to the center of the array.\n    For two-dimensional input, swaps first and third quadrants, and second\n    and fourth quadrants.\n\nNotes\n-----\n`fft2` is just `fftn` with a different default for `axes`.\n\nThe output, analogously to `fft`, contains the term for zero frequency in\nthe low-order corner of the transformed axes, the positive frequency terms\nin the first half of these axes, the term for the Nyquist frequency in the\nmiddle of the axes and the negative frequency terms in the second half of\nthe axes, in order of decreasingly negative frequency.\n\nSee `fftn` for details and a plotting example, and `numpy.fft` for\ndefinitions and conventions used.\n\n\nExamples\n--------\n>>> import numpy as np\n>>> a = np.mgrid[:5, :5][0]\n>>> np.fft.fft2(a)\narray([[ 50.  +0.j        ,   0.  +0.j        ,   0.  +0.j        , # may vary\n          0.  +0.j        ,   0.  +0.j        ],\n       [-12.5+17.20477401j,   0.  +0.j        ,   0.  +0.j        ,\n          0.  +0.j        ,   0.  +0.j        ],\n       [-12.5 +4.0614962j ,   0.  +0.j        ,   0.  +0.j        ,\n          0.  +0.j        ,   0.  +0.j        ],\n       [-12.5 -4.0614962j ,   0.  +0.j        ,   0.  +0.j        ,\n          0.  +0.j        ,   0.  +0.j        ],\n       [-12.5-17.20477401j,   0.  +0.j        ,   0.  +0.j        ,\n          0.  +0.j        ,   0.  +0.j        ]])"
    },
    {
      "name": "ifft2",
      "docstring": "Compute the 2-dimensional inverse discrete Fourier Transform.\n\nThis function computes the inverse of the 2-dimensional discrete Fourier\nTransform over any number of axes in an M-dimensional array by means of\nthe Fast Fourier Transform (FFT).  In other words, ``ifft2(fft2(a)) == a``\nto within numerical accuracy.  By default, the inverse transform is\ncomputed over the last two axes of the input array.\n\nThe input, analogously to `ifft`, should be ordered in the same way as is\nreturned by `fft2`, i.e. it should have the term for zero frequency\nin the low-order corner of the two axes, the positive frequency terms in\nthe first half of these axes, the term for the Nyquist frequency in the\nmiddle of the axes and the negative frequency terms in the second half of\nboth axes, in order of decreasingly negative frequency.\n\nParameters\n----------\na : array_like\n    Input array, can be complex.\ns : sequence of ints, optional\n    Shape (length of each axis) of the output (``s[0]`` refers to axis 0,\n    ``s[1]`` to axis 1, etc.).  This corresponds to `n` for ``ifft(x, n)``.\n    Along each axis, if the given shape is smaller than that of the input,\n    the input is cropped. If it is larger, the input is padded with zeros.\n\n    .. versionchanged:: 2.0\n\n        If it is ``-1``, the whole input is used (no padding/trimming).\n\n    If `s` is not given, the shape of the input along the axes specified\n    by `axes` is used.  See notes for issue on `ifft` zero padding.\n\n    .. deprecated:: 2.0\n\n        If `s` is not ``None``, `axes` must not be ``None`` either.\n\n    .. deprecated:: 2.0\n\n        `s` must contain only ``int`` s, not ``None`` values. ``None``\n        values currently mean that the default value for ``n`` is used\n        in the corresponding 1-D transform, but this behaviour is\n        deprecated.\n\naxes : sequence of ints, optional\n    Axes over which to compute the FFT.  If not given, the last two\n    axes are used.  A repeated index in `axes` means the transform over\n    that axis is performed multiple times.  A one-element sequence means\n    that a one-dimensional FFT is performed. Default: ``(-2, -1)``.\n\n    .. deprecated:: 2.0\n\n        If `s` is specified, the corresponding `axes` to be transformed\n        must not be ``None``.\n\nnorm : {\"backward\", \"ortho\", \"forward\"}, optional\n    Normalization mode (see `numpy.fft`). Default is \"backward\".\n    Indicates which direction of the forward/backward pair of transforms\n    is scaled and with what normalization factor.\n\n    .. versionadded:: 1.20.0\n\n        The \"backward\", \"forward\" values were added.\n\nout : complex ndarray, optional\n    If provided, the result will be placed in this array. It should be\n    of the appropriate shape and dtype for all axes (and hence is\n    incompatible with passing in all but the trivial ``s``).\n\n    .. versionadded:: 2.0.0\n\nReturns\n-------\nout : complex ndarray\n    The truncated or zero-padded input, transformed along the axes\n    indicated by `axes`, or the last two axes if `axes` is not given.\n\nRaises\n------\nValueError\n    If `s` and `axes` have different length, or `axes` not given and\n    ``len(s) != 2``.\nIndexError\n    If an element of `axes` is larger than than the number of axes of `a`.\n\nSee Also\n--------\nnumpy.fft : Overall view of discrete Fourier transforms, with definitions\n     and conventions used.\nfft2 : The forward 2-dimensional FFT, of which `ifft2` is the inverse.\nifftn : The inverse of the *n*-dimensional FFT.\nfft : The one-dimensional FFT.\nifft : The one-dimensional inverse FFT.\n\nNotes\n-----\n`ifft2` is just `ifftn` with a different default for `axes`.\n\nSee `ifftn` for details and a plotting example, and `numpy.fft` for\ndefinition and conventions used.\n\nZero-padding, analogously with `ifft`, is performed by appending zeros to\nthe input along the specified dimension.  Although this is the common\napproach, it might lead to surprising results.  If another form of zero\npadding is desired, it must be performed before `ifft2` is called.\n\nExamples\n--------\n>>> import numpy as np\n>>> a = 4 * np.eye(4)\n>>> np.fft.ifft2(a)\narray([[1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j], # may vary\n       [0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j],\n       [0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],\n       [0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]])"
    },
    {
      "name": "rfftn",
      "docstring": "Compute the N-dimensional discrete Fourier Transform for real input.\n\nThis function computes the N-dimensional discrete Fourier Transform over\nany number of axes in an M-dimensional real array by means of the Fast\nFourier Transform (FFT).  By default, all axes are transformed, with the\nreal transform performed over the last axis, while the remaining\ntransforms are complex.\n\nParameters\n----------\na : array_like\n    Input array, taken to be real.\ns : sequence of ints, optional\n    Shape (length along each transformed axis) to use from the input.\n    (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.).\n    The final element of `s` corresponds to `n` for ``rfft(x, n)``, while\n    for the remaining axes, it corresponds to `n` for ``fft(x, n)``.\n    Along any axis, if the given shape is smaller than that of the input,\n    the input is cropped. If it is larger, the input is padded with zeros.\n\n    .. versionchanged:: 2.0\n\n        If it is ``-1``, the whole input is used (no padding/trimming).\n\n    If `s` is not given, the shape of the input along the axes specified\n    by `axes` is used.\n\n    .. deprecated:: 2.0\n\n        If `s` is not ``None``, `axes` must not be ``None`` either.\n\n    .. deprecated:: 2.0\n\n        `s` must contain only ``int`` s, not ``None`` values. ``None``\n        values currently mean that the default value for ``n`` is used\n        in the corresponding 1-D transform, but this behaviour is\n        deprecated.\n\naxes : sequence of ints, optional\n    Axes over which to compute the FFT.  If not given, the last ``len(s)``\n    axes are used, or all axes if `s` is also not specified.\n\n    .. deprecated:: 2.0\n\n        If `s` is specified, the corresponding `axes` to be transformed\n        must be explicitly specified too.\n\nnorm : {\"backward\", \"ortho\", \"forward\"}, optional\n    Normalization mode (see `numpy.fft`). Default is \"backward\".\n    Indicates which direction of the forward/backward pair of transforms\n    is scaled and with what normalization factor.\n\n    .. versionadded:: 1.20.0\n\n        The \"backward\", \"forward\" values were added.\n\nout : complex ndarray, optional\n    If provided, the result will be placed in this array. It should be\n    of the appropriate shape and dtype for all axes (and hence is\n    incompatible with passing in all but the trivial ``s``).\n\n    .. versionadded:: 2.0.0\n\nReturns\n-------\nout : complex ndarray\n    The truncated or zero-padded input, transformed along the axes\n    indicated by `axes`, or by a combination of `s` and `a`,\n    as explained in the parameters section above.\n    The length of the last axis transformed will be ``s[-1]//2+1``,\n    while the remaining transformed axes will have lengths according to\n    `s`, or unchanged from the input.\n\nRaises\n------\nValueError\n    If `s` and `axes` have different length.\nIndexError\n    If an element of `axes` is larger than than the number of axes of `a`.\n\nSee Also\n--------\nirfftn : The inverse of `rfftn`, i.e. the inverse of the n-dimensional FFT\n     of real input.\nfft : The one-dimensional FFT, with definitions and conventions used.\nrfft : The one-dimensional FFT of real input.\nfftn : The n-dimensional FFT.\nrfft2 : The two-dimensional FFT of real input.\n\nNotes\n-----\nThe transform for real input is performed over the last transformation\naxis, as by `rfft`, then the transform over the remaining axes is\nperformed as by `fftn`.  The order of the output is as for `rfft` for the\nfinal transformation axis, and as for `fftn` for the remaining\ntransformation axes.\n\nSee `fft` for details, definitions and conventions used.\n\nExamples\n--------\n>>> import numpy as np\n>>> a = np.ones((2, 2, 2))\n>>> np.fft.rfftn(a)\narray([[[8.+0.j,  0.+0.j], # may vary\n        [0.+0.j,  0.+0.j]],\n       [[0.+0.j,  0.+0.j],\n        [0.+0.j,  0.+0.j]]])\n\n>>> np.fft.rfftn(a, axes=(2, 0))\narray([[[4.+0.j,  0.+0.j], # may vary\n        [4.+0.j,  0.+0.j]],\n       [[0.+0.j,  0.+0.j],\n        [0.+0.j,  0.+0.j]]])"
    },
    {
      "name": "rfft2",
      "docstring": "Compute the 2-dimensional FFT of a real array.\n\nParameters\n----------\na : array\n    Input array, taken to be real.\ns : sequence of ints, optional\n    Shape of the FFT.\n\n    .. versionchanged:: 2.0\n\n        If it is ``-1``, the whole input is used (no padding/trimming).\n\n    .. deprecated:: 2.0\n\n        If `s` is not ``None``, `axes` must not be ``None`` either.\n\n    .. deprecated:: 2.0\n\n        `s` must contain only ``int`` s, not ``None`` values. ``None``\n        values currently mean that the default value for ``n`` is used\n        in the corresponding 1-D transform, but this behaviour is\n        deprecated.\n\naxes : sequence of ints, optional\n    Axes over which to compute the FFT. Default: ``(-2, -1)``.\n\n    .. deprecated:: 2.0\n\n        If `s` is specified, the corresponding `axes` to be transformed\n        must not be ``None``.\n\nnorm : {\"backward\", \"ortho\", \"forward\"}, optional\n    Normalization mode (see `numpy.fft`). Default is \"backward\".\n    Indicates which direction of the forward/backward pair of transforms\n    is scaled and with what normalization factor.\n\n    .. versionadded:: 1.20.0\n\n        The \"backward\", \"forward\" values were added.\n\nout : complex ndarray, optional\n    If provided, the result will be placed in this array. It should be\n    of the appropriate shape and dtype for the last inverse transform.\n    incompatible with passing in all but the trivial ``s``).\n\n    .. versionadded:: 2.0.0\n\nReturns\n-------\nout : ndarray\n    The result of the real 2-D FFT.\n\nSee Also\n--------\nrfftn : Compute the N-dimensional discrete Fourier Transform for real\n        input.\n\nNotes\n-----\nThis is really just `rfftn` with different default behavior.\nFor more details see `rfftn`.\n\nExamples\n--------\n>>> import numpy as np\n>>> a = np.mgrid[:5, :5][0]\n>>> np.fft.rfft2(a)\narray([[ 50.  +0.j        ,   0.  +0.j        ,   0.  +0.j        ],\n       [-12.5+17.20477401j,   0.  +0.j        ,   0.  +0.j        ],\n       [-12.5 +4.0614962j ,   0.  +0.j        ,   0.  +0.j        ],\n       [-12.5 -4.0614962j ,   0.  +0.j        ,   0.  +0.j        ],\n       [-12.5-17.20477401j,   0.  +0.j        ,   0.  +0.j        ]])"
    },
    {
      "name": "irfftn",
      "docstring": "Computes the inverse of `rfftn`.\n\nThis function computes the inverse of the N-dimensional discrete\nFourier Transform for real input over any number of axes in an\nM-dimensional array by means of the Fast Fourier Transform (FFT).  In\nother words, ``irfftn(rfftn(a), a.shape) == a`` to within numerical\naccuracy. (The ``a.shape`` is necessary like ``len(a)`` is for `irfft`,\nand for the same reason.)\n\nThe input should be ordered in the same way as is returned by `rfftn`,\ni.e. as for `irfft` for the final transformation axis, and as for `ifftn`\nalong all the other axes.\n\nParameters\n----------\na : array_like\n    Input array.\ns : sequence of ints, optional\n    Shape (length of each transformed axis) of the output\n    (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.). `s` is also the\n    number of input points used along this axis, except for the last axis,\n    where ``s[-1]//2+1`` points of the input are used.\n    Along any axis, if the shape indicated by `s` is smaller than that of\n    the input, the input is cropped.  If it is larger, the input is padded\n    with zeros.\n\n    .. versionchanged:: 2.0\n\n        If it is ``-1``, the whole input is used (no padding/trimming).\n\n    If `s` is not given, the shape of the input along the axes\n    specified by axes is used. Except for the last axis which is taken to\n    be ``2*(m-1)`` where ``m`` is the length of the input along that axis.\n\n    .. deprecated:: 2.0\n\n        If `s` is not ``None``, `axes` must not be ``None`` either.\n\n    .. deprecated:: 2.0\n\n        `s` must contain only ``int`` s, not ``None`` values. ``None``\n        values currently mean that the default value for ``n`` is used\n        in the corresponding 1-D transform, but this behaviour is\n        deprecated.\n\naxes : sequence of ints, optional\n    Axes over which to compute the inverse FFT. If not given, the last\n    `len(s)` axes are used, or all axes if `s` is also not specified.\n    Repeated indices in `axes` means that the inverse transform over that\n    axis is performed multiple times.\n\n    .. deprecated:: 2.0\n\n        If `s` is specified, the corresponding `axes` to be transformed\n        must be explicitly specified too.\n\nnorm : {\"backward\", \"ortho\", \"forward\"}, optional\n    Normalization mode (see `numpy.fft`). Default is \"backward\".\n    Indicates which direction of the forward/backward pair of transforms\n    is scaled and with what normalization factor.\n\n    .. versionadded:: 1.20.0\n\n        The \"backward\", \"forward\" values were added.\n\nout : ndarray, optional\n    If provided, the result will be placed in this array. It should be\n    of the appropriate shape and dtype for the last transformation.\n\n    .. versionadded:: 2.0.0\n\nReturns\n-------\nout : ndarray\n    The truncated or zero-padded input, transformed along the axes\n    indicated by `axes`, or by a combination of `s` or `a`,\n    as explained in the parameters section above.\n    The length of each transformed axis is as given by the corresponding\n    element of `s`, or the length of the input in every axis except for the\n    last one if `s` is not given.  In the final transformed axis the length\n    of the output when `s` is not given is ``2*(m-1)`` where ``m`` is the\n    length of the final transformed axis of the input.  To get an odd\n    number of output points in the final axis, `s` must be specified.\n\nRaises\n------\nValueError\n    If `s` and `axes` have different length.\nIndexError\n    If an element of `axes` is larger than than the number of axes of `a`.\n\nSee Also\n--------\nrfftn : The forward n-dimensional FFT of real input,\n        of which `ifftn` is the inverse.\nfft : The one-dimensional FFT, with definitions and conventions used.\nirfft : The inverse of the one-dimensional FFT of real input.\nirfft2 : The inverse of the two-dimensional FFT of real input.\n\nNotes\n-----\nSee `fft` for definitions and conventions used.\n\nSee `rfft` for definitions and conventions used for real input.\n\nThe correct interpretation of the hermitian input depends on the shape of\nthe original data, as given by `s`. This is because each input shape could\ncorrespond to either an odd or even length signal. By default, `irfftn`\nassumes an even output length which puts the last entry at the Nyquist\nfrequency; aliasing with its symmetric counterpart. When performing the\nfinal complex to real transform, the last value is thus treated as purely\nreal. To avoid losing information, the correct shape of the real input\n**must** be given.\n\nExamples\n--------\n>>> import numpy as np\n>>> a = np.zeros((3, 2, 2))\n>>> a[0, 0, 0] = 3 * 2 * 2\n>>> np.fft.irfftn(a)\narray([[[1.,  1.],\n        [1.,  1.]],\n       [[1.,  1.],\n        [1.,  1.]],\n       [[1.,  1.],\n        [1.,  1.]]])"
    },
    {
      "name": "irfft2",
      "docstring": "Computes the inverse of `rfft2`.\n\nParameters\n----------\na : array_like\n    The input array\ns : sequence of ints, optional\n    Shape of the real output to the inverse FFT.\n\n    .. versionchanged:: 2.0\n\n        If it is ``-1``, the whole input is used (no padding/trimming).\n\n    .. deprecated:: 2.0\n\n        If `s` is not ``None``, `axes` must not be ``None`` either.\n\n    .. deprecated:: 2.0\n\n        `s` must contain only ``int`` s, not ``None`` values. ``None``\n        values currently mean that the default value for ``n`` is used\n        in the corresponding 1-D transform, but this behaviour is\n        deprecated.\n\naxes : sequence of ints, optional\n    The axes over which to compute the inverse fft.\n    Default: ``(-2, -1)``, the last two axes.\n\n    .. deprecated:: 2.0\n\n        If `s` is specified, the corresponding `axes` to be transformed\n        must not be ``None``.\n\nnorm : {\"backward\", \"ortho\", \"forward\"}, optional\n    Normalization mode (see `numpy.fft`). Default is \"backward\".\n    Indicates which direction of the forward/backward pair of transforms\n    is scaled and with what normalization factor.\n\n    .. versionadded:: 1.20.0\n\n        The \"backward\", \"forward\" values were added.\n\nout : ndarray, optional\n    If provided, the result will be placed in this array. It should be\n    of the appropriate shape and dtype for the last transformation.\n\n    .. versionadded:: 2.0.0\n\nReturns\n-------\nout : ndarray\n    The result of the inverse real 2-D FFT.\n\nSee Also\n--------\nrfft2 : The forward two-dimensional FFT of real input,\n        of which `irfft2` is the inverse.\nrfft : The one-dimensional FFT for real input.\nirfft : The inverse of the one-dimensional FFT of real input.\nirfftn : Compute the inverse of the N-dimensional FFT of real input.\n\nNotes\n-----\nThis is really `irfftn` with different defaults.\nFor more details see `irfftn`.\n\nExamples\n--------\n>>> import numpy as np\n>>> a = np.mgrid[:5, :5][0]\n>>> A = np.fft.rfft2(a)\n>>> np.fft.irfft2(A, s=a.shape)\narray([[0., 0., 0., 0., 0.],\n       [1., 1., 1., 1., 1.],\n       [2., 2., 2., 2., 2.],\n       [3., 3., 3., 3., 3.],\n       [4., 4., 4., 4., 4.]])"
    }
  ],
  "innovations": []
}