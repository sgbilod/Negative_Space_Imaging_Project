{
  "file_path": "c:\\Users\\sgbil\\OneDrive\\Desktop\\Negative_Space_Imaging_Project\\.venv\\Lib\\site-packages\\matplotlib\\bezier.py",
  "classes": [
    {
      "name": "NonIntersectingPathException",
      "docstring": null,
      "methods": []
    },
    {
      "name": "BezierSegment",
      "docstring": "A d-dimensional B\u00e9zier segment.\n\nParameters\n----------\ncontrol_points : (N, d) array\n    Location of the *N* control points.",
      "methods": [
        {
          "name": "__init__",
          "docstring": null
        },
        {
          "name": "point_at_t",
          "docstring": "Evaluate the curve at a single point, returning a tuple of *d* floats."
        },
        {
          "name": "control_points",
          "docstring": "The control points of the curve."
        },
        {
          "name": "dimension",
          "docstring": "The dimension of the curve."
        },
        {
          "name": "degree",
          "docstring": "Degree of the polynomial. One less the number of control points."
        },
        {
          "name": "polynomial_coefficients",
          "docstring": "The polynomial coefficients of the B\u00e9zier curve.\n\n.. warning:: Follows opposite convention from `numpy.polyval`.\n\nReturns\n-------\n(n+1, d) array\n    Coefficients after expanding in polynomial basis, where :math:`n`\n    is the degree of the B\u00e9zier curve and :math:`d` its dimension.\n    These are the numbers (:math:`C_j`) such that the curve can be\n    written :math:`\\sum_{j=0}^n C_j t^j`.\n\nNotes\n-----\nThe coefficients are calculated as\n\n.. math::\n\n    {n \\choose j} \\sum_{i=0}^j (-1)^{i+j} {j \\choose i} P_i\n\nwhere :math:`P_i` are the control points of the curve."
        },
        {
          "name": "axis_aligned_extrema",
          "docstring": "Return the dimension and location of the curve's interior extrema.\n\nThe extrema are the points along the curve where one of its partial\nderivatives is zero.\n\nReturns\n-------\ndims : array of int\n    Index :math:`i` of the partial derivative which is zero at each\n    interior extrema.\ndzeros : array of float\n    Of same size as dims. The :math:`t` such that :math:`d/dx_i B(t) =\n    0`"
        }
      ]
    }
  ],
  "functions": [
    {
      "name": "get_intersection",
      "docstring": "Return the intersection between the line through (*cx1*, *cy1*) at angle\n*t1* and the line through (*cx2*, *cy2*) at angle *t2*."
    },
    {
      "name": "get_normal_points",
      "docstring": "For a line passing through (*cx*, *cy*) and having an angle *t*, return\nlocations of the two points located along its perpendicular line at the\ndistance of *length*."
    },
    {
      "name": "split_de_casteljau",
      "docstring": "Split a B\u00e9zier segment defined by its control points *beta* into two\nseparate segments divided at *t* and return their control points."
    },
    {
      "name": "find_bezier_t_intersecting_with_closedpath",
      "docstring": "Find the intersection of the B\u00e9zier curve with a closed path.\n\nThe intersection point *t* is approximated by two parameters *t0*, *t1*\nsuch that *t0* <= *t* <= *t1*.\n\nSearch starts from *t0* and *t1* and uses a simple bisecting algorithm\ntherefore one of the end points must be inside the path while the other\ndoesn't. The search stops when the distance of the points parametrized by\n*t0* and *t1* gets smaller than the given *tolerance*.\n\nParameters\n----------\nbezier_point_at_t : callable\n    A function returning x, y coordinates of the B\u00e9zier at parameter *t*.\n    It must have the signature::\n\n        bezier_point_at_t(t: float) -> tuple[float, float]\n\ninside_closedpath : callable\n    A function returning True if a given point (x, y) is inside the\n    closed path. It must have the signature::\n\n        inside_closedpath(point: tuple[float, float]) -> bool\n\nt0, t1 : float\n    Start parameters for the search.\n\ntolerance : float\n    Maximal allowed distance between the final points.\n\nReturns\n-------\nt0, t1 : float\n    The B\u00e9zier path parameters."
    },
    {
      "name": "split_bezier_intersecting_with_closedpath",
      "docstring": "Split a B\u00e9zier curve into two at the intersection with a closed path.\n\nParameters\n----------\nbezier : (N, 2) array-like\n    Control points of the B\u00e9zier segment. See `.BezierSegment`.\ninside_closedpath : callable\n    A function returning True if a given point (x, y) is inside the\n    closed path. See also `.find_bezier_t_intersecting_with_closedpath`.\ntolerance : float\n    The tolerance for the intersection. See also\n    `.find_bezier_t_intersecting_with_closedpath`.\n\nReturns\n-------\nleft, right\n    Lists of control points for the two B\u00e9zier segments."
    },
    {
      "name": "split_path_inout",
      "docstring": "Divide a path into two segments at the point where ``inside(x, y)`` becomes\nFalse."
    },
    {
      "name": "inside_circle",
      "docstring": "Return a function that checks whether a point is in a circle with center\n(*cx*, *cy*) and radius *r*.\n\nThe returned function has the signature::\n\n    f(xy: tuple[float, float]) -> bool"
    },
    {
      "name": "get_cos_sin",
      "docstring": null
    },
    {
      "name": "check_if_parallel",
      "docstring": "Check if two lines are parallel.\n\nParameters\n----------\ndx1, dy1, dx2, dy2 : float\n    The gradients *dy*/*dx* of the two lines.\ntolerance : float\n    The angular tolerance in radians up to which the lines are considered\n    parallel.\n\nReturns\n-------\nis_parallel\n    - 1 if two lines are parallel in same direction.\n    - -1 if two lines are parallel in opposite direction.\n    - False otherwise."
    },
    {
      "name": "get_parallels",
      "docstring": "Given the quadratic B\u00e9zier control points *bezier2*, returns\ncontrol points of quadratic B\u00e9zier lines roughly parallel to given\none separated by *width*."
    },
    {
      "name": "find_control_points",
      "docstring": "Find control points of the B\u00e9zier curve passing through (*c1x*, *c1y*),\n(*mmx*, *mmy*), and (*c2x*, *c2y*), at parametric values 0, 0.5, and 1."
    },
    {
      "name": "make_wedged_bezier2",
      "docstring": "Being similar to `get_parallels`, returns control points of two quadratic\nB\u00e9zier lines having a width roughly parallel to given one separated by\n*width*."
    },
    {
      "name": "point_at_t",
      "docstring": "Evaluate the curve at a single point, returning a tuple of *d* floats."
    },
    {
      "name": "control_points",
      "docstring": "The control points of the curve."
    },
    {
      "name": "dimension",
      "docstring": "The dimension of the curve."
    },
    {
      "name": "degree",
      "docstring": "Degree of the polynomial. One less the number of control points."
    },
    {
      "name": "polynomial_coefficients",
      "docstring": "The polynomial coefficients of the B\u00e9zier curve.\n\n.. warning:: Follows opposite convention from `numpy.polyval`.\n\nReturns\n-------\n(n+1, d) array\n    Coefficients after expanding in polynomial basis, where :math:`n`\n    is the degree of the B\u00e9zier curve and :math:`d` its dimension.\n    These are the numbers (:math:`C_j`) such that the curve can be\n    written :math:`\\sum_{j=0}^n C_j t^j`.\n\nNotes\n-----\nThe coefficients are calculated as\n\n.. math::\n\n    {n \\choose j} \\sum_{i=0}^j (-1)^{i+j} {j \\choose i} P_i\n\nwhere :math:`P_i` are the control points of the curve."
    },
    {
      "name": "axis_aligned_extrema",
      "docstring": "Return the dimension and location of the curve's interior extrema.\n\nThe extrema are the points along the curve where one of its partial\nderivatives is zero.\n\nReturns\n-------\ndims : array of int\n    Index :math:`i` of the partial derivative which is zero at each\n    interior extrema.\ndzeros : array of float\n    Of same size as dims. The :math:`t` such that :math:`d/dx_i B(t) =\n    0`"
    }
  ],
  "innovations": []
}