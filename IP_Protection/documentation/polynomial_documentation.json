{
  "file_path": "c:\\Users\\sgbil\\OneDrive\\Desktop\\Negative_Space_Imaging_Project\\.venv\\Lib\\site-packages\\numpy\\polynomial\\polynomial.py",
  "classes": [
    {
      "name": "Polynomial",
      "docstring": "A power series class.\n\nThe Polynomial class provides the standard Python numerical methods\n'+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the\nattributes and methods listed below.\n\nParameters\n----------\ncoef : array_like\n    Polynomial coefficients in order of increasing degree, i.e.,\n    ``(1, 2, 3)`` give ``1 + 2*x + 3*x**2``.\ndomain : (2,) array_like, optional\n    Domain to use. The interval ``[domain[0], domain[1]]`` is mapped\n    to the interval ``[window[0], window[1]]`` by shifting and scaling.\n    The default value is [-1., 1.].\nwindow : (2,) array_like, optional\n    Window, see `domain` for its use. The default value is [-1., 1.].\nsymbol : str, optional\n    Symbol used to represent the independent variable in string\n    representations of the polynomial expression, e.g. for printing.\n    The symbol must be a valid Python identifier. Default value is 'x'.\n\n    .. versionadded:: 1.24",
      "methods": []
    }
  ],
  "functions": [
    {
      "name": "polyline",
      "docstring": "Returns an array representing a linear polynomial.\n\nParameters\n----------\noff, scl : scalars\n    The \"y-intercept\" and \"slope\" of the line, respectively.\n\nReturns\n-------\ny : ndarray\n    This module's representation of the linear polynomial ``off +\n    scl*x``.\n\nSee Also\n--------\nnumpy.polynomial.chebyshev.chebline\nnumpy.polynomial.legendre.legline\nnumpy.polynomial.laguerre.lagline\nnumpy.polynomial.hermite.hermline\nnumpy.polynomial.hermite_e.hermeline\n\nExamples\n--------\n>>> from numpy.polynomial import polynomial as P\n>>> P.polyline(1, -1)\narray([ 1, -1])\n>>> P.polyval(1, P.polyline(1, -1))  # should be 0\n0.0"
    },
    {
      "name": "polyfromroots",
      "docstring": "Generate a monic polynomial with given roots.\n\nReturn the coefficients of the polynomial\n\n.. math:: p(x) = (x - r_0) * (x - r_1) * ... * (x - r_n),\n\nwhere the :math:`r_n` are the roots specified in `roots`.  If a zero has\nmultiplicity n, then it must appear in `roots` n times. For instance,\nif 2 is a root of multiplicity three and 3 is a root of multiplicity 2,\nthen `roots` looks something like [2, 2, 2, 3, 3]. The roots can appear\nin any order.\n\nIf the returned coefficients are `c`, then\n\n.. math:: p(x) = c_0 + c_1 * x + ... +  x^n\n\nThe coefficient of the last term is 1 for monic polynomials in this\nform.\n\nParameters\n----------\nroots : array_like\n    Sequence containing the roots.\n\nReturns\n-------\nout : ndarray\n    1-D array of the polynomial's coefficients If all the roots are\n    real, then `out` is also real, otherwise it is complex.  (see\n    Examples below).\n\nSee Also\n--------\nnumpy.polynomial.chebyshev.chebfromroots\nnumpy.polynomial.legendre.legfromroots\nnumpy.polynomial.laguerre.lagfromroots\nnumpy.polynomial.hermite.hermfromroots\nnumpy.polynomial.hermite_e.hermefromroots\n\nNotes\n-----\nThe coefficients are determined by multiplying together linear factors\nof the form ``(x - r_i)``, i.e.\n\n.. math:: p(x) = (x - r_0) (x - r_1) ... (x - r_n)\n\nwhere ``n == len(roots) - 1``; note that this implies that ``1`` is always\nreturned for :math:`a_n`.\n\nExamples\n--------\n>>> from numpy.polynomial import polynomial as P\n>>> P.polyfromroots((-1,0,1))  # x(x - 1)(x + 1) = x^3 - x\narray([ 0., -1.,  0.,  1.])\n>>> j = complex(0,1)\n>>> P.polyfromroots((-j,j))  # complex returned, though values are real\narray([1.+0.j,  0.+0.j,  1.+0.j])"
    },
    {
      "name": "polyadd",
      "docstring": "Add one polynomial to another.\n\nReturns the sum of two polynomials `c1` + `c2`.  The arguments are\nsequences of coefficients from lowest order term to highest, i.e.,\n[1,2,3] represents the polynomial ``1 + 2*x + 3*x**2``.\n\nParameters\n----------\nc1, c2 : array_like\n    1-D arrays of polynomial coefficients ordered from low to high.\n\nReturns\n-------\nout : ndarray\n    The coefficient array representing their sum.\n\nSee Also\n--------\npolysub, polymulx, polymul, polydiv, polypow\n\nExamples\n--------\n>>> from numpy.polynomial import polynomial as P\n>>> c1 = (1, 2, 3)\n>>> c2 = (3, 2, 1)\n>>> sum = P.polyadd(c1,c2); sum\narray([4.,  4.,  4.])\n>>> P.polyval(2, sum)  # 4 + 4(2) + 4(2**2)\n28.0"
    },
    {
      "name": "polysub",
      "docstring": "Subtract one polynomial from another.\n\nReturns the difference of two polynomials `c1` - `c2`.  The arguments\nare sequences of coefficients from lowest order term to highest, i.e.,\n[1,2,3] represents the polynomial ``1 + 2*x + 3*x**2``.\n\nParameters\n----------\nc1, c2 : array_like\n    1-D arrays of polynomial coefficients ordered from low to\n    high.\n\nReturns\n-------\nout : ndarray\n    Of coefficients representing their difference.\n\nSee Also\n--------\npolyadd, polymulx, polymul, polydiv, polypow\n\nExamples\n--------\n>>> from numpy.polynomial import polynomial as P\n>>> c1 = (1, 2, 3)\n>>> c2 = (3, 2, 1)\n>>> P.polysub(c1,c2)\narray([-2.,  0.,  2.])\n>>> P.polysub(c2, c1)  # -P.polysub(c1,c2)\narray([ 2.,  0., -2.])"
    },
    {
      "name": "polymulx",
      "docstring": "Multiply a polynomial by x.\n\nMultiply the polynomial `c` by x, where x is the independent\nvariable.\n\n\nParameters\n----------\nc : array_like\n    1-D array of polynomial coefficients ordered from low to\n    high.\n\nReturns\n-------\nout : ndarray\n    Array representing the result of the multiplication.\n\nSee Also\n--------\npolyadd, polysub, polymul, polydiv, polypow\n\nExamples\n--------\n>>> from numpy.polynomial import polynomial as P\n>>> c = (1, 2, 3)\n>>> P.polymulx(c)\narray([0., 1., 2., 3.])"
    },
    {
      "name": "polymul",
      "docstring": "Multiply one polynomial by another.\n\nReturns the product of two polynomials `c1` * `c2`.  The arguments are\nsequences of coefficients, from lowest order term to highest, e.g.,\n[1,2,3] represents the polynomial ``1 + 2*x + 3*x**2.``\n\nParameters\n----------\nc1, c2 : array_like\n    1-D arrays of coefficients representing a polynomial, relative to the\n    \"standard\" basis, and ordered from lowest order term to highest.\n\nReturns\n-------\nout : ndarray\n    Of the coefficients of their product.\n\nSee Also\n--------\npolyadd, polysub, polymulx, polydiv, polypow\n\nExamples\n--------\n>>> from numpy.polynomial import polynomial as P\n>>> c1 = (1, 2, 3)\n>>> c2 = (3, 2, 1)\n>>> P.polymul(c1, c2)\narray([  3.,   8.,  14.,   8.,   3.])"
    },
    {
      "name": "polydiv",
      "docstring": "Divide one polynomial by another.\n\nReturns the quotient-with-remainder of two polynomials `c1` / `c2`.\nThe arguments are sequences of coefficients, from lowest order term\nto highest, e.g., [1,2,3] represents ``1 + 2*x + 3*x**2``.\n\nParameters\n----------\nc1, c2 : array_like\n    1-D arrays of polynomial coefficients ordered from low to high.\n\nReturns\n-------\n[quo, rem] : ndarrays\n    Of coefficient series representing the quotient and remainder.\n\nSee Also\n--------\npolyadd, polysub, polymulx, polymul, polypow\n\nExamples\n--------\n>>> from numpy.polynomial import polynomial as P\n>>> c1 = (1, 2, 3)\n>>> c2 = (3, 2, 1)\n>>> P.polydiv(c1, c2)\n(array([3.]), array([-8., -4.]))\n>>> P.polydiv(c2, c1)\n(array([ 0.33333333]), array([ 2.66666667,  1.33333333]))  # may vary"
    },
    {
      "name": "polypow",
      "docstring": "Raise a polynomial to a power.\n\nReturns the polynomial `c` raised to the power `pow`. The argument\n`c` is a sequence of coefficients ordered from low to high. i.e.,\n[1,2,3] is the series  ``1 + 2*x + 3*x**2.``\n\nParameters\n----------\nc : array_like\n    1-D array of array of series coefficients ordered from low to\n    high degree.\npow : integer\n    Power to which the series will be raised\nmaxpower : integer, optional\n    Maximum power allowed. This is mainly to limit growth of the series\n    to unmanageable size. Default is 16\n\nReturns\n-------\ncoef : ndarray\n    Power series of power.\n\nSee Also\n--------\npolyadd, polysub, polymulx, polymul, polydiv\n\nExamples\n--------\n>>> from numpy.polynomial import polynomial as P\n>>> P.polypow([1, 2, 3], 2)\narray([ 1., 4., 10., 12., 9.])"
    },
    {
      "name": "polyder",
      "docstring": "Differentiate a polynomial.\n\nReturns the polynomial coefficients `c` differentiated `m` times along\n`axis`.  At each iteration the result is multiplied by `scl` (the\nscaling factor is for use in a linear change of variable).  The\nargument `c` is an array of coefficients from low to high degree along\neach axis, e.g., [1,2,3] represents the polynomial ``1 + 2*x + 3*x**2``\nwhile [[1,2],[1,2]] represents ``1 + 1*x + 2*y + 2*x*y`` if axis=0 is\n``x`` and axis=1 is ``y``.\n\nParameters\n----------\nc : array_like\n    Array of polynomial coefficients. If c is multidimensional the\n    different axis correspond to different variables with the degree\n    in each axis given by the corresponding index.\nm : int, optional\n    Number of derivatives taken, must be non-negative. (Default: 1)\nscl : scalar, optional\n    Each differentiation is multiplied by `scl`.  The end result is\n    multiplication by ``scl**m``.  This is for use in a linear change\n    of variable. (Default: 1)\naxis : int, optional\n    Axis over which the derivative is taken. (Default: 0).\n\nReturns\n-------\nder : ndarray\n    Polynomial coefficients of the derivative.\n\nSee Also\n--------\npolyint\n\nExamples\n--------\n>>> from numpy.polynomial import polynomial as P\n>>> c = (1, 2, 3, 4)\n>>> P.polyder(c)  # (d/dx)(c)\narray([  2.,   6.,  12.])\n>>> P.polyder(c, 3)  # (d**3/dx**3)(c)\narray([24.])\n>>> P.polyder(c, scl=-1)  # (d/d(-x))(c)\narray([ -2.,  -6., -12.])\n>>> P.polyder(c, 2, -1)  # (d**2/d(-x)**2)(c)\narray([  6.,  24.])"
    },
    {
      "name": "polyint",
      "docstring": "Integrate a polynomial.\n\nReturns the polynomial coefficients `c` integrated `m` times from\n`lbnd` along `axis`.  At each iteration the resulting series is\n**multiplied** by `scl` and an integration constant, `k`, is added.\nThe scaling factor is for use in a linear change of variable.  (\"Buyer\nbeware\": note that, depending on what one is doing, one may want `scl`\nto be the reciprocal of what one might expect; for more information,\nsee the Notes section below.) The argument `c` is an array of\ncoefficients, from low to high degree along each axis, e.g., [1,2,3]\nrepresents the polynomial ``1 + 2*x + 3*x**2`` while [[1,2],[1,2]]\nrepresents ``1 + 1*x + 2*y + 2*x*y`` if axis=0 is ``x`` and axis=1 is\n``y``.\n\nParameters\n----------\nc : array_like\n    1-D array of polynomial coefficients, ordered from low to high.\nm : int, optional\n    Order of integration, must be positive. (Default: 1)\nk : {[], list, scalar}, optional\n    Integration constant(s).  The value of the first integral at zero\n    is the first value in the list, the value of the second integral\n    at zero is the second value, etc.  If ``k == []`` (the default),\n    all constants are set to zero.  If ``m == 1``, a single scalar can\n    be given instead of a list.\nlbnd : scalar, optional\n    The lower bound of the integral. (Default: 0)\nscl : scalar, optional\n    Following each integration the result is *multiplied* by `scl`\n    before the integration constant is added. (Default: 1)\naxis : int, optional\n    Axis over which the integral is taken. (Default: 0).\n\nReturns\n-------\nS : ndarray\n    Coefficient array of the integral.\n\nRaises\n------\nValueError\n    If ``m < 1``, ``len(k) > m``, ``np.ndim(lbnd) != 0``, or\n    ``np.ndim(scl) != 0``.\n\nSee Also\n--------\npolyder\n\nNotes\n-----\nNote that the result of each integration is *multiplied* by `scl`.  Why\nis this important to note?  Say one is making a linear change of\nvariable :math:`u = ax + b` in an integral relative to `x`. Then\n:math:`dx = du/a`, so one will need to set `scl` equal to\n:math:`1/a` - perhaps not what one would have first thought.\n\nExamples\n--------\n>>> from numpy.polynomial import polynomial as P\n>>> c = (1, 2, 3)\n>>> P.polyint(c)  # should return array([0, 1, 1, 1])\narray([0.,  1.,  1.,  1.])\n>>> P.polyint(c, 3)  # should return array([0, 0, 0, 1/6, 1/12, 1/20])\n array([ 0.        ,  0.        ,  0.        ,  0.16666667,  0.08333333, # may vary\n         0.05      ])\n>>> P.polyint(c, k=3)  # should return array([3, 1, 1, 1])\narray([3.,  1.,  1.,  1.])\n>>> P.polyint(c,lbnd=-2)  # should return array([6, 1, 1, 1])\narray([6.,  1.,  1.,  1.])\n>>> P.polyint(c,scl=-2)  # should return array([0, -2, -2, -2])\narray([ 0., -2., -2., -2.])"
    },
    {
      "name": "polyval",
      "docstring": "Evaluate a polynomial at points x.\n\nIf `c` is of length ``n + 1``, this function returns the value\n\n.. math:: p(x) = c_0 + c_1 * x + ... + c_n * x^n\n\nThe parameter `x` is converted to an array only if it is a tuple or a\nlist, otherwise it is treated as a scalar. In either case, either `x`\nor its elements must support multiplication and addition both with\nthemselves and with the elements of `c`.\n\nIf `c` is a 1-D array, then ``p(x)`` will have the same shape as `x`.  If\n`c` is multidimensional, then the shape of the result depends on the\nvalue of `tensor`. If `tensor` is true the shape will be c.shape[1:] +\nx.shape. If `tensor` is false the shape will be c.shape[1:]. Note that\nscalars have shape (,).\n\nTrailing zeros in the coefficients will be used in the evaluation, so\nthey should be avoided if efficiency is a concern.\n\nParameters\n----------\nx : array_like, compatible object\n    If `x` is a list or tuple, it is converted to an ndarray, otherwise\n    it is left unchanged and treated as a scalar. In either case, `x`\n    or its elements must support addition and multiplication with\n    with themselves and with the elements of `c`.\nc : array_like\n    Array of coefficients ordered so that the coefficients for terms of\n    degree n are contained in c[n]. If `c` is multidimensional the\n    remaining indices enumerate multiple polynomials. In the two\n    dimensional case the coefficients may be thought of as stored in\n    the columns of `c`.\ntensor : boolean, optional\n    If True, the shape of the coefficient array is extended with ones\n    on the right, one for each dimension of `x`. Scalars have dimension 0\n    for this action. The result is that every column of coefficients in\n    `c` is evaluated for every element of `x`. If False, `x` is broadcast\n    over the columns of `c` for the evaluation.  This keyword is useful\n    when `c` is multidimensional. The default value is True.\n\nReturns\n-------\nvalues : ndarray, compatible object\n    The shape of the returned array is described above.\n\nSee Also\n--------\npolyval2d, polygrid2d, polyval3d, polygrid3d\n\nNotes\n-----\nThe evaluation uses Horner's method.\n\nExamples\n--------\n>>> import numpy as np\n>>> from numpy.polynomial.polynomial import polyval\n>>> polyval(1, [1,2,3])\n6.0\n>>> a = np.arange(4).reshape(2,2)\n>>> a\narray([[0, 1],\n       [2, 3]])\n>>> polyval(a, [1, 2, 3])\narray([[ 1.,   6.],\n       [17.,  34.]])\n>>> coef = np.arange(4).reshape(2, 2)  # multidimensional coefficients\n>>> coef\narray([[0, 1],\n       [2, 3]])\n>>> polyval([1, 2], coef, tensor=True)\narray([[2.,  4.],\n       [4.,  7.]])\n>>> polyval([1, 2], coef, tensor=False)\narray([2.,  7.])"
    },
    {
      "name": "polyvalfromroots",
      "docstring": "Evaluate a polynomial specified by its roots at points x.\n\nIf `r` is of length ``N``, this function returns the value\n\n.. math:: p(x) = \\prod_{n=1}^{N} (x - r_n)\n\nThe parameter `x` is converted to an array only if it is a tuple or a\nlist, otherwise it is treated as a scalar. In either case, either `x`\nor its elements must support multiplication and addition both with\nthemselves and with the elements of `r`.\n\nIf `r` is a 1-D array, then ``p(x)`` will have the same shape as `x`.  If `r`\nis multidimensional, then the shape of the result depends on the value of\n`tensor`. If `tensor` is ``True`` the shape will be r.shape[1:] + x.shape;\nthat is, each polynomial is evaluated at every value of `x`. If `tensor` is\n``False``, the shape will be r.shape[1:]; that is, each polynomial is\nevaluated only for the corresponding broadcast value of `x`. Note that\nscalars have shape (,).\n\nParameters\n----------\nx : array_like, compatible object\n    If `x` is a list or tuple, it is converted to an ndarray, otherwise\n    it is left unchanged and treated as a scalar. In either case, `x`\n    or its elements must support addition and multiplication with\n    with themselves and with the elements of `r`.\nr : array_like\n    Array of roots. If `r` is multidimensional the first index is the\n    root index, while the remaining indices enumerate multiple\n    polynomials. For instance, in the two dimensional case the roots\n    of each polynomial may be thought of as stored in the columns of `r`.\ntensor : boolean, optional\n    If True, the shape of the roots array is extended with ones on the\n    right, one for each dimension of `x`. Scalars have dimension 0 for this\n    action. The result is that every column of coefficients in `r` is\n    evaluated for every element of `x`. If False, `x` is broadcast over the\n    columns of `r` for the evaluation.  This keyword is useful when `r` is\n    multidimensional. The default value is True.\n\nReturns\n-------\nvalues : ndarray, compatible object\n    The shape of the returned array is described above.\n\nSee Also\n--------\npolyroots, polyfromroots, polyval\n\nExamples\n--------\n>>> from numpy.polynomial.polynomial import polyvalfromroots\n>>> polyvalfromroots(1, [1, 2, 3])\n0.0\n>>> a = np.arange(4).reshape(2, 2)\n>>> a\narray([[0, 1],\n       [2, 3]])\n>>> polyvalfromroots(a, [-1, 0, 1])\narray([[-0.,   0.],\n       [ 6.,  24.]])\n>>> r = np.arange(-2, 2).reshape(2,2)  # multidimensional coefficients\n>>> r # each column of r defines one polynomial\narray([[-2, -1],\n       [ 0,  1]])\n>>> b = [-2, 1]\n>>> polyvalfromroots(b, r, tensor=True)\narray([[-0.,  3.],\n       [ 3., 0.]])\n>>> polyvalfromroots(b, r, tensor=False)\narray([-0.,  0.])"
    },
    {
      "name": "polyval2d",
      "docstring": "Evaluate a 2-D polynomial at points (x, y).\n\nThis function returns the value\n\n.. math:: p(x,y) = \\sum_{i,j} c_{i,j} * x^i * y^j\n\nThe parameters `x` and `y` are converted to arrays only if they are\ntuples or a lists, otherwise they are treated as a scalars and they\nmust have the same shape after conversion. In either case, either `x`\nand `y` or their elements must support multiplication and addition both\nwith themselves and with the elements of `c`.\n\nIf `c` has fewer than two dimensions, ones are implicitly appended to\nits shape to make it 2-D. The shape of the result will be c.shape[2:] +\nx.shape.\n\nParameters\n----------\nx, y : array_like, compatible objects\n    The two dimensional series is evaluated at the points ``(x, y)``,\n    where `x` and `y` must have the same shape. If `x` or `y` is a list\n    or tuple, it is first converted to an ndarray, otherwise it is left\n    unchanged and, if it isn't an ndarray, it is treated as a scalar.\nc : array_like\n    Array of coefficients ordered so that the coefficient of the term\n    of multi-degree i,j is contained in ``c[i,j]``. If `c` has\n    dimension greater than two the remaining indices enumerate multiple\n    sets of coefficients.\n\nReturns\n-------\nvalues : ndarray, compatible object\n    The values of the two dimensional polynomial at points formed with\n    pairs of corresponding values from `x` and `y`.\n\nSee Also\n--------\npolyval, polygrid2d, polyval3d, polygrid3d\n\nExamples\n--------\n>>> from numpy.polynomial import polynomial as P\n>>> c = ((1, 2, 3), (4, 5, 6))\n>>> P.polyval2d(1, 1, c)\n21.0"
    },
    {
      "name": "polygrid2d",
      "docstring": "Evaluate a 2-D polynomial on the Cartesian product of x and y.\n\nThis function returns the values:\n\n.. math:: p(a,b) = \\sum_{i,j} c_{i,j} * a^i * b^j\n\nwhere the points ``(a, b)`` consist of all pairs formed by taking\n`a` from `x` and `b` from `y`. The resulting points form a grid with\n`x` in the first dimension and `y` in the second.\n\nThe parameters `x` and `y` are converted to arrays only if they are\ntuples or a lists, otherwise they are treated as a scalars. In either\ncase, either `x` and `y` or their elements must support multiplication\nand addition both with themselves and with the elements of `c`.\n\nIf `c` has fewer than two dimensions, ones are implicitly appended to\nits shape to make it 2-D. The shape of the result will be c.shape[2:] +\nx.shape + y.shape.\n\nParameters\n----------\nx, y : array_like, compatible objects\n    The two dimensional series is evaluated at the points in the\n    Cartesian product of `x` and `y`.  If `x` or `y` is a list or\n    tuple, it is first converted to an ndarray, otherwise it is left\n    unchanged and, if it isn't an ndarray, it is treated as a scalar.\nc : array_like\n    Array of coefficients ordered so that the coefficients for terms of\n    degree i,j are contained in ``c[i,j]``. If `c` has dimension\n    greater than two the remaining indices enumerate multiple sets of\n    coefficients.\n\nReturns\n-------\nvalues : ndarray, compatible object\n    The values of the two dimensional polynomial at points in the Cartesian\n    product of `x` and `y`.\n\nSee Also\n--------\npolyval, polyval2d, polyval3d, polygrid3d\n\nExamples\n--------\n>>> from numpy.polynomial import polynomial as P\n>>> c = ((1, 2, 3), (4, 5, 6))\n>>> P.polygrid2d([0, 1], [0, 1], c)\narray([[ 1.,  6.],\n       [ 5., 21.]])"
    },
    {
      "name": "polyval3d",
      "docstring": "Evaluate a 3-D polynomial at points (x, y, z).\n\nThis function returns the values:\n\n.. math:: p(x,y,z) = \\sum_{i,j,k} c_{i,j,k} * x^i * y^j * z^k\n\nThe parameters `x`, `y`, and `z` are converted to arrays only if\nthey are tuples or a lists, otherwise they are treated as a scalars and\nthey must have the same shape after conversion. In either case, either\n`x`, `y`, and `z` or their elements must support multiplication and\naddition both with themselves and with the elements of `c`.\n\nIf `c` has fewer than 3 dimensions, ones are implicitly appended to its\nshape to make it 3-D. The shape of the result will be c.shape[3:] +\nx.shape.\n\nParameters\n----------\nx, y, z : array_like, compatible object\n    The three dimensional series is evaluated at the points\n    ``(x, y, z)``, where `x`, `y`, and `z` must have the same shape.  If\n    any of `x`, `y`, or `z` is a list or tuple, it is first converted\n    to an ndarray, otherwise it is left unchanged and if it isn't an\n    ndarray it is  treated as a scalar.\nc : array_like\n    Array of coefficients ordered so that the coefficient of the term of\n    multi-degree i,j,k is contained in ``c[i,j,k]``. If `c` has dimension\n    greater than 3 the remaining indices enumerate multiple sets of\n    coefficients.\n\nReturns\n-------\nvalues : ndarray, compatible object\n    The values of the multidimensional polynomial on points formed with\n    triples of corresponding values from `x`, `y`, and `z`.\n\nSee Also\n--------\npolyval, polyval2d, polygrid2d, polygrid3d\n\nExamples\n--------\n>>> from numpy.polynomial import polynomial as P\n>>> c = ((1, 2, 3), (4, 5, 6), (7, 8, 9))\n>>> P.polyval3d(1, 1, 1, c)\n45.0"
    },
    {
      "name": "polygrid3d",
      "docstring": "Evaluate a 3-D polynomial on the Cartesian product of x, y and z.\n\nThis function returns the values:\n\n.. math:: p(a,b,c) = \\sum_{i,j,k} c_{i,j,k} * a^i * b^j * c^k\n\nwhere the points ``(a, b, c)`` consist of all triples formed by taking\n`a` from `x`, `b` from `y`, and `c` from `z`. The resulting points form\na grid with `x` in the first dimension, `y` in the second, and `z` in\nthe third.\n\nThe parameters `x`, `y`, and `z` are converted to arrays only if they\nare tuples or a lists, otherwise they are treated as a scalars. In\neither case, either `x`, `y`, and `z` or their elements must support\nmultiplication and addition both with themselves and with the elements\nof `c`.\n\nIf `c` has fewer than three dimensions, ones are implicitly appended to\nits shape to make it 3-D. The shape of the result will be c.shape[3:] +\nx.shape + y.shape + z.shape.\n\nParameters\n----------\nx, y, z : array_like, compatible objects\n    The three dimensional series is evaluated at the points in the\n    Cartesian product of `x`, `y`, and `z`.  If `x`, `y`, or `z` is a\n    list or tuple, it is first converted to an ndarray, otherwise it is\n    left unchanged and, if it isn't an ndarray, it is treated as a\n    scalar.\nc : array_like\n    Array of coefficients ordered so that the coefficients for terms of\n    degree i,j are contained in ``c[i,j]``. If `c` has dimension\n    greater than two the remaining indices enumerate multiple sets of\n    coefficients.\n\nReturns\n-------\nvalues : ndarray, compatible object\n    The values of the two dimensional polynomial at points in the Cartesian\n    product of `x` and `y`.\n\nSee Also\n--------\npolyval, polyval2d, polygrid2d, polyval3d\n\nExamples\n--------\n>>> from numpy.polynomial import polynomial as P\n>>> c = ((1, 2, 3), (4, 5, 6), (7, 8, 9))\n>>> P.polygrid3d([0, 1], [0, 1], [0, 1], c)\narray([[ 1., 13.],\n       [ 6., 51.]])"
    },
    {
      "name": "polyvander",
      "docstring": "Vandermonde matrix of given degree.\n\nReturns the Vandermonde matrix of degree `deg` and sample points\n`x`. The Vandermonde matrix is defined by\n\n.. math:: V[..., i] = x^i,\n\nwhere ``0 <= i <= deg``. The leading indices of `V` index the elements of\n`x` and the last index is the power of `x`.\n\nIf `c` is a 1-D array of coefficients of length ``n + 1`` and `V` is the\nmatrix ``V = polyvander(x, n)``, then ``np.dot(V, c)`` and\n``polyval(x, c)`` are the same up to roundoff. This equivalence is\nuseful both for least squares fitting and for the evaluation of a large\nnumber of polynomials of the same degree and sample points.\n\nParameters\n----------\nx : array_like\n    Array of points. The dtype is converted to float64 or complex128\n    depending on whether any of the elements are complex. If `x` is\n    scalar it is converted to a 1-D array.\ndeg : int\n    Degree of the resulting matrix.\n\nReturns\n-------\nvander : ndarray.\n    The Vandermonde matrix. The shape of the returned matrix is\n    ``x.shape + (deg + 1,)``, where the last index is the power of `x`.\n    The dtype will be the same as the converted `x`.\n\nSee Also\n--------\npolyvander2d, polyvander3d\n\nExamples\n--------\nThe Vandermonde matrix of degree ``deg = 5`` and sample points\n``x = [-1, 2, 3]`` contains the element-wise powers of `x`\nfrom 0 to 5 as its columns.\n\n>>> from numpy.polynomial import polynomial as P\n>>> x, deg = [-1, 2, 3], 5\n>>> P.polyvander(x=x, deg=deg)\narray([[  1.,  -1.,   1.,  -1.,   1.,  -1.],\n       [  1.,   2.,   4.,   8.,  16.,  32.],\n       [  1.,   3.,   9.,  27.,  81., 243.]])"
    },
    {
      "name": "polyvander2d",
      "docstring": "Pseudo-Vandermonde matrix of given degrees.\n\nReturns the pseudo-Vandermonde matrix of degrees `deg` and sample\npoints ``(x, y)``. The pseudo-Vandermonde matrix is defined by\n\n.. math:: V[..., (deg[1] + 1)*i + j] = x^i * y^j,\n\nwhere ``0 <= i <= deg[0]`` and ``0 <= j <= deg[1]``. The leading indices of\n`V` index the points ``(x, y)`` and the last index encodes the powers of\n`x` and `y`.\n\nIf ``V = polyvander2d(x, y, [xdeg, ydeg])``, then the columns of `V`\ncorrespond to the elements of a 2-D coefficient array `c` of shape\n(xdeg + 1, ydeg + 1) in the order\n\n.. math:: c_{00}, c_{01}, c_{02} ... , c_{10}, c_{11}, c_{12} ...\n\nand ``np.dot(V, c.flat)`` and ``polyval2d(x, y, c)`` will be the same\nup to roundoff. This equivalence is useful both for least squares\nfitting and for the evaluation of a large number of 2-D polynomials\nof the same degrees and sample points.\n\nParameters\n----------\nx, y : array_like\n    Arrays of point coordinates, all of the same shape. The dtypes\n    will be converted to either float64 or complex128 depending on\n    whether any of the elements are complex. Scalars are converted to\n    1-D arrays.\ndeg : list of ints\n    List of maximum degrees of the form [x_deg, y_deg].\n\nReturns\n-------\nvander2d : ndarray\n    The shape of the returned matrix is ``x.shape + (order,)``, where\n    :math:`order = (deg[0]+1)*(deg([1]+1)`.  The dtype will be the same\n    as the converted `x` and `y`.\n\nSee Also\n--------\npolyvander, polyvander3d, polyval2d, polyval3d\n\nExamples\n--------\n>>> import numpy as np\n\nThe 2-D pseudo-Vandermonde matrix of degree ``[1, 2]`` and sample\npoints ``x = [-1, 2]`` and ``y = [1, 3]`` is as follows:\n\n>>> from numpy.polynomial import polynomial as P\n>>> x = np.array([-1, 2])\n>>> y = np.array([1, 3])\n>>> m, n = 1, 2\n>>> deg = np.array([m, n])\n>>> V = P.polyvander2d(x=x, y=y, deg=deg)\n>>> V\narray([[ 1.,  1.,  1., -1., -1., -1.],\n       [ 1.,  3.,  9.,  2.,  6., 18.]])\n\nWe can verify the columns for any ``0 <= i <= m`` and ``0 <= j <= n``:\n\n>>> i, j = 0, 1\n>>> V[:, (deg[1]+1)*i + j] == x**i * y**j\narray([ True,  True])\n\nThe (1D) Vandermonde matrix of sample points ``x`` and degree ``m`` is a\nspecial case of the (2D) pseudo-Vandermonde matrix with ``y`` points all\nzero and degree ``[m, 0]``.\n\n>>> P.polyvander2d(x=x, y=0*x, deg=(m, 0)) == P.polyvander(x=x, deg=m)\narray([[ True,  True],\n       [ True,  True]])"
    },
    {
      "name": "polyvander3d",
      "docstring": "Pseudo-Vandermonde matrix of given degrees.\n\nReturns the pseudo-Vandermonde matrix of degrees `deg` and sample\npoints ``(x, y, z)``. If `l`, `m`, `n` are the given degrees in `x`, `y`, `z`,\nthen The pseudo-Vandermonde matrix is defined by\n\n.. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = x^i * y^j * z^k,\n\nwhere ``0 <= i <= l``, ``0 <= j <= m``, and ``0 <= j <= n``.  The leading\nindices of `V` index the points ``(x, y, z)`` and the last index encodes\nthe powers of `x`, `y`, and `z`.\n\nIf ``V = polyvander3d(x, y, z, [xdeg, ydeg, zdeg])``, then the columns\nof `V` correspond to the elements of a 3-D coefficient array `c` of\nshape (xdeg + 1, ydeg + 1, zdeg + 1) in the order\n\n.. math:: c_{000}, c_{001}, c_{002},... , c_{010}, c_{011}, c_{012},...\n\nand  ``np.dot(V, c.flat)`` and ``polyval3d(x, y, z, c)`` will be the\nsame up to roundoff. This equivalence is useful both for least squares\nfitting and for the evaluation of a large number of 3-D polynomials\nof the same degrees and sample points.\n\nParameters\n----------\nx, y, z : array_like\n    Arrays of point coordinates, all of the same shape. The dtypes will\n    be converted to either float64 or complex128 depending on whether\n    any of the elements are complex. Scalars are converted to 1-D\n    arrays.\ndeg : list of ints\n    List of maximum degrees of the form [x_deg, y_deg, z_deg].\n\nReturns\n-------\nvander3d : ndarray\n    The shape of the returned matrix is ``x.shape + (order,)``, where\n    :math:`order = (deg[0]+1)*(deg([1]+1)*(deg[2]+1)`.  The dtype will\n    be the same as the converted `x`, `y`, and `z`.\n\nSee Also\n--------\npolyvander, polyvander3d, polyval2d, polyval3d\n\nExamples\n--------\n>>> import numpy as np\n>>> from numpy.polynomial import polynomial as P\n>>> x = np.asarray([-1, 2, 1])\n>>> y = np.asarray([1, -2, -3])\n>>> z = np.asarray([2, 2, 5])\n>>> l, m, n = [2, 2, 1]\n>>> deg = [l, m, n]\n>>> V = P.polyvander3d(x=x, y=y, z=z, deg=deg)\n>>> V\narray([[  1.,   2.,   1.,   2.,   1.,   2.,  -1.,  -2.,  -1.,\n         -2.,  -1.,  -2.,   1.,   2.,   1.,   2.,   1.,   2.],\n       [  1.,   2.,  -2.,  -4.,   4.,   8.,   2.,   4.,  -4.,\n         -8.,   8.,  16.,   4.,   8.,  -8., -16.,  16.,  32.],\n       [  1.,   5.,  -3., -15.,   9.,  45.,   1.,   5.,  -3.,\n        -15.,   9.,  45.,   1.,   5.,  -3., -15.,   9.,  45.]])\n\nWe can verify the columns for any ``0 <= i <= l``, ``0 <= j <= m``,\nand ``0 <= k <= n``\n\n>>> i, j, k = 2, 1, 0\n>>> V[:, (m+1)*(n+1)*i + (n+1)*j + k] == x**i * y**j * z**k\narray([ True,  True,  True])"
    },
    {
      "name": "polyfit",
      "docstring": "Least-squares fit of a polynomial to data.\n\nReturn the coefficients of a polynomial of degree `deg` that is the\nleast squares fit to the data values `y` given at points `x`. If `y` is\n1-D the returned coefficients will also be 1-D. If `y` is 2-D multiple\nfits are done, one for each column of `y`, and the resulting\ncoefficients are stored in the corresponding columns of a 2-D return.\nThe fitted polynomial(s) are in the form\n\n.. math::  p(x) = c_0 + c_1 * x + ... + c_n * x^n,\n\nwhere `n` is `deg`.\n\nParameters\n----------\nx : array_like, shape (`M`,)\n    x-coordinates of the `M` sample (data) points ``(x[i], y[i])``.\ny : array_like, shape (`M`,) or (`M`, `K`)\n    y-coordinates of the sample points.  Several sets of sample points\n    sharing the same x-coordinates can be (independently) fit with one\n    call to `polyfit` by passing in for `y` a 2-D array that contains\n    one data set per column.\ndeg : int or 1-D array_like\n    Degree(s) of the fitting polynomials. If `deg` is a single integer\n    all terms up to and including the `deg`'th term are included in the\n    fit. For NumPy versions >= 1.11.0 a list of integers specifying the\n    degrees of the terms to include may be used instead.\nrcond : float, optional\n    Relative condition number of the fit.  Singular values smaller\n    than `rcond`, relative to the largest singular value, will be\n    ignored.  The default value is ``len(x)*eps``, where `eps` is the\n    relative precision of the platform's float type, about 2e-16 in\n    most cases.\nfull : bool, optional\n    Switch determining the nature of the return value.  When ``False``\n    (the default) just the coefficients are returned; when ``True``,\n    diagnostic information from the singular value decomposition (used\n    to solve the fit's matrix equation) is also returned.\nw : array_like, shape (`M`,), optional\n    Weights. If not None, the weight ``w[i]`` applies to the unsquared\n    residual ``y[i] - y_hat[i]`` at ``x[i]``. Ideally the weights are\n    chosen so that the errors of the products ``w[i]*y[i]`` all have the\n    same variance.  When using inverse-variance weighting, use\n    ``w[i] = 1/sigma(y[i])``.  The default value is None.\n\nReturns\n-------\ncoef : ndarray, shape (`deg` + 1,) or (`deg` + 1, `K`)\n    Polynomial coefficients ordered from low to high.  If `y` was 2-D,\n    the coefficients in column `k` of `coef` represent the polynomial\n    fit to the data in `y`'s `k`-th column.\n\n[residuals, rank, singular_values, rcond] : list\n    These values are only returned if ``full == True``\n\n    - residuals -- sum of squared residuals of the least squares fit\n    - rank -- the numerical rank of the scaled Vandermonde matrix\n    - singular_values -- singular values of the scaled Vandermonde matrix\n    - rcond -- value of `rcond`.\n\n    For more details, see `numpy.linalg.lstsq`.\n\nRaises\n------\nRankWarning\n    Raised if the matrix in the least-squares fit is rank deficient.\n    The warning is only raised if ``full == False``.  The warnings can\n    be turned off by:\n\n    >>> import warnings\n    >>> warnings.simplefilter('ignore', np.exceptions.RankWarning)\n\nSee Also\n--------\nnumpy.polynomial.chebyshev.chebfit\nnumpy.polynomial.legendre.legfit\nnumpy.polynomial.laguerre.lagfit\nnumpy.polynomial.hermite.hermfit\nnumpy.polynomial.hermite_e.hermefit\npolyval : Evaluates a polynomial.\npolyvander : Vandermonde matrix for powers.\nnumpy.linalg.lstsq : Computes a least-squares fit from the matrix.\nscipy.interpolate.UnivariateSpline : Computes spline fits.\n\nNotes\n-----\nThe solution is the coefficients of the polynomial `p` that minimizes\nthe sum of the weighted squared errors\n\n.. math:: E = \\sum_j w_j^2 * |y_j - p(x_j)|^2,\n\nwhere the :math:`w_j` are the weights. This problem is solved by\nsetting up the (typically) over-determined matrix equation:\n\n.. math:: V(x) * c = w * y,\n\nwhere `V` is the weighted pseudo Vandermonde matrix of `x`, `c` are the\ncoefficients to be solved for, `w` are the weights, and `y` are the\nobserved values.  This equation is then solved using the singular value\ndecomposition of `V`.\n\nIf some of the singular values of `V` are so small that they are\nneglected (and `full` == ``False``), a `~exceptions.RankWarning` will be\nraised.  This means that the coefficient values may be poorly determined.\nFitting to a lower order polynomial will usually get rid of the warning\n(but may not be what you want, of course; if you have independent\nreason(s) for choosing the degree which isn't working, you may have to:\na) reconsider those reasons, and/or b) reconsider the quality of your\ndata).  The `rcond` parameter can also be set to a value smaller than\nits default, but the resulting fit may be spurious and have large\ncontributions from roundoff error.\n\nPolynomial fits using double precision tend to \"fail\" at about\n(polynomial) degree 20. Fits using Chebyshev or Legendre series are\ngenerally better conditioned, but much can still depend on the\ndistribution of the sample points and the smoothness of the data.  If\nthe quality of the fit is inadequate, splines may be a good\nalternative.\n\nExamples\n--------\n>>> import numpy as np\n>>> from numpy.polynomial import polynomial as P\n>>> x = np.linspace(-1,1,51)  # x \"data\": [-1, -0.96, ..., 0.96, 1]\n>>> rng = np.random.default_rng()\n>>> err = rng.normal(size=len(x))\n>>> y = x**3 - x + err  # x^3 - x + Gaussian noise\n>>> c, stats = P.polyfit(x,y,3,full=True)\n>>> c # c[0], c[1] approx. -1, c[2] should be approx. 0, c[3] approx. 1\narray([ 0.23111996, -1.02785049, -0.2241444 ,  1.08405657]) # may vary\n>>> stats # note the large SSR, explaining the rather poor results\n[array([48.312088]),                                        # may vary\n 4,\n array([1.38446749, 1.32119158, 0.50443316, 0.28853036]),\n 1.1324274851176597e-14]\n\nSame thing without the added noise\n\n>>> y = x**3 - x\n>>> c, stats = P.polyfit(x,y,3,full=True)\n>>> c # c[0], c[1] ~= -1, c[2] should be \"very close to 0\", c[3] ~= 1\narray([-6.73496154e-17, -1.00000000e+00,  0.00000000e+00,  1.00000000e+00])\n>>> stats # note the minuscule SSR\n[array([8.79579319e-31]),\n np.int32(4),\n array([1.38446749, 1.32119158, 0.50443316, 0.28853036]),\n 1.1324274851176597e-14]"
    },
    {
      "name": "polycompanion",
      "docstring": "Return the companion matrix of c.\n\nThe companion matrix for power series cannot be made symmetric by\nscaling the basis, so this function differs from those for the\northogonal polynomials.\n\nParameters\n----------\nc : array_like\n    1-D array of polynomial coefficients ordered from low to high\n    degree.\n\nReturns\n-------\nmat : ndarray\n    Companion matrix of dimensions (deg, deg).\n\nExamples\n--------\n>>> from numpy.polynomial import polynomial as P\n>>> c = (1, 2, 3)\n>>> P.polycompanion(c)\narray([[ 0.        , -0.33333333],\n       [ 1.        , -0.66666667]])"
    },
    {
      "name": "polyroots",
      "docstring": "Compute the roots of a polynomial.\n\nReturn the roots (a.k.a. \"zeros\") of the polynomial\n\n.. math:: p(x) = \\sum_i c[i] * x^i.\n\nParameters\n----------\nc : 1-D array_like\n    1-D array of polynomial coefficients.\n\nReturns\n-------\nout : ndarray\n    Array of the roots of the polynomial. If all the roots are real,\n    then `out` is also real, otherwise it is complex.\n\nSee Also\n--------\nnumpy.polynomial.chebyshev.chebroots\nnumpy.polynomial.legendre.legroots\nnumpy.polynomial.laguerre.lagroots\nnumpy.polynomial.hermite.hermroots\nnumpy.polynomial.hermite_e.hermeroots\n\nNotes\n-----\nThe root estimates are obtained as the eigenvalues of the companion\nmatrix, Roots far from the origin of the complex plane may have large\nerrors due to the numerical instability of the power series for such\nvalues. Roots with multiplicity greater than 1 will also show larger\nerrors as the value of the series near such points is relatively\ninsensitive to errors in the roots. Isolated roots near the origin can\nbe improved by a few iterations of Newton's method.\n\nExamples\n--------\n>>> import numpy.polynomial.polynomial as poly\n>>> poly.polyroots(poly.polyfromroots((-1,0,1)))\narray([-1.,  0.,  1.])\n>>> poly.polyroots(poly.polyfromroots((-1,0,1))).dtype\ndtype('float64')\n>>> j = complex(0,1)\n>>> poly.polyroots(poly.polyfromroots((-j,0,j)))\narray([  0.00000000e+00+0.j,   0.00000000e+00+1.j,   2.77555756e-17-1.j])  # may vary"
    }
  ],
  "innovations": []
}