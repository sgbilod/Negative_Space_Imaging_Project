{
  "file_path": "c:\\Users\\sgbil\\OneDrive\\Desktop\\Negative_Space_Imaging_Project\\.venv\\Lib\\site-packages\\numpy\\lib\\_scimath_impl.py",
  "classes": [],
  "functions": [
    {
      "name": "sqrt",
      "docstring": "Compute the square root of x.\n\nFor negative input elements, a complex value is returned\n(unlike `numpy.sqrt` which returns NaN).\n\nParameters\n----------\nx : array_like\n   The input value(s).\n\nReturns\n-------\nout : ndarray or scalar\n   The square root of `x`. If `x` was a scalar, so is `out`,\n   otherwise an array is returned.\n\nSee Also\n--------\nnumpy.sqrt\n\nExamples\n--------\nFor real, non-negative inputs this works just like `numpy.sqrt`:\n\n>>> import numpy as np\n\n>>> np.emath.sqrt(1)\n1.0\n>>> np.emath.sqrt([1, 4])\narray([1.,  2.])\n\nBut it automatically handles negative inputs:\n\n>>> np.emath.sqrt(-1)\n1j\n>>> np.emath.sqrt([-1,4])\narray([0.+1.j, 2.+0.j])\n\nDifferent results are expected because:\nfloating point 0.0 and -0.0 are distinct.\n\nFor more control, explicitly use complex() as follows:\n\n>>> np.emath.sqrt(complex(-4.0, 0.0))\n2j\n>>> np.emath.sqrt(complex(-4.0, -0.0))\n-2j"
    },
    {
      "name": "log",
      "docstring": "Compute the natural logarithm of `x`.\n\nReturn the \"principal value\" (for a description of this, see `numpy.log`)\nof :math:`log_e(x)`. For real `x > 0`, this is a real number (``log(0)``\nreturns ``-inf`` and ``log(np.inf)`` returns ``inf``). Otherwise, the\ncomplex principle value is returned.\n\nParameters\n----------\nx : array_like\n   The value(s) whose log is (are) required.\n\nReturns\n-------\nout : ndarray or scalar\n   The log of the `x` value(s). If `x` was a scalar, so is `out`,\n   otherwise an array is returned.\n\nSee Also\n--------\nnumpy.log\n\nNotes\n-----\nFor a log() that returns ``NAN`` when real `x < 0`, use `numpy.log`\n(note, however, that otherwise `numpy.log` and this `log` are identical,\ni.e., both return ``-inf`` for `x = 0`, ``inf`` for `x = inf`, and,\nnotably, the complex principle value if ``x.imag != 0``).\n\nExamples\n--------\n>>> import numpy as np\n>>> np.emath.log(np.exp(1))\n1.0\n\nNegative arguments are handled \"correctly\" (recall that\n``exp(log(x)) == x`` does *not* hold for real ``x < 0``):\n\n>>> np.emath.log(-np.exp(1)) == (1 + np.pi * 1j)\nTrue"
    },
    {
      "name": "log10",
      "docstring": "Compute the logarithm base 10 of `x`.\n\nReturn the \"principal value\" (for a description of this, see\n`numpy.log10`) of :math:`log_{10}(x)`. For real `x > 0`, this\nis a real number (``log10(0)`` returns ``-inf`` and ``log10(np.inf)``\nreturns ``inf``). Otherwise, the complex principle value is returned.\n\nParameters\n----------\nx : array_like or scalar\n   The value(s) whose log base 10 is (are) required.\n\nReturns\n-------\nout : ndarray or scalar\n   The log base 10 of the `x` value(s). If `x` was a scalar, so is `out`,\n   otherwise an array object is returned.\n\nSee Also\n--------\nnumpy.log10\n\nNotes\n-----\nFor a log10() that returns ``NAN`` when real `x < 0`, use `numpy.log10`\n(note, however, that otherwise `numpy.log10` and this `log10` are\nidentical, i.e., both return ``-inf`` for `x = 0`, ``inf`` for `x = inf`,\nand, notably, the complex principle value if ``x.imag != 0``).\n\nExamples\n--------\n>>> import numpy as np\n\n(We set the printing precision so the example can be auto-tested)\n\n>>> np.set_printoptions(precision=4)\n\n>>> np.emath.log10(10**1)\n1.0\n\n>>> np.emath.log10([-10**1, -10**2, 10**2])\narray([1.+1.3644j, 2.+1.3644j, 2.+0.j    ])"
    },
    {
      "name": "logn",
      "docstring": "Take log base n of x.\n\nIf `x` contains negative inputs, the answer is computed and returned in the\ncomplex domain.\n\nParameters\n----------\nn : array_like\n   The integer base(s) in which the log is taken.\nx : array_like\n   The value(s) whose log base `n` is (are) required.\n\nReturns\n-------\nout : ndarray or scalar\n   The log base `n` of the `x` value(s). If `x` was a scalar, so is\n   `out`, otherwise an array is returned.\n\nExamples\n--------\n>>> import numpy as np\n>>> np.set_printoptions(precision=4)\n\n>>> np.emath.logn(2, [4, 8])\narray([2., 3.])\n>>> np.emath.logn(2, [-4, -8, 8])\narray([2.+4.5324j, 3.+4.5324j, 3.+0.j    ])"
    },
    {
      "name": "log2",
      "docstring": "Compute the logarithm base 2 of `x`.\n\nReturn the \"principal value\" (for a description of this, see\n`numpy.log2`) of :math:`log_2(x)`. For real `x > 0`, this is\na real number (``log2(0)`` returns ``-inf`` and ``log2(np.inf)`` returns\n``inf``). Otherwise, the complex principle value is returned.\n\nParameters\n----------\nx : array_like\n   The value(s) whose log base 2 is (are) required.\n\nReturns\n-------\nout : ndarray or scalar\n   The log base 2 of the `x` value(s). If `x` was a scalar, so is `out`,\n   otherwise an array is returned.\n\nSee Also\n--------\nnumpy.log2\n\nNotes\n-----\nFor a log2() that returns ``NAN`` when real `x < 0`, use `numpy.log2`\n(note, however, that otherwise `numpy.log2` and this `log2` are\nidentical, i.e., both return ``-inf`` for `x = 0`, ``inf`` for `x = inf`,\nand, notably, the complex principle value if ``x.imag != 0``).\n\nExamples\n--------\n\nWe set the printing precision so the example can be auto-tested:\n\n>>> np.set_printoptions(precision=4)\n\n>>> np.emath.log2(8)\n3.0\n>>> np.emath.log2([-4, -8, 8])\narray([2.+4.5324j, 3.+4.5324j, 3.+0.j    ])"
    },
    {
      "name": "power",
      "docstring": "Return x to the power p, (x**p).\n\nIf `x` contains negative values, the output is converted to the\ncomplex domain.\n\nParameters\n----------\nx : array_like\n    The input value(s).\np : array_like of ints\n    The power(s) to which `x` is raised. If `x` contains multiple values,\n    `p` has to either be a scalar, or contain the same number of values\n    as `x`. In the latter case, the result is\n    ``x[0]**p[0], x[1]**p[1], ...``.\n\nReturns\n-------\nout : ndarray or scalar\n    The result of ``x**p``. If `x` and `p` are scalars, so is `out`,\n    otherwise an array is returned.\n\nSee Also\n--------\nnumpy.power\n\nExamples\n--------\n>>> import numpy as np\n>>> np.set_printoptions(precision=4)\n\n>>> np.emath.power(2, 2)\n4\n\n>>> np.emath.power([2, 4], 2)\narray([ 4, 16])\n\n>>> np.emath.power([2, 4], -2)\narray([0.25  ,  0.0625])\n\n>>> np.emath.power([-2, 4], 2)\narray([ 4.-0.j, 16.+0.j])\n\n>>> np.emath.power([2, 4], [2, 4])\narray([ 4, 256])"
    },
    {
      "name": "arccos",
      "docstring": "Compute the inverse cosine of x.\n\nReturn the \"principal value\" (for a description of this, see\n`numpy.arccos`) of the inverse cosine of `x`. For real `x` such that\n`abs(x) <= 1`, this is a real number in the closed interval\n:math:`[0, \\pi]`.  Otherwise, the complex principle value is returned.\n\nParameters\n----------\nx : array_like or scalar\n   The value(s) whose arccos is (are) required.\n\nReturns\n-------\nout : ndarray or scalar\n   The inverse cosine(s) of the `x` value(s). If `x` was a scalar, so\n   is `out`, otherwise an array object is returned.\n\nSee Also\n--------\nnumpy.arccos\n\nNotes\n-----\nFor an arccos() that returns ``NAN`` when real `x` is not in the\ninterval ``[-1,1]``, use `numpy.arccos`.\n\nExamples\n--------\n>>> import numpy as np\n>>> np.set_printoptions(precision=4)\n\n>>> np.emath.arccos(1) # a scalar is returned\n0.0\n\n>>> np.emath.arccos([1,2])\narray([0.-0.j   , 0.-1.317j])"
    },
    {
      "name": "arcsin",
      "docstring": "Compute the inverse sine of x.\n\nReturn the \"principal value\" (for a description of this, see\n`numpy.arcsin`) of the inverse sine of `x`. For real `x` such that\n`abs(x) <= 1`, this is a real number in the closed interval\n:math:`[-\\pi/2, \\pi/2]`.  Otherwise, the complex principle value is\nreturned.\n\nParameters\n----------\nx : array_like or scalar\n   The value(s) whose arcsin is (are) required.\n\nReturns\n-------\nout : ndarray or scalar\n   The inverse sine(s) of the `x` value(s). If `x` was a scalar, so\n   is `out`, otherwise an array object is returned.\n\nSee Also\n--------\nnumpy.arcsin\n\nNotes\n-----\nFor an arcsin() that returns ``NAN`` when real `x` is not in the\ninterval ``[-1,1]``, use `numpy.arcsin`.\n\nExamples\n--------\n>>> import numpy as np\n>>> np.set_printoptions(precision=4)\n\n>>> np.emath.arcsin(0)\n0.0\n\n>>> np.emath.arcsin([0,1])\narray([0.    , 1.5708])"
    },
    {
      "name": "arctanh",
      "docstring": "Compute the inverse hyperbolic tangent of `x`.\n\nReturn the \"principal value\" (for a description of this, see\n`numpy.arctanh`) of ``arctanh(x)``. For real `x` such that\n``abs(x) < 1``, this is a real number.  If `abs(x) > 1`, or if `x` is\ncomplex, the result is complex. Finally, `x = 1` returns``inf`` and\n``x=-1`` returns ``-inf``.\n\nParameters\n----------\nx : array_like\n   The value(s) whose arctanh is (are) required.\n\nReturns\n-------\nout : ndarray or scalar\n   The inverse hyperbolic tangent(s) of the `x` value(s). If `x` was\n   a scalar so is `out`, otherwise an array is returned.\n\n\nSee Also\n--------\nnumpy.arctanh\n\nNotes\n-----\nFor an arctanh() that returns ``NAN`` when real `x` is not in the\ninterval ``(-1,1)``, use `numpy.arctanh` (this latter, however, does\nreturn +/-inf for ``x = +/-1``).\n\nExamples\n--------\n>>> import numpy as np\n>>> np.set_printoptions(precision=4)\n\n>>> np.emath.arctanh(0.5)\n0.5493061443340549\n\n>>> from numpy.testing import suppress_warnings\n>>> with suppress_warnings() as sup:\n...     sup.filter(RuntimeWarning)\n...     np.emath.arctanh(np.eye(2))\narray([[inf,  0.],\n       [ 0., inf]])\n>>> np.emath.arctanh([1j])\narray([0.+0.7854j])"
    }
  ],
  "innovations": []
}