{
  "file_path": "c:\\Users\\sgbil\\OneDrive\\Desktop\\Negative_Space_Imaging_Project\\.venv\\Lib\\site-packages\\numpy\\lib\\mixins.py",
  "classes": [
    {
      "name": "NDArrayOperatorsMixin",
      "docstring": "Mixin defining all operator special methods using __array_ufunc__.\n\nThis class implements the special methods for almost all of Python's\nbuiltin operators defined in the `operator` module, including comparisons\n(``==``, ``>``, etc.) and arithmetic (``+``, ``*``, ``-``, etc.), by\ndeferring to the ``__array_ufunc__`` method, which subclasses must\nimplement.\n\nIt is useful for writing classes that do not inherit from `numpy.ndarray`,\nbut that should support arithmetic and numpy universal functions like\narrays as described in `A Mechanism for Overriding Ufuncs\n<https://numpy.org/neps/nep-0013-ufunc-overrides.html>`_.\n\nAs an trivial example, consider this implementation of an ``ArrayLike``\nclass that simply wraps a NumPy array and ensures that the result of any\narithmetic operation is also an ``ArrayLike`` object:\n\n    >>> import numbers\n    >>> class ArrayLike(np.lib.mixins.NDArrayOperatorsMixin):\n    ...     def __init__(self, value):\n    ...         self.value = np.asarray(value)\n    ...\n    ...     # One might also consider adding the built-in list type to this\n    ...     # list, to support operations like np.add(array_like, list)\n    ...     _HANDLED_TYPES = (np.ndarray, numbers.Number)\n    ...\n    ...     def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):\n    ...         out = kwargs.get('out', ())\n    ...         for x in inputs + out:\n    ...             # Only support operations with instances of\n    ...             # _HANDLED_TYPES. Use ArrayLike instead of type(self)\n    ...             # for isinstance to allow subclasses that don't\n    ...             # override __array_ufunc__ to handle ArrayLike objects.\n    ...             if not isinstance(\n    ...                 x, self._HANDLED_TYPES + (ArrayLike,)\n    ...             ):\n    ...                 return NotImplemented\n    ...\n    ...         # Defer to the implementation of the ufunc\n    ...         # on unwrapped values.\n    ...         inputs = tuple(x.value if isinstance(x, ArrayLike) else x\n    ...                     for x in inputs)\n    ...         if out:\n    ...             kwargs['out'] = tuple(\n    ...                 x.value if isinstance(x, ArrayLike) else x\n    ...                 for x in out)\n    ...         result = getattr(ufunc, method)(*inputs, **kwargs)\n    ...\n    ...         if type(result) is tuple:\n    ...             # multiple return values\n    ...             return tuple(type(self)(x) for x in result)\n    ...         elif method == 'at':\n    ...             # no return value\n    ...             return None\n    ...         else:\n    ...             # one return value\n    ...             return type(self)(result)\n    ...\n    ...     def __repr__(self):\n    ...         return '%s(%r)' % (type(self).__name__, self.value)\n\nIn interactions between ``ArrayLike`` objects and numbers or numpy arrays,\nthe result is always another ``ArrayLike``:\n\n    >>> x = ArrayLike([1, 2, 3])\n    >>> x - 1\n    ArrayLike(array([0, 1, 2]))\n    >>> 1 - x\n    ArrayLike(array([ 0, -1, -2]))\n    >>> np.arange(3) - x\n    ArrayLike(array([-1, -1, -1]))\n    >>> x - np.arange(3)\n    ArrayLike(array([1, 1, 1]))\n\nNote that unlike ``numpy.ndarray``, ``ArrayLike`` does not allow operations\nwith arbitrary, unrecognized types. This ensures that interactions with\nArrayLike preserve a well-defined casting hierarchy.",
      "methods": []
    }
  ],
  "functions": [
    {
      "name": "func",
      "docstring": null
    },
    {
      "name": "func",
      "docstring": null
    },
    {
      "name": "func",
      "docstring": null
    },
    {
      "name": "func",
      "docstring": null
    }
  ],
  "innovations": []
}