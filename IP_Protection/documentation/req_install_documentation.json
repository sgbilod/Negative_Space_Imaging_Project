{
  "file_path": "c:\\Users\\sgbil\\OneDrive\\Desktop\\Negative_Space_Imaging_Project\\.venv\\Lib\\site-packages\\pip\\_internal\\req\\req_install.py",
  "classes": [
    {
      "name": "InstallRequirement",
      "docstring": "Represents something that may be installed later on, may have information\nabout where to fetch the relevant requirement and also contains logic for\ninstalling the said requirement.",
      "methods": [
        {
          "name": "__init__",
          "docstring": null
        },
        {
          "name": "format_debug",
          "docstring": "An un-tested helper for getting state, for debugging."
        },
        {
          "name": "name",
          "docstring": null
        },
        {
          "name": "supports_pyproject_editable",
          "docstring": null
        },
        {
          "name": "specifier",
          "docstring": null
        },
        {
          "name": "is_direct",
          "docstring": "Whether this requirement was specified as a direct URL."
        },
        {
          "name": "is_pinned",
          "docstring": "Return whether I am pinned to an exact version.\n\nFor example, some-package==1.2 is pinned; some-package>1.2 is not."
        },
        {
          "name": "match_markers",
          "docstring": null
        },
        {
          "name": "has_hash_options",
          "docstring": "Return whether any known-good hashes are specified as options.\n\nThese activate --require-hashes mode; hashes specified as part of a\nURL do not."
        },
        {
          "name": "hashes",
          "docstring": "Return a hash-comparer that considers my option- and URL-based\nhashes to be known-good.\n\nHashes in URLs--ones embedded in the requirements file, not ones\ndownloaded from an index server--are almost peers with ones from\nflags. They satisfy --require-hashes (whether it was implicitly or\nexplicitly activated) but do not activate it. md5 and sha224 are not\nallowed in flags, which should nudge people toward good algos. We\nalways OR all hashes together, even ones from URLs.\n\n:param trust_internet: Whether to trust URL-based (#md5=...) hashes\n    downloaded from the internet, as by populate_link()"
        },
        {
          "name": "from_path",
          "docstring": "Format a nice indicator to show where this \"comes from\" "
        },
        {
          "name": "ensure_build_location",
          "docstring": null
        },
        {
          "name": "warn_on_mismatching_name",
          "docstring": null
        },
        {
          "name": "check_if_exists",
          "docstring": "Find an installed distribution that satisfies or conflicts\nwith this requirement, and set self.satisfied_by or\nself.should_reinstall appropriately."
        },
        {
          "name": "is_wheel",
          "docstring": null
        },
        {
          "name": "is_wheel_from_cache",
          "docstring": null
        },
        {
          "name": "unpacked_source_directory",
          "docstring": null
        },
        {
          "name": "setup_py_path",
          "docstring": null
        },
        {
          "name": "setup_cfg_path",
          "docstring": null
        },
        {
          "name": "pyproject_toml_path",
          "docstring": null
        },
        {
          "name": "load_pyproject_toml",
          "docstring": "Load the pyproject.toml file.\n\nAfter calling this routine, all of the attributes related to PEP 517\nprocessing for this requirement have been set. In particular, the\nuse_pep517 attribute can be used to determine whether we should\nfollow the PEP 517 or legacy (setup.py) code path."
        },
        {
          "name": "isolated_editable_sanity_check",
          "docstring": "Check that an editable requirement if valid for use with PEP 517/518.\n\nThis verifies that an editable that has a pyproject.toml either supports PEP 660\nor as a setup.py or a setup.cfg"
        },
        {
          "name": "prepare_metadata",
          "docstring": "Ensure that project metadata is available.\n\nUnder PEP 517 and PEP 660, call the backend hook to prepare the metadata.\nUnder legacy processing, call setup.py egg-info."
        },
        {
          "name": "metadata",
          "docstring": null
        },
        {
          "name": "get_dist",
          "docstring": null
        },
        {
          "name": "assert_source_matches_version",
          "docstring": null
        },
        {
          "name": "ensure_has_source_dir",
          "docstring": "Ensure that a source_dir is set.\n\nThis will create a temporary build dir if the name of the requirement\nisn't known yet.\n\n:param parent_dir: The ideal pip parent_dir for the source_dir.\n    Generally src_dir for editables and build_dir for sdists.\n:return: self.source_dir"
        },
        {
          "name": "needs_unpacked_archive",
          "docstring": null
        },
        {
          "name": "ensure_pristine_source_checkout",
          "docstring": "Ensure the source directory has not yet been built in."
        },
        {
          "name": "update_editable",
          "docstring": null
        },
        {
          "name": "uninstall",
          "docstring": "Uninstall the distribution currently satisfying this requirement.\n\nPrompts before removing or modifying files unless\n``auto_confirm`` is True.\n\nRefuses to delete or modify files outside of ``sys.prefix`` -\nthus uninstallation within a virtual environment can only\nmodify that virtual environment, even if the virtualenv is\nlinked to global site-packages."
        },
        {
          "name": "archive",
          "docstring": "Saves archive to provided build_dir.\n\nUsed for saving downloaded VCS requirements as part of `pip download`."
        },
        {
          "name": "install",
          "docstring": null
        }
      ]
    }
  ],
  "functions": [
    {
      "name": "check_invalid_constraint_type",
      "docstring": null
    },
    {
      "name": "check_legacy_setup_py_options",
      "docstring": null
    },
    {
      "name": "format_debug",
      "docstring": "An un-tested helper for getting state, for debugging."
    },
    {
      "name": "name",
      "docstring": null
    },
    {
      "name": "supports_pyproject_editable",
      "docstring": null
    },
    {
      "name": "specifier",
      "docstring": null
    },
    {
      "name": "is_direct",
      "docstring": "Whether this requirement was specified as a direct URL."
    },
    {
      "name": "is_pinned",
      "docstring": "Return whether I am pinned to an exact version.\n\nFor example, some-package==1.2 is pinned; some-package>1.2 is not."
    },
    {
      "name": "match_markers",
      "docstring": null
    },
    {
      "name": "has_hash_options",
      "docstring": "Return whether any known-good hashes are specified as options.\n\nThese activate --require-hashes mode; hashes specified as part of a\nURL do not."
    },
    {
      "name": "hashes",
      "docstring": "Return a hash-comparer that considers my option- and URL-based\nhashes to be known-good.\n\nHashes in URLs--ones embedded in the requirements file, not ones\ndownloaded from an index server--are almost peers with ones from\nflags. They satisfy --require-hashes (whether it was implicitly or\nexplicitly activated) but do not activate it. md5 and sha224 are not\nallowed in flags, which should nudge people toward good algos. We\nalways OR all hashes together, even ones from URLs.\n\n:param trust_internet: Whether to trust URL-based (#md5=...) hashes\n    downloaded from the internet, as by populate_link()"
    },
    {
      "name": "from_path",
      "docstring": "Format a nice indicator to show where this \"comes from\" "
    },
    {
      "name": "ensure_build_location",
      "docstring": null
    },
    {
      "name": "warn_on_mismatching_name",
      "docstring": null
    },
    {
      "name": "check_if_exists",
      "docstring": "Find an installed distribution that satisfies or conflicts\nwith this requirement, and set self.satisfied_by or\nself.should_reinstall appropriately."
    },
    {
      "name": "is_wheel",
      "docstring": null
    },
    {
      "name": "is_wheel_from_cache",
      "docstring": null
    },
    {
      "name": "unpacked_source_directory",
      "docstring": null
    },
    {
      "name": "setup_py_path",
      "docstring": null
    },
    {
      "name": "setup_cfg_path",
      "docstring": null
    },
    {
      "name": "pyproject_toml_path",
      "docstring": null
    },
    {
      "name": "load_pyproject_toml",
      "docstring": "Load the pyproject.toml file.\n\nAfter calling this routine, all of the attributes related to PEP 517\nprocessing for this requirement have been set. In particular, the\nuse_pep517 attribute can be used to determine whether we should\nfollow the PEP 517 or legacy (setup.py) code path."
    },
    {
      "name": "isolated_editable_sanity_check",
      "docstring": "Check that an editable requirement if valid for use with PEP 517/518.\n\nThis verifies that an editable that has a pyproject.toml either supports PEP 660\nor as a setup.py or a setup.cfg"
    },
    {
      "name": "prepare_metadata",
      "docstring": "Ensure that project metadata is available.\n\nUnder PEP 517 and PEP 660, call the backend hook to prepare the metadata.\nUnder legacy processing, call setup.py egg-info."
    },
    {
      "name": "metadata",
      "docstring": null
    },
    {
      "name": "get_dist",
      "docstring": null
    },
    {
      "name": "assert_source_matches_version",
      "docstring": null
    },
    {
      "name": "ensure_has_source_dir",
      "docstring": "Ensure that a source_dir is set.\n\nThis will create a temporary build dir if the name of the requirement\nisn't known yet.\n\n:param parent_dir: The ideal pip parent_dir for the source_dir.\n    Generally src_dir for editables and build_dir for sdists.\n:return: self.source_dir"
    },
    {
      "name": "needs_unpacked_archive",
      "docstring": null
    },
    {
      "name": "ensure_pristine_source_checkout",
      "docstring": "Ensure the source directory has not yet been built in."
    },
    {
      "name": "update_editable",
      "docstring": null
    },
    {
      "name": "uninstall",
      "docstring": "Uninstall the distribution currently satisfying this requirement.\n\nPrompts before removing or modifying files unless\n``auto_confirm`` is True.\n\nRefuses to delete or modify files outside of ``sys.prefix`` -\nthus uninstallation within a virtual environment can only\nmodify that virtual environment, even if the virtualenv is\nlinked to global site-packages."
    },
    {
      "name": "archive",
      "docstring": "Saves archive to provided build_dir.\n\nUsed for saving downloaded VCS requirements as part of `pip download`."
    },
    {
      "name": "install",
      "docstring": null
    }
  ],
  "innovations": []
}