{
  "file_path": "c:\\Users\\sgbil\\OneDrive\\Desktop\\Negative_Space_Imaging_Project\\.venv\\Lib\\site-packages\\numpy\\_core\\_ufunc_config.py",
  "classes": [
    {
      "name": "_unspecified",
      "docstring": null,
      "methods": []
    },
    {
      "name": "errstate",
      "docstring": "errstate(**kwargs)\n\nContext manager for floating-point error handling.\n\nUsing an instance of `errstate` as a context manager allows statements in\nthat context to execute with a known error handling behavior. Upon entering\nthe context the error handling is set with `seterr` and `seterrcall`, and\nupon exiting it is reset to what it was before.\n\n..  versionchanged:: 1.17.0\n    `errstate` is also usable as a function decorator, saving\n    a level of indentation if an entire function is wrapped.\n\n.. versionchanged:: 2.0\n    `errstate` is now fully thread and asyncio safe, but may not be\n    entered more than once.\n    It is not safe to decorate async functions using ``errstate``.\n\nParameters\n----------\nkwargs : {divide, over, under, invalid}\n    Keyword arguments. The valid keywords are the possible floating-point\n    exceptions. Each keyword should have a string value that defines the\n    treatment for the particular error. Possible values are\n    {'ignore', 'warn', 'raise', 'call', 'print', 'log'}.\n\nSee Also\n--------\nseterr, geterr, seterrcall, geterrcall\n\nNotes\n-----\nFor complete documentation of the types of floating-point exceptions and\ntreatment options, see `seterr`.\n\nExamples\n--------\n>>> import numpy as np\n>>> olderr = np.seterr(all='ignore')  # Set error handling to known state.\n\n>>> np.arange(3) / 0.\narray([nan, inf, inf])\n>>> with np.errstate(divide='ignore'):\n...     np.arange(3) / 0.\narray([nan, inf, inf])\n\n>>> np.sqrt(-1)\nnp.float64(nan)\n>>> with np.errstate(invalid='raise'):\n...     np.sqrt(-1)\nTraceback (most recent call last):\n  File \"<stdin>\", line 2, in <module>\nFloatingPointError: invalid value encountered in sqrt\n\nOutside the context the error handling behavior has not changed:\n\n>>> np.geterr()\n{'divide': 'ignore', 'over': 'ignore', 'under': 'ignore', 'invalid': 'ignore'}\n>>> olderr = np.seterr(**olderr)  # restore original state",
      "methods": [
        {
          "name": "__init__",
          "docstring": null
        }
      ]
    }
  ],
  "functions": [
    {
      "name": "seterr",
      "docstring": "Set how floating-point errors are handled.\n\nNote that operations on integer scalar types (such as `int16`) are\nhandled like floating point, and are affected by these settings.\n\nParameters\n----------\nall : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n    Set treatment for all types of floating-point errors at once:\n\n    - ignore: Take no action when the exception occurs.\n    - warn: Print a :exc:`RuntimeWarning` (via the Python `warnings`\n      module).\n    - raise: Raise a :exc:`FloatingPointError`.\n    - call: Call a function specified using the `seterrcall` function.\n    - print: Print a warning directly to ``stdout``.\n    - log: Record error in a Log object specified by `seterrcall`.\n\n    The default is not to change the current behavior.\ndivide : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n    Treatment for division by zero.\nover : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n    Treatment for floating-point overflow.\nunder : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n    Treatment for floating-point underflow.\ninvalid : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n    Treatment for invalid floating-point operation.\n\nReturns\n-------\nold_settings : dict\n    Dictionary containing the old settings.\n\nSee also\n--------\nseterrcall : Set a callback function for the 'call' mode.\ngeterr, geterrcall, errstate\n\nNotes\n-----\nThe floating-point exceptions are defined in the IEEE 754 standard [1]_:\n\n- Division by zero: infinite result obtained from finite numbers.\n- Overflow: result too large to be expressed.\n- Underflow: result so close to zero that some precision\n  was lost.\n- Invalid operation: result is not an expressible number, typically\n  indicates that a NaN was produced.\n\n.. [1] https://en.wikipedia.org/wiki/IEEE_754\n\nExamples\n--------\n>>> import numpy as np\n>>> orig_settings = np.seterr(all='ignore')  # seterr to known value\n>>> np.int16(32000) * np.int16(3)\nnp.int16(30464)\n>>> np.seterr(over='raise')\n{'divide': 'ignore', 'over': 'ignore', 'under': 'ignore', 'invalid': 'ignore'}\n>>> old_settings = np.seterr(all='warn', over='raise')\n>>> np.int16(32000) * np.int16(3)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nFloatingPointError: overflow encountered in scalar multiply\n\n>>> old_settings = np.seterr(all='print')\n>>> np.geterr()\n{'divide': 'print', 'over': 'print', 'under': 'print', 'invalid': 'print'}\n>>> np.int16(32000) * np.int16(3)\nnp.int16(30464)\n>>> np.seterr(**orig_settings)  # restore original\n{'divide': 'print', 'over': 'print', 'under': 'print', 'invalid': 'print'}"
    },
    {
      "name": "geterr",
      "docstring": "Get the current way of handling floating-point errors.\n\nReturns\n-------\nres : dict\n    A dictionary with keys \"divide\", \"over\", \"under\", and \"invalid\",\n    whose values are from the strings \"ignore\", \"print\", \"log\", \"warn\",\n    \"raise\", and \"call\". The keys represent possible floating-point\n    exceptions, and the values define how these exceptions are handled.\n\nSee Also\n--------\ngeterrcall, seterr, seterrcall\n\nNotes\n-----\nFor complete documentation of the types of floating-point exceptions and\ntreatment options, see `seterr`.\n\nExamples\n--------\n>>> import numpy as np\n>>> np.geterr()\n{'divide': 'warn', 'over': 'warn', 'under': 'ignore', 'invalid': 'warn'}\n>>> np.arange(3.) / np.arange(3.)  # doctest: +SKIP\narray([nan,  1.,  1.])\nRuntimeWarning: invalid value encountered in divide\n\n>>> oldsettings = np.seterr(all='warn', invalid='raise')\n>>> np.geterr()\n{'divide': 'warn', 'over': 'warn', 'under': 'warn', 'invalid': 'raise'}\n>>> np.arange(3.) / np.arange(3.)\nTraceback (most recent call last):\n  ...\nFloatingPointError: invalid value encountered in divide\n>>> oldsettings = np.seterr(**oldsettings)  # restore original"
    },
    {
      "name": "setbufsize",
      "docstring": "Set the size of the buffer used in ufuncs.\n\n.. versionchanged:: 2.0\n    The scope of setting the buffer is tied to the `numpy.errstate`\n    context.  Exiting a ``with errstate():`` will also restore the bufsize.\n\nParameters\n----------\nsize : int\n    Size of buffer.\n\nReturns\n-------\nbufsize : int\n    Previous size of ufunc buffer in bytes.\n\nExamples\n--------\nWhen exiting a `numpy.errstate` context manager the bufsize is restored:\n\n>>> import numpy as np\n>>> with np.errstate():\n...     np.setbufsize(4096)\n...     print(np.getbufsize())\n...\n8192\n4096\n>>> np.getbufsize()\n8192"
    },
    {
      "name": "getbufsize",
      "docstring": "Return the size of the buffer used in ufuncs.\n\nReturns\n-------\ngetbufsize : int\n    Size of ufunc buffer in bytes.\n\nExamples\n--------\n>>> import numpy as np\n>>> np.getbufsize()\n8192"
    },
    {
      "name": "seterrcall",
      "docstring": "Set the floating-point error callback function or log object.\n\nThere are two ways to capture floating-point error messages.  The first\nis to set the error-handler to 'call', using `seterr`.  Then, set\nthe function to call using this function.\n\nThe second is to set the error-handler to 'log', using `seterr`.\nFloating-point errors then trigger a call to the 'write' method of\nthe provided object.\n\nParameters\n----------\nfunc : callable f(err, flag) or object with write method\n    Function to call upon floating-point errors ('call'-mode) or\n    object whose 'write' method is used to log such message ('log'-mode).\n\n    The call function takes two arguments. The first is a string describing\n    the type of error (such as \"divide by zero\", \"overflow\", \"underflow\",\n    or \"invalid value\"), and the second is the status flag.  The flag is a\n    byte, whose four least-significant bits indicate the type of error, one\n    of \"divide\", \"over\", \"under\", \"invalid\"::\n\n      [0 0 0 0 divide over under invalid]\n\n    In other words, ``flags = divide + 2*over + 4*under + 8*invalid``.\n\n    If an object is provided, its write method should take one argument,\n    a string.\n\nReturns\n-------\nh : callable, log instance or None\n    The old error handler.\n\nSee Also\n--------\nseterr, geterr, geterrcall\n\nExamples\n--------\nCallback upon error:\n\n>>> def err_handler(type, flag):\n...     print(\"Floating point error (%s), with flag %s\" % (type, flag))\n...\n\n>>> import numpy as np\n\n>>> orig_handler = np.seterrcall(err_handler)\n>>> orig_err = np.seterr(all='call')\n\n>>> np.array([1, 2, 3]) / 0.0\nFloating point error (divide by zero), with flag 1\narray([inf, inf, inf])\n\n>>> np.seterrcall(orig_handler)\n<function err_handler at 0x...>\n>>> np.seterr(**orig_err)\n{'divide': 'call', 'over': 'call', 'under': 'call', 'invalid': 'call'}\n\nLog error message:\n\n>>> class Log:\n...     def write(self, msg):\n...         print(\"LOG: %s\" % msg)\n...\n\n>>> log = Log()\n>>> saved_handler = np.seterrcall(log)\n>>> save_err = np.seterr(all='log')\n\n>>> np.array([1, 2, 3]) / 0.0\nLOG: Warning: divide by zero encountered in divide\narray([inf, inf, inf])\n\n>>> np.seterrcall(orig_handler)\n<numpy.Log object at 0x...>\n>>> np.seterr(**orig_err)\n{'divide': 'log', 'over': 'log', 'under': 'log', 'invalid': 'log'}"
    },
    {
      "name": "geterrcall",
      "docstring": "Return the current callback function used on floating-point errors.\n\nWhen the error handling for a floating-point error (one of \"divide\",\n\"over\", \"under\", or \"invalid\") is set to 'call' or 'log', the function\nthat is called or the log instance that is written to is returned by\n`geterrcall`. This function or log instance has been set with\n`seterrcall`.\n\nReturns\n-------\nerrobj : callable, log instance or None\n    The current error handler. If no handler was set through `seterrcall`,\n    ``None`` is returned.\n\nSee Also\n--------\nseterrcall, seterr, geterr\n\nNotes\n-----\nFor complete documentation of the types of floating-point exceptions and\ntreatment options, see `seterr`.\n\nExamples\n--------\n>>> import numpy as np\n>>> np.geterrcall()  # we did not yet set a handler, returns None\n\n>>> orig_settings = np.seterr(all='call')\n>>> def err_handler(type, flag):\n...     print(\"Floating point error (%s), with flag %s\" % (type, flag))\n>>> old_handler = np.seterrcall(err_handler)\n>>> np.array([1, 2, 3]) / 0.0\nFloating point error (divide by zero), with flag 1\narray([inf, inf, inf])\n\n>>> cur_handler = np.geterrcall()\n>>> cur_handler is err_handler\nTrue\n>>> old_settings = np.seterr(**orig_settings)  # restore original\n>>> old_handler = np.seterrcall(None)  # restore original"
    },
    {
      "name": "inner",
      "docstring": null
    }
  ],
  "innovations": []
}