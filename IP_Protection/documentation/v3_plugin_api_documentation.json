{
  "file_path": "c:\\Users\\sgbil\\OneDrive\\Desktop\\Negative_Space_Imaging_Project\\.venv\\Lib\\site-packages\\imageio\\core\\v3_plugin_api.py",
  "classes": [
    {
      "name": "ImageProperties",
      "docstring": "Standardized Metadata\n\nImageProperties represent a set of standardized metadata that is available\nunder the same name for every supported format. If the ImageResource (or\nformat) does not specify the value, a sensible default value is chosen\ninstead.\n\nAttributes\n----------\nshape : Tuple[int, ...]\n    The shape of the loaded ndimage.\ndtype : np.dtype\n    The dtype of the loaded ndimage.\nn_images : int\n    Number of images in the file if ``index=...``, `None` for single images.\nis_batch : bool\n    If True, the first dimension of the ndimage represents a batch dimension\n    along which several images are stacked.\nspacing : Tuple\n    A tuple describing the spacing between pixels along each axis of the\n    ndimage. If the spacing is uniform along an axis the value corresponding\n    to that axis is a single float. If the spacing is non-uniform, the value\n    corresponding to that axis is a tuple in which the i-th element\n    indicates the spacing between the i-th and (i+1)-th pixel along that\n    axis.",
      "methods": []
    },
    {
      "name": "PluginV3",
      "docstring": "A ImageIO Plugin.\n\nThis is an abstract plugin that documents the v3 plugin API interface. A\nplugin is an adapter/wrapper around a backend that converts a request from\niio.core (e.g., read an image from file) into a sequence of instructions for\nthe backend that fulfill the request.\n\nPlugin authors may choose to subclass this class when implementing a new\nplugin, but aren't obliged to do so. As long as the plugin class implements\nthe interface (methods) described below the ImageIO core will treat it just\nlike any other plugin.\n\n\nParameters\n----------\nrequest : iio.Request\n    A request object that represents the users intent. It provides a\n    standard interface to access the various ImageResources and serves them\n    to the plugin as a file object (or file). Check the docs for details.\n**kwargs : Any\n    Additional configuration arguments for the plugin or backend. Usually\n    these match the configuration arguments available on the backend and\n    are forwarded to it.\n\n\nRaises\n------\nInitializationError\n    During ``__init__`` the plugin tests if it can fulfill the request. If\n    it can't, e.g., because the request points to a file in the wrong\n    format, then it should raise an ``InitializationError`` and provide a\n    reason for failure. This reason may be reported to the user.\nImportError\n    Plugins will be imported dynamically when listed in\n    ``iio.config.known_plugins`` to fulfill requests. This way, users only\n    have to load plugins/backends they actually use. If this plugin's backend\n    is not installed, it should raise an ``ImportError`` either during\n    module import or during class construction.\n\nNotes\n-----\nUpon successful construction the plugin takes ownership of the provided\nrequest. This means that it is the plugin's responsibility to call\nrequest.finish() to close the resource when it is no longer needed.\n\nPlugins _must_ implement a context manager that closes and cleans any\nresources held by the plugin upon exit.",
      "methods": [
        {
          "name": "__init__",
          "docstring": "Initialize a new Plugin Instance.\n\nSee Plugin's docstring for detailed documentation.\n\nNotes\n-----\nThe implementation here stores the request as a local variable that is\nexposed using a @property below. If you inherit from PluginV3, remember\nto call ``super().__init__(request)``."
        },
        {
          "name": "read",
          "docstring": "Read a ndimage.\n\nThe ``read`` method loads a (single) ndimage, located at ``index`` from\nthe requested ImageResource.\n\nIt is at the plugin's descretion to decide (and document) what\nconstitutes a single ndimage. A sensible way to make this decision is to\nchoose based on the ImageResource's format and on what users will expect\nfrom such a format. For example, a sensible choice for a TIFF file\nproduced by an ImageJ hyperstack is to read it as a volumetric ndimage\n(1 color dimension followed by 3 spatial dimensions). On the other hand,\na sensible choice for a MP4 file produced by Davinci Resolve is to treat\neach frame as a ndimage (2 spatial dimensions followed by 1 color\ndimension).\n\nThe value ``index=None`` is special. It requests the plugin to load all\nndimages in the file and stack them along a new first axis. For example,\nif a MP4 file is read with ``index=None`` and the plugin identifies\nsingle frames as ndimages, then the plugin should read all frames and\nstack them into a new ndimage which now contains a time axis as its\nfirst axis. If a PNG file (single image format) is read with\n``index=None`` the plugin does a very similar thing: It loads all\nndimages in the file (here it's just one) and stacks them along a new\nfirst axis, effectively prepending an axis with size 1 to the image. If\na plugin does not wish to support ``index=None`` it should set a more\nsensible default and raise a ``ValueError`` when requested to read using\n``index=None``.\n\nParameters\n----------\nindex : int\n    If the ImageResource contains multiple ndimages, and index is an\n    integer, select the index-th ndimage from among them and return it.\n    If index is an ellipsis (...), read all ndimages in the file and\n    stack them along a new batch dimension. If index is None, let the\n    plugin decide. If the index is out of bounds a ``ValueError`` is\n    raised.\n**kwargs : Any\n    The read method may accept any number of plugin-specific keyword\n    arguments to further customize the read behavior. Usually these\n    match the arguments available on the backend and are forwarded to\n    it.\n\nReturns\n-------\nndimage : np.ndarray\n    A ndimage containing decoded pixel data (sometimes called bitmap).\n\nNotes\n-----\nThe ImageResource from which the plugin should read is managed by the\nprovided request object. Directly accessing the managed ImageResource is\n_not_ permitted. Instead, you can get FileLike access to the\nImageResource via request.get_file().\n\nIf the backend doesn't support reading from FileLike objects, you can\nrequest a temporary file to pass to the backend via\n``request.get_local_filename()``. This is, however, not very performant\n(involves copying the Request's content into a temporary file), so you\nshould avoid doing this whenever possible. Consider it a fallback method\nin case all else fails."
        },
        {
          "name": "write",
          "docstring": "Write a ndimage to a ImageResource.\n\nThe ``write`` method encodes the given ndimage into the format handled\nby the backend and writes it to the ImageResource. It overwrites\nany content that may have been previously stored in the file.\n\nIf the backend supports only a single format then it must check if\nthe ImageResource matches that format and raise an exception if not.\nTypically, this should be done during initialization in the form of a\n``InitializationError``.\n\nIf the backend supports more than one format it must determine the\nrequested/desired format. Usually this can be done by inspecting the\nImageResource (e.g., by checking ``request.extension``), or by providing\na mechanism to explicitly set the format (perhaps with a - sensible -\ndefault value). If the plugin can not determine the desired format, it\n**must not** write to the ImageResource, but raise an exception instead.\n\nIf the backend supports at least one format that can hold multiple\nndimages it should be capable of handling ndimage batches and lists of\nndimages. If the ``ndimage`` input is a list of ndimages, the plugin\nshould not assume that the ndimages are not stackable, i.e., ndimages\nmay have different shapes. Otherwise, the ``ndimage`` may be a batch of\nmultiple ndimages stacked along the first axis of the array. The plugin\nmust be able to discover this, either automatically or via additional\n`kwargs`. If there is ambiguity in the process, the plugin must clearly\ndocument what happens in such cases and, if possible, describe how to\nresolve this ambiguity.\n\nParameters\n----------\nndimage : ArrayLike\n    The ndimage to encode and write to the current ImageResource.\n**kwargs : Any\n    The write method may accept any number of plugin-specific keyword\n    arguments to customize the writing behavior. Usually these match the\n    arguments available on the backend and are forwarded to it.\n\nReturns\n-------\nencoded_image : bytes or None\n    If the chosen ImageResource is the special target ``\"<bytes>\"`` then\n    write should return a byte string containing the encoded image data.\n    Otherwise, it returns None.\n\nNotes\n-----\nThe ImageResource to which the plugin should write to is managed by the\nprovided request object. Directly accessing the managed ImageResource is\n_not_ permitted. Instead, you can get FileLike access to the\nImageResource via request.get_file().\n\nIf the backend doesn't support writing to FileLike objects, you can\nrequest a temporary file to pass to the backend via\n``request.get_local_filename()``. This is, however, not very performant\n(involves copying the Request's content from a temporary file), so you\nshould avoid doing this whenever possible. Consider it a fallback method\nin case all else fails."
        },
        {
          "name": "iter",
          "docstring": "Iterate the ImageResource.\n\nThis method returns a generator that yields ndimages in the order in which\nthey appear in the file. This is roughly equivalent to::\n\n    idx = 0\n    while True:\n        try:\n            yield self.read(index=idx)\n        except ValueError:\n            break\n\nIt works very similar to ``read``, and you can consult the documentation\nof that method for additional information on desired behavior.\n\nParameters\n----------\n**kwargs : Any\n    The iter method may accept any number of plugin-specific keyword\n    arguments to further customize the reading/iteration behavior.\n    Usually these match the arguments available on the backend and are\n    forwarded to it.\n\nYields\n------\nndimage : np.ndarray\n    A ndimage containing decoded pixel data (sometimes called bitmap).\n\nSee Also\n--------\nPluginV3.read"
        },
        {
          "name": "properties",
          "docstring": "Standardized ndimage metadata.\n\nParameters\n----------\nindex : int\n    If the ImageResource contains multiple ndimages, and index is an\ninteger, select the index-th ndimage from among them and return its\nproperties. If index is an ellipsis (...), read all ndimages in the file\nand stack them along a new batch dimension and return their properties.\nIf index is None, the plugin decides the default.\n\nReturns\n-------\nproperties : ImageProperties\n    A dataclass filled with standardized image metadata."
        },
        {
          "name": "metadata",
          "docstring": "Format-Specific ndimage metadata.\n\nThe method reads metadata stored in the ImageResource and returns it as\na python dict. The plugin is free to choose which name to give a piece\nof metadata; however, if possible, it should match the name given by the\nformat. There is no requirement regarding the fields a plugin must\nexpose; however, if a plugin does expose any,``exclude_applied`` applies\nto these fields.\n\nIf the plugin does return metadata items, it must check the value of\n``exclude_applied`` before returning them. If ``exclude applied`` is\nTrue, then any metadata item that would be applied to an ndimage\nreturned by ``read`` (or ``iter``) must not be returned. This is done to\navoid confusion; for example, if an ImageResource defines the ExIF\nrotation tag, and the plugin applies the rotation to the data before\nreturning it, then ``exclude_applied`` prevents confusion on whether the\ntag was already applied or not.\n\nThe `kwarg` ``index`` behaves similar to its counterpart in ``read``\nwith one exception: If the ``index`` is None, then global metadata is\nreturned instead of returning a combination of all metadata items. If\nthere is no global metadata, the Plugin should return an empty dict or\nraise an exception.\n\nParameters\n----------\nindex : int\n    If the ImageResource contains multiple ndimages, and index is an\n    integer, select the index-th ndimage from among them and return its\n    metadata. If index is an ellipsis (...), return global metadata. If\n    index is None, the plugin decides the default.\nexclude_applied : bool\n    If True (default), do not report metadata fields that the plugin\n    would apply/consume while reading the image.\n\nReturns\n-------\nmetadata : dict\n    A dictionary filled with format-specific metadata fields and their\n    values."
        },
        {
          "name": "close",
          "docstring": "Close the ImageResource.\n\nThis method allows a plugin to behave similar to the python built-in ``open``::\n\n    image_file = my_plugin(Request, \"r\")\n    ...\n    image_file.close()\n\nIt is used by the context manager and deconstructor below to avoid leaking\nImageResources. If the plugin has no other cleanup to do it doesn't have\nto overwrite this method itself and can rely on the implementation\nbelow."
        },
        {
          "name": "request",
          "docstring": null
        }
      ]
    }
  ],
  "functions": [
    {
      "name": "read",
      "docstring": "Read a ndimage.\n\nThe ``read`` method loads a (single) ndimage, located at ``index`` from\nthe requested ImageResource.\n\nIt is at the plugin's descretion to decide (and document) what\nconstitutes a single ndimage. A sensible way to make this decision is to\nchoose based on the ImageResource's format and on what users will expect\nfrom such a format. For example, a sensible choice for a TIFF file\nproduced by an ImageJ hyperstack is to read it as a volumetric ndimage\n(1 color dimension followed by 3 spatial dimensions). On the other hand,\na sensible choice for a MP4 file produced by Davinci Resolve is to treat\neach frame as a ndimage (2 spatial dimensions followed by 1 color\ndimension).\n\nThe value ``index=None`` is special. It requests the plugin to load all\nndimages in the file and stack them along a new first axis. For example,\nif a MP4 file is read with ``index=None`` and the plugin identifies\nsingle frames as ndimages, then the plugin should read all frames and\nstack them into a new ndimage which now contains a time axis as its\nfirst axis. If a PNG file (single image format) is read with\n``index=None`` the plugin does a very similar thing: It loads all\nndimages in the file (here it's just one) and stacks them along a new\nfirst axis, effectively prepending an axis with size 1 to the image. If\na plugin does not wish to support ``index=None`` it should set a more\nsensible default and raise a ``ValueError`` when requested to read using\n``index=None``.\n\nParameters\n----------\nindex : int\n    If the ImageResource contains multiple ndimages, and index is an\n    integer, select the index-th ndimage from among them and return it.\n    If index is an ellipsis (...), read all ndimages in the file and\n    stack them along a new batch dimension. If index is None, let the\n    plugin decide. If the index is out of bounds a ``ValueError`` is\n    raised.\n**kwargs : Any\n    The read method may accept any number of plugin-specific keyword\n    arguments to further customize the read behavior. Usually these\n    match the arguments available on the backend and are forwarded to\n    it.\n\nReturns\n-------\nndimage : np.ndarray\n    A ndimage containing decoded pixel data (sometimes called bitmap).\n\nNotes\n-----\nThe ImageResource from which the plugin should read is managed by the\nprovided request object. Directly accessing the managed ImageResource is\n_not_ permitted. Instead, you can get FileLike access to the\nImageResource via request.get_file().\n\nIf the backend doesn't support reading from FileLike objects, you can\nrequest a temporary file to pass to the backend via\n``request.get_local_filename()``. This is, however, not very performant\n(involves copying the Request's content into a temporary file), so you\nshould avoid doing this whenever possible. Consider it a fallback method\nin case all else fails."
    },
    {
      "name": "write",
      "docstring": "Write a ndimage to a ImageResource.\n\nThe ``write`` method encodes the given ndimage into the format handled\nby the backend and writes it to the ImageResource. It overwrites\nany content that may have been previously stored in the file.\n\nIf the backend supports only a single format then it must check if\nthe ImageResource matches that format and raise an exception if not.\nTypically, this should be done during initialization in the form of a\n``InitializationError``.\n\nIf the backend supports more than one format it must determine the\nrequested/desired format. Usually this can be done by inspecting the\nImageResource (e.g., by checking ``request.extension``), or by providing\na mechanism to explicitly set the format (perhaps with a - sensible -\ndefault value). If the plugin can not determine the desired format, it\n**must not** write to the ImageResource, but raise an exception instead.\n\nIf the backend supports at least one format that can hold multiple\nndimages it should be capable of handling ndimage batches and lists of\nndimages. If the ``ndimage`` input is a list of ndimages, the plugin\nshould not assume that the ndimages are not stackable, i.e., ndimages\nmay have different shapes. Otherwise, the ``ndimage`` may be a batch of\nmultiple ndimages stacked along the first axis of the array. The plugin\nmust be able to discover this, either automatically or via additional\n`kwargs`. If there is ambiguity in the process, the plugin must clearly\ndocument what happens in such cases and, if possible, describe how to\nresolve this ambiguity.\n\nParameters\n----------\nndimage : ArrayLike\n    The ndimage to encode and write to the current ImageResource.\n**kwargs : Any\n    The write method may accept any number of plugin-specific keyword\n    arguments to customize the writing behavior. Usually these match the\n    arguments available on the backend and are forwarded to it.\n\nReturns\n-------\nencoded_image : bytes or None\n    If the chosen ImageResource is the special target ``\"<bytes>\"`` then\n    write should return a byte string containing the encoded image data.\n    Otherwise, it returns None.\n\nNotes\n-----\nThe ImageResource to which the plugin should write to is managed by the\nprovided request object. Directly accessing the managed ImageResource is\n_not_ permitted. Instead, you can get FileLike access to the\nImageResource via request.get_file().\n\nIf the backend doesn't support writing to FileLike objects, you can\nrequest a temporary file to pass to the backend via\n``request.get_local_filename()``. This is, however, not very performant\n(involves copying the Request's content from a temporary file), so you\nshould avoid doing this whenever possible. Consider it a fallback method\nin case all else fails."
    },
    {
      "name": "iter",
      "docstring": "Iterate the ImageResource.\n\nThis method returns a generator that yields ndimages in the order in which\nthey appear in the file. This is roughly equivalent to::\n\n    idx = 0\n    while True:\n        try:\n            yield self.read(index=idx)\n        except ValueError:\n            break\n\nIt works very similar to ``read``, and you can consult the documentation\nof that method for additional information on desired behavior.\n\nParameters\n----------\n**kwargs : Any\n    The iter method may accept any number of plugin-specific keyword\n    arguments to further customize the reading/iteration behavior.\n    Usually these match the arguments available on the backend and are\n    forwarded to it.\n\nYields\n------\nndimage : np.ndarray\n    A ndimage containing decoded pixel data (sometimes called bitmap).\n\nSee Also\n--------\nPluginV3.read"
    },
    {
      "name": "properties",
      "docstring": "Standardized ndimage metadata.\n\nParameters\n----------\nindex : int\n    If the ImageResource contains multiple ndimages, and index is an\ninteger, select the index-th ndimage from among them and return its\nproperties. If index is an ellipsis (...), read all ndimages in the file\nand stack them along a new batch dimension and return their properties.\nIf index is None, the plugin decides the default.\n\nReturns\n-------\nproperties : ImageProperties\n    A dataclass filled with standardized image metadata."
    },
    {
      "name": "metadata",
      "docstring": "Format-Specific ndimage metadata.\n\nThe method reads metadata stored in the ImageResource and returns it as\na python dict. The plugin is free to choose which name to give a piece\nof metadata; however, if possible, it should match the name given by the\nformat. There is no requirement regarding the fields a plugin must\nexpose; however, if a plugin does expose any,``exclude_applied`` applies\nto these fields.\n\nIf the plugin does return metadata items, it must check the value of\n``exclude_applied`` before returning them. If ``exclude applied`` is\nTrue, then any metadata item that would be applied to an ndimage\nreturned by ``read`` (or ``iter``) must not be returned. This is done to\navoid confusion; for example, if an ImageResource defines the ExIF\nrotation tag, and the plugin applies the rotation to the data before\nreturning it, then ``exclude_applied`` prevents confusion on whether the\ntag was already applied or not.\n\nThe `kwarg` ``index`` behaves similar to its counterpart in ``read``\nwith one exception: If the ``index`` is None, then global metadata is\nreturned instead of returning a combination of all metadata items. If\nthere is no global metadata, the Plugin should return an empty dict or\nraise an exception.\n\nParameters\n----------\nindex : int\n    If the ImageResource contains multiple ndimages, and index is an\n    integer, select the index-th ndimage from among them and return its\n    metadata. If index is an ellipsis (...), return global metadata. If\n    index is None, the plugin decides the default.\nexclude_applied : bool\n    If True (default), do not report metadata fields that the plugin\n    would apply/consume while reading the image.\n\nReturns\n-------\nmetadata : dict\n    A dictionary filled with format-specific metadata fields and their\n    values."
    },
    {
      "name": "close",
      "docstring": "Close the ImageResource.\n\nThis method allows a plugin to behave similar to the python built-in ``open``::\n\n    image_file = my_plugin(Request, \"r\")\n    ...\n    image_file.close()\n\nIt is used by the context manager and deconstructor below to avoid leaking\nImageResources. If the plugin has no other cleanup to do it doesn't have\nto overwrite this method itself and can rely on the implementation\nbelow."
    },
    {
      "name": "request",
      "docstring": null
    }
  ],
  "innovations": []
}