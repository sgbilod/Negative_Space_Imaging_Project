{
  "file_path": "c:\\Users\\sgbil\\OneDrive\\Desktop\\Negative_Space_Imaging_Project\\.venv\\Lib\\site-packages\\matplotlib\\cbook.py",
  "classes": [
    {
      "name": "_ExceptionInfo",
      "docstring": "A class to carry exception information around.\n\nThis is used to store and later raise exceptions. It's an alternative to\ndirectly storing Exception instances that circumvents traceback-related\nissues: caching tracebacks can keep user's objects in local namespaces\nalive indefinitely, which can lead to very surprising memory issues for\nusers and result in incorrect tracebacks.",
      "methods": [
        {
          "name": "__init__",
          "docstring": null
        },
        {
          "name": "from_exception",
          "docstring": null
        },
        {
          "name": "to_exception",
          "docstring": null
        }
      ]
    },
    {
      "name": "_StrongRef",
      "docstring": "Wrapper similar to a weakref, but keeping a strong reference to the object.",
      "methods": [
        {
          "name": "__init__",
          "docstring": null
        }
      ]
    },
    {
      "name": "_UnhashDict",
      "docstring": "A minimal dict-like class that also supports unhashable keys, storing them\nin a list of key-value pairs.\n\nThis class only implements the interface needed for `CallbackRegistry`, and\ntries to minimize the overhead for the hashable case.",
      "methods": [
        {
          "name": "__init__",
          "docstring": null
        },
        {
          "name": "pop",
          "docstring": null
        }
      ]
    },
    {
      "name": "CallbackRegistry",
      "docstring": "Handle registering, processing, blocking, and disconnecting\nfor a set of signals and callbacks:\n\n    >>> def oneat(x):\n    ...     print('eat', x)\n    >>> def ondrink(x):\n    ...     print('drink', x)\n\n    >>> from matplotlib.cbook import CallbackRegistry\n    >>> callbacks = CallbackRegistry()\n\n    >>> id_eat = callbacks.connect('eat', oneat)\n    >>> id_drink = callbacks.connect('drink', ondrink)\n\n    >>> callbacks.process('drink', 123)\n    drink 123\n    >>> callbacks.process('eat', 456)\n    eat 456\n    >>> callbacks.process('be merry', 456)   # nothing will be called\n\n    >>> callbacks.disconnect(id_eat)\n    >>> callbacks.process('eat', 456)        # nothing will be called\n\n    >>> with callbacks.blocked(signal='drink'):\n    ...     callbacks.process('drink', 123)  # nothing will be called\n    >>> callbacks.process('drink', 123)\n    drink 123\n\nIn practice, one should always disconnect all callbacks when they are\nno longer needed to avoid dangling references (and thus memory leaks).\nHowever, real code in Matplotlib rarely does so, and due to its design,\nit is rather difficult to place this kind of code.  To get around this,\nand prevent this class of memory leaks, we instead store weak references\nto bound methods only, so when the destination object needs to die, the\nCallbackRegistry won't keep it alive.\n\nParameters\n----------\nexception_handler : callable, optional\n   If not None, *exception_handler* must be a function that takes an\n   `Exception` as single parameter.  It gets called with any `Exception`\n   raised by the callbacks during `CallbackRegistry.process`, and may\n   either re-raise the exception or handle it in another manner.\n\n   The default handler prints the exception (with `traceback.print_exc`) if\n   an interactive event loop is running; it re-raises the exception if no\n   interactive event loop is running.\n\nsignals : list, optional\n    If not None, *signals* is a list of signals that this registry handles:\n    attempting to `process` or to `connect` to a signal not in the list\n    throws a `ValueError`.  The default, None, does not restrict the\n    handled signals.",
      "methods": [
        {
          "name": "__init__",
          "docstring": null
        },
        {
          "name": "connect",
          "docstring": "Register *func* to be called when signal *signal* is generated."
        },
        {
          "name": "disconnect",
          "docstring": "Disconnect the callback registered with callback id *cid*.\n\nNo error is raised if such a callback does not exist."
        },
        {
          "name": "process",
          "docstring": "Process signal *s*.\n\nAll of the functions registered to receive callbacks on *s* will be\ncalled with ``*args`` and ``**kwargs``."
        },
        {
          "name": "blocked",
          "docstring": "Block callback signals from being processed.\n\nA context manager to temporarily block/disable callback signals\nfrom being processed by the registered listeners.\n\nParameters\n----------\nsignal : str, optional\n    The callback signal to block. The default is to block all signals."
        }
      ]
    },
    {
      "name": "silent_list",
      "docstring": "A list with a short ``repr()``.\n\nThis is meant to be used for a homogeneous list of artists, so that they\ndon't cause long, meaningless output.\n\nInstead of ::\n\n    [<matplotlib.lines.Line2D object at 0x7f5749fed3c8>,\n     <matplotlib.lines.Line2D object at 0x7f5749fed4e0>,\n     <matplotlib.lines.Line2D object at 0x7f5758016550>]\n\none will get ::\n\n    <a list of 3 Line2D objects>\n\nIf ``self.type`` is None, the type name is obtained from the first item in\nthe list (if any).",
      "methods": [
        {
          "name": "__init__",
          "docstring": null
        }
      ]
    },
    {
      "name": "_Stack",
      "docstring": "Stack of elements with a movable cursor.\n\nMimics home/back/forward in a web browser.",
      "methods": [
        {
          "name": "__init__",
          "docstring": null
        },
        {
          "name": "clear",
          "docstring": "Empty the stack."
        },
        {
          "name": "forward",
          "docstring": "Move the position forward and return the current element."
        },
        {
          "name": "back",
          "docstring": "Move the position back and return the current element."
        },
        {
          "name": "push",
          "docstring": "Push *o* to the stack after the current position, and return *o*.\n\nDiscard all later elements."
        },
        {
          "name": "home",
          "docstring": "Push the first element onto the top of the stack.\n\nThe first element is returned."
        }
      ]
    },
    {
      "name": "Grouper",
      "docstring": "A disjoint-set data structure.\n\nObjects can be joined using :meth:`join`, tested for connectedness\nusing :meth:`joined`, and all disjoint sets can be retrieved by\nusing the object as an iterator.\n\nThe objects being joined must be hashable and weak-referenceable.\n\nExamples\n--------\n>>> from matplotlib.cbook import Grouper\n>>> class Foo:\n...     def __init__(self, s):\n...         self.s = s\n...     def __repr__(self):\n...         return self.s\n...\n>>> a, b, c, d, e, f = [Foo(x) for x in 'abcdef']\n>>> grp = Grouper()\n>>> grp.join(a, b)\n>>> grp.join(b, c)\n>>> grp.join(d, e)\n>>> list(grp)\n[[a, b, c], [d, e]]\n>>> grp.joined(a, b)\nTrue\n>>> grp.joined(a, c)\nTrue\n>>> grp.joined(a, d)\nFalse",
      "methods": [
        {
          "name": "__init__",
          "docstring": null
        },
        {
          "name": "join",
          "docstring": "Join given arguments into the same set.  Accepts one or more arguments."
        },
        {
          "name": "joined",
          "docstring": "Return whether *a* and *b* are members of the same set."
        },
        {
          "name": "remove",
          "docstring": "Remove *a* from the grouper, doing nothing if it is not there."
        },
        {
          "name": "get_siblings",
          "docstring": "Return all of the items joined with *a*, including itself."
        }
      ]
    },
    {
      "name": "GrouperView",
      "docstring": "Immutable view over a `.Grouper`.",
      "methods": [
        {
          "name": "__init__",
          "docstring": null
        },
        {
          "name": "joined",
          "docstring": "Return whether *a* and *b* are members of the same set."
        },
        {
          "name": "get_siblings",
          "docstring": "Return all of the items joined with *a*, including itself."
        }
      ]
    },
    {
      "name": "_OrderedSet",
      "docstring": null,
      "methods": [
        {
          "name": "__init__",
          "docstring": null
        },
        {
          "name": "add",
          "docstring": null
        },
        {
          "name": "discard",
          "docstring": null
        }
      ]
    },
    {
      "name": "subcls",
      "docstring": null,
      "methods": []
    }
  ],
  "functions": [
    {
      "name": "strip_math",
      "docstring": "Remove latex formatting from mathtext.\n\nOnly handles fully math and fully non-math strings."
    },
    {
      "name": "is_writable_file_like",
      "docstring": "Return whether *obj* looks like a file object with a *write* method."
    },
    {
      "name": "file_requires_unicode",
      "docstring": "Return whether the given writable file-like object requires Unicode to be\nwritten to it."
    },
    {
      "name": "to_filehandle",
      "docstring": "Convert a path to an open file handle or pass-through a file-like object.\n\nConsider using `open_file_cm` instead, as it allows one to properly close\nnewly created file objects more easily.\n\nParameters\n----------\nfname : str or path-like or file-like\n    If `str` or `os.PathLike`, the file is opened using the flags specified\n    by *flag* and *encoding*.  If a file-like object, it is passed through.\nflag : str, default: 'r'\n    Passed as the *mode* argument to `open` when *fname* is `str` or\n    `os.PathLike`; ignored if *fname* is file-like.\nreturn_opened : bool, default: False\n    If True, return both the file object and a boolean indicating whether\n    this was a new file (that the caller needs to close).  If False, return\n    only the new file.\nencoding : str or None, default: None\n    Passed as the *mode* argument to `open` when *fname* is `str` or\n    `os.PathLike`; ignored if *fname* is file-like.\n\nReturns\n-------\nfh : file-like\nopened : bool\n    *opened* is only returned if *return_opened* is True."
    },
    {
      "name": "open_file_cm",
      "docstring": "Pass through file objects and context-manage path-likes."
    },
    {
      "name": "is_scalar_or_string",
      "docstring": "Return whether the given object is a scalar or string like."
    },
    {
      "name": "get_sample_data",
      "docstring": "Return a sample data file.  *fname* is a path relative to the\n:file:`mpl-data/sample_data` directory.  If *asfileobj* is `True`\nreturn a file object, otherwise just a file path.\n\nSample data files are stored in the 'mpl-data/sample_data' directory within\nthe Matplotlib package.\n\nIf the filename ends in .gz, the file is implicitly ungzipped.  If the\nfilename ends with .npy or .npz, and *asfileobj* is `True`, the file is\nloaded with `numpy.load`."
    },
    {
      "name": "flatten",
      "docstring": "Return a generator of flattened nested containers.\n\nFor example:\n\n    >>> from matplotlib.cbook import flatten\n    >>> l = (('John', ['Hunter']), (1, 23), [[([42, (5, 23)], )]])\n    >>> print(list(flatten(l)))\n    ['John', 'Hunter', 1, 23, 42, 5, 23]\n\nBy: Composite of Holger Krekel and Luther Blissett\nFrom: https://code.activestate.com/recipes/121294-simple-generator-for-flattening-nested-containers/\nand Recipe 1.12 in cookbook"
    },
    {
      "name": "safe_masked_invalid",
      "docstring": null
    },
    {
      "name": "print_cycles",
      "docstring": "Print loops of cyclic references in the given *objects*.\n\nIt is often useful to pass in ``gc.garbage`` to find the cycles that are\npreventing some objects from being garbage collected.\n\nParameters\n----------\nobjects\n    A list of objects to find cycles in.\noutstream\n    The stream for output.\nshow_progress : bool\n    If True, print the number of objects reached as they are found."
    },
    {
      "name": "simple_linear_interpolation",
      "docstring": "Resample an array with ``steps - 1`` points between original point pairs.\n\nAlong each column of *a*, ``(steps - 1)`` points are introduced between\neach original values; the values are linearly interpolated.\n\nParameters\n----------\na : array, shape (n, ...)\nsteps : int\n\nReturns\n-------\narray\n    shape ``((n - 1) * steps + 1, ...)``"
    },
    {
      "name": "delete_masked_points",
      "docstring": "Find all masked and/or non-finite points in a set of arguments,\nand return the arguments with only the unmasked points remaining.\n\nArguments can be in any of 5 categories:\n\n1) 1-D masked arrays\n2) 1-D ndarrays\n3) ndarrays with more than one dimension\n4) other non-string iterables\n5) anything else\n\nThe first argument must be in one of the first four categories;\nany argument with a length differing from that of the first\nargument (and hence anything in category 5) then will be\npassed through unchanged.\n\nMasks are obtained from all arguments of the correct length\nin categories 1, 2, and 4; a point is bad if masked in a masked\narray or if it is a nan or inf.  No attempt is made to\nextract a mask from categories 2, 3, and 4 if `numpy.isfinite`\ndoes not yield a Boolean array.\n\nAll input arguments that are not passed unchanged are returned\nas ndarrays after removing the points or rows corresponding to\nmasks in any of the arguments.\n\nA vastly simpler version of this function was originally\nwritten as a helper for Axes.scatter()."
    },
    {
      "name": "boxplot_stats",
      "docstring": "Return a list of dictionaries of statistics used to draw a series of box\nand whisker plots using `~.Axes.bxp`.\n\nParameters\n----------\nX : array-like\n    Data that will be represented in the boxplots. Should have 2 or\n    fewer dimensions.\n\nwhis : float or (float, float), default: 1.5\n    The position of the whiskers.\n\n    If a float, the lower whisker is at the lowest datum above\n    ``Q1 - whis*(Q3-Q1)``, and the upper whisker at the highest datum below\n    ``Q3 + whis*(Q3-Q1)``, where Q1 and Q3 are the first and third\n    quartiles.  The default value of ``whis = 1.5`` corresponds to Tukey's\n    original definition of boxplots.\n\n    If a pair of floats, they indicate the percentiles at which to draw the\n    whiskers (e.g., (5, 95)).  In particular, setting this to (0, 100)\n    results in whiskers covering the whole range of the data.\n\n    In the edge case where ``Q1 == Q3``, *whis* is automatically set to\n    (0, 100) (cover the whole range of the data) if *autorange* is True.\n\n    Beyond the whiskers, data are considered outliers and are plotted as\n    individual points.\n\nbootstrap : int, optional\n    Number of times the confidence intervals around the median\n    should be bootstrapped (percentile method).\n\nlabels : list of str, optional\n    Labels for each dataset. Length must be compatible with\n    dimensions of *X*.\n\nautorange : bool, optional (False)\n    When `True` and the data are distributed such that the 25th and 75th\n    percentiles are equal, ``whis`` is set to (0, 100) such that the\n    whisker ends are at the minimum and maximum of the data.\n\nReturns\n-------\nlist of dict\n    A list of dictionaries containing the results for each column\n    of data. Keys of each dictionary are the following:\n\n    ========   ===================================\n    Key        Value Description\n    ========   ===================================\n    label      tick label for the boxplot\n    mean       arithmetic mean value\n    med        50th percentile\n    q1         first quartile (25th percentile)\n    q3         third quartile (75th percentile)\n    iqr        interquartile range\n    cilo       lower notch around the median\n    cihi       upper notch around the median\n    whislo     end of the lower whisker\n    whishi     end of the upper whisker\n    fliers     outliers\n    ========   ===================================\n\nNotes\n-----\nNon-bootstrapping approach to confidence interval uses Gaussian-based\nasymptotic approximation:\n\n.. math::\n\n    \\mathrm{med} \\pm 1.57 \\times \\frac{\\mathrm{iqr}}{\\sqrt{N}}\n\nGeneral approach from:\nMcGill, R., Tukey, J.W., and Larsen, W.A. (1978) \"Variations of\nBoxplots\", The American Statistician, 32:12-16."
    },
    {
      "name": "contiguous_regions",
      "docstring": "Return a list of (ind0, ind1) such that ``mask[ind0:ind1].all()`` is\nTrue and we cover all such regions."
    },
    {
      "name": "is_math_text",
      "docstring": "Return whether the string *s* contains math expressions.\n\nThis is done by checking whether *s* contains an even number of\nnon-escaped dollar signs."
    },
    {
      "name": "violin_stats",
      "docstring": "Return a list of dictionaries of data which can be used to draw a series\nof violin plots.\n\nSee the ``Returns`` section below to view the required keys of the\ndictionary.\n\nUsers can skip this function and pass a user-defined set of dictionaries\nwith the same keys to `~.axes.Axes.violinplot` instead of using Matplotlib\nto do the calculations. See the *Returns* section below for the keys\nthat must be present in the dictionaries.\n\nParameters\n----------\nX : array-like\n    Sample data that will be used to produce the gaussian kernel density\n    estimates. Must have 2 or fewer dimensions.\n\nmethod : callable\n    The method used to calculate the kernel density estimate for each\n    column of data. When called via ``method(v, coords)``, it should\n    return a vector of the values of the KDE evaluated at the values\n    specified in coords.\n\npoints : int, default: 100\n    Defines the number of points to evaluate each of the gaussian kernel\n    density estimates at.\n\nquantiles : array-like, default: None\n    Defines (if not None) a list of floats in interval [0, 1] for each\n    column of data, which represents the quantiles that will be rendered\n    for that column of data. Must have 2 or fewer dimensions. 1D array will\n    be treated as a singleton list containing them.\n\nReturns\n-------\nlist of dict\n    A list of dictionaries containing the results for each column of data.\n    The dictionaries contain at least the following:\n\n    - coords: A list of scalars containing the coordinates this particular\n      kernel density estimate was evaluated at.\n    - vals: A list of scalars containing the values of the kernel density\n      estimate at each of the coordinates given in *coords*.\n    - mean: The mean value for this column of data.\n    - median: The median value for this column of data.\n    - min: The minimum value for this column of data.\n    - max: The maximum value for this column of data.\n    - quantiles: The quantile values for this column of data."
    },
    {
      "name": "pts_to_prestep",
      "docstring": "Convert continuous line to pre-steps.\n\nGiven a set of ``N`` points, convert to ``2N - 1`` points, which when\nconnected linearly give a step function which changes values at the\nbeginning of the intervals.\n\nParameters\n----------\nx : array\n    The x location of the steps. May be empty.\n\ny1, ..., yp : array\n    y arrays to be turned into steps; all must be the same length as ``x``.\n\nReturns\n-------\narray\n    The x and y values converted to steps in the same order as the input;\n    can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is\n    length ``N``, each of these arrays will be length ``2N + 1``. For\n    ``N=0``, the length will be 0.\n\nExamples\n--------\n>>> x_s, y1_s, y2_s = pts_to_prestep(x, y1, y2)"
    },
    {
      "name": "pts_to_poststep",
      "docstring": "Convert continuous line to post-steps.\n\nGiven a set of ``N`` points convert to ``2N + 1`` points, which when\nconnected linearly give a step function which changes values at the end of\nthe intervals.\n\nParameters\n----------\nx : array\n    The x location of the steps. May be empty.\n\ny1, ..., yp : array\n    y arrays to be turned into steps; all must be the same length as ``x``.\n\nReturns\n-------\narray\n    The x and y values converted to steps in the same order as the input;\n    can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is\n    length ``N``, each of these arrays will be length ``2N + 1``. For\n    ``N=0``, the length will be 0.\n\nExamples\n--------\n>>> x_s, y1_s, y2_s = pts_to_poststep(x, y1, y2)"
    },
    {
      "name": "pts_to_midstep",
      "docstring": "Convert continuous line to mid-steps.\n\nGiven a set of ``N`` points convert to ``2N`` points which when connected\nlinearly give a step function which changes values at the middle of the\nintervals.\n\nParameters\n----------\nx : array\n    The x location of the steps. May be empty.\n\ny1, ..., yp : array\n    y arrays to be turned into steps; all must be the same length as\n    ``x``.\n\nReturns\n-------\narray\n    The x and y values converted to steps in the same order as the input;\n    can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is\n    length ``N``, each of these arrays will be length ``2N``.\n\nExamples\n--------\n>>> x_s, y1_s, y2_s = pts_to_midstep(x, y1, y2)"
    },
    {
      "name": "index_of",
      "docstring": "A helper function to create reasonable x values for the given *y*.\n\nThis is used for plotting (x, y) if x values are not explicitly given.\n\nFirst try ``y.index`` (assuming *y* is a `pandas.Series`), if that\nfails, use ``range(len(y))``.\n\nThis will be extended in the future to deal with more types of\nlabeled data.\n\nParameters\n----------\ny : float or array-like\n\nReturns\n-------\nx, y : ndarray\n   The x and y values to plot."
    },
    {
      "name": "safe_first_element",
      "docstring": "Return the first element in *obj*.\n\nThis is a type-independent way of obtaining the first element,\nsupporting both index access and the iterator protocol."
    },
    {
      "name": "sanitize_sequence",
      "docstring": "Convert dictview objects to list. Other inputs are returned unchanged."
    },
    {
      "name": "normalize_kwargs",
      "docstring": "Helper function to normalize kwarg inputs.\n\nParameters\n----------\nkw : dict or None\n    A dict of keyword arguments.  None is explicitly supported and treated\n    as an empty dict, to support functions with an optional parameter of\n    the form ``props=None``.\n\nalias_mapping : dict or Artist subclass or Artist instance, optional\n    A mapping between a canonical name to a list of aliases, in order of\n    precedence from lowest to highest.\n\n    If the canonical value is not in the list it is assumed to have the\n    highest priority.\n\n    If an Artist subclass or instance is passed, use its properties alias\n    mapping.\n\nRaises\n------\nTypeError\n    To match what Python raises if invalid arguments/keyword arguments are\n    passed to a callable."
    },
    {
      "name": "from_exception",
      "docstring": null
    },
    {
      "name": "to_exception",
      "docstring": null
    },
    {
      "name": "pop",
      "docstring": null
    },
    {
      "name": "connect",
      "docstring": "Register *func* to be called when signal *signal* is generated."
    },
    {
      "name": "disconnect",
      "docstring": "Disconnect the callback registered with callback id *cid*.\n\nNo error is raised if such a callback does not exist."
    },
    {
      "name": "process",
      "docstring": "Process signal *s*.\n\nAll of the functions registered to receive callbacks on *s* will be\ncalled with ``*args`` and ``**kwargs``."
    },
    {
      "name": "blocked",
      "docstring": "Block callback signals from being processed.\n\nA context manager to temporarily block/disable callback signals\nfrom being processed by the registered listeners.\n\nParameters\n----------\nsignal : str, optional\n    The callback signal to block. The default is to block all signals."
    },
    {
      "name": "clear",
      "docstring": "Empty the stack."
    },
    {
      "name": "forward",
      "docstring": "Move the position forward and return the current element."
    },
    {
      "name": "back",
      "docstring": "Move the position back and return the current element."
    },
    {
      "name": "push",
      "docstring": "Push *o* to the stack after the current position, and return *o*.\n\nDiscard all later elements."
    },
    {
      "name": "home",
      "docstring": "Push the first element onto the top of the stack.\n\nThe first element is returned."
    },
    {
      "name": "print_path",
      "docstring": null
    },
    {
      "name": "recurse",
      "docstring": null
    },
    {
      "name": "join",
      "docstring": "Join given arguments into the same set.  Accepts one or more arguments."
    },
    {
      "name": "joined",
      "docstring": "Return whether *a* and *b* are members of the same set."
    },
    {
      "name": "remove",
      "docstring": "Remove *a* from the grouper, doing nothing if it is not there."
    },
    {
      "name": "get_siblings",
      "docstring": "Return all of the items joined with *a*, including itself."
    },
    {
      "name": "joined",
      "docstring": "Return whether *a* and *b* are members of the same set."
    },
    {
      "name": "get_siblings",
      "docstring": "Return all of the items joined with *a*, including itself."
    },
    {
      "name": "safe_isfinite",
      "docstring": null
    },
    {
      "name": "add",
      "docstring": null
    },
    {
      "name": "discard",
      "docstring": null
    },
    {
      "name": "class_factory",
      "docstring": null
    }
  ],
  "innovations": []
}