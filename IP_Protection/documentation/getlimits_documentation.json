{
  "file_path": "c:\\Users\\sgbil\\OneDrive\\Desktop\\Negative_Space_Imaging_Project\\.venv\\Lib\\site-packages\\numpy\\_core\\getlimits.py",
  "classes": [
    {
      "name": "MachArLike",
      "docstring": "Object to simulate MachAr instance ",
      "methods": [
        {
          "name": "__init__",
          "docstring": null
        },
        {
          "name": "smallest_subnormal",
          "docstring": "Return the value for the smallest subnormal.\n\nReturns\n-------\nsmallest_subnormal : float\n    value for the smallest subnormal.\n\nWarns\n-----\nUserWarning\n    If the calculated value for the smallest subnormal is zero."
        }
      ]
    },
    {
      "name": "finfo",
      "docstring": "finfo(dtype)\n\nMachine limits for floating point types.\n\nAttributes\n----------\nbits : int\n    The number of bits occupied by the type.\ndtype : dtype\n    Returns the dtype for which `finfo` returns information. For complex\n    input, the returned dtype is the associated ``float*`` dtype for its\n    real and complex components.\neps : float\n    The difference between 1.0 and the next smallest representable float\n    larger than 1.0. For example, for 64-bit binary floats in the IEEE-754\n    standard, ``eps = 2**-52``, approximately 2.22e-16.\nepsneg : float\n    The difference between 1.0 and the next smallest representable float\n    less than 1.0. For example, for 64-bit binary floats in the IEEE-754\n    standard, ``epsneg = 2**-53``, approximately 1.11e-16.\niexp : int\n    The number of bits in the exponent portion of the floating point\n    representation.\nmachep : int\n    The exponent that yields `eps`.\nmax : floating point number of the appropriate type\n    The largest representable number.\nmaxexp : int\n    The smallest positive power of the base (2) that causes overflow.\nmin : floating point number of the appropriate type\n    The smallest representable number, typically ``-max``.\nminexp : int\n    The most negative power of the base (2) consistent with there\n    being no leading 0's in the mantissa.\nnegep : int\n    The exponent that yields `epsneg`.\nnexp : int\n    The number of bits in the exponent including its sign and bias.\nnmant : int\n    The number of bits in the mantissa.\nprecision : int\n    The approximate number of decimal digits to which this kind of\n    float is precise.\nresolution : floating point number of the appropriate type\n    The approximate decimal resolution of this type, i.e.,\n    ``10**-precision``.\ntiny : float\n    An alias for `smallest_normal`, kept for backwards compatibility.\nsmallest_normal : float\n    The smallest positive floating point number with 1 as leading bit in\n    the mantissa following IEEE-754 (see Notes).\nsmallest_subnormal : float\n    The smallest positive floating point number with 0 as leading bit in\n    the mantissa following IEEE-754.\n\nParameters\n----------\ndtype : float, dtype, or instance\n    Kind of floating point or complex floating point\n    data-type about which to get information.\n\nSee Also\n--------\niinfo : The equivalent for integer data types.\nspacing : The distance between a value and the nearest adjacent number\nnextafter : The next floating point value after x1 towards x2\n\nNotes\n-----\nFor developers of NumPy: do not instantiate this at the module level.\nThe initial calculation of these parameters is expensive and negatively\nimpacts import times.  These objects are cached, so calling ``finfo()``\nrepeatedly inside your functions is not a problem.\n\nNote that ``smallest_normal`` is not actually the smallest positive\nrepresentable value in a NumPy floating point type. As in the IEEE-754\nstandard [1]_, NumPy floating point types make use of subnormal numbers to\nfill the gap between 0 and ``smallest_normal``. However, subnormal numbers\nmay have significantly reduced precision [2]_.\n\nThis function can also be used for complex data types as well. If used,\nthe output will be the same as the corresponding real float type\n(e.g. numpy.finfo(numpy.csingle) is the same as numpy.finfo(numpy.single)).\nHowever, the output is true for the real and imaginary components.\n\nReferences\n----------\n.. [1] IEEE Standard for Floating-Point Arithmetic, IEEE Std 754-2008,\n       pp.1-70, 2008, https://doi.org/10.1109/IEEESTD.2008.4610935\n.. [2] Wikipedia, \"Denormal Numbers\",\n       https://en.wikipedia.org/wiki/Denormal_number\n\nExamples\n--------\n>>> import numpy as np\n>>> np.finfo(np.float64).dtype\ndtype('float64')\n>>> np.finfo(np.complex64).dtype\ndtype('float32')",
      "methods": [
        {
          "name": "smallest_normal",
          "docstring": "Return the value for the smallest normal.\n\nReturns\n-------\nsmallest_normal : float\n    Value for the smallest normal.\n\nWarns\n-----\nUserWarning\n    If the calculated value for the smallest normal is requested for\n    double-double."
        },
        {
          "name": "tiny",
          "docstring": "Return the value for tiny, alias of smallest_normal.\n\nReturns\n-------\ntiny : float\n    Value for the smallest normal, alias of smallest_normal.\n\nWarns\n-----\nUserWarning\n    If the calculated value for the smallest normal is requested for\n    double-double."
        }
      ]
    },
    {
      "name": "iinfo",
      "docstring": "iinfo(type)\n\nMachine limits for integer types.\n\nAttributes\n----------\nbits : int\n    The number of bits occupied by the type.\ndtype : dtype\n    Returns the dtype for which `iinfo` returns information.\nmin : int\n    The smallest integer expressible by the type.\nmax : int\n    The largest integer expressible by the type.\n\nParameters\n----------\nint_type : integer type, dtype, or instance\n    The kind of integer data type to get information about.\n\nSee Also\n--------\nfinfo : The equivalent for floating point data types.\n\nExamples\n--------\nWith types:\n\n>>> import numpy as np\n>>> ii16 = np.iinfo(np.int16)\n>>> ii16.min\n-32768\n>>> ii16.max\n32767\n>>> ii32 = np.iinfo(np.int32)\n>>> ii32.min\n-2147483648\n>>> ii32.max\n2147483647\n\nWith instances:\n\n>>> ii32 = np.iinfo(np.int32(10))\n>>> ii32.min\n-2147483648\n>>> ii32.max\n2147483647",
      "methods": [
        {
          "name": "__init__",
          "docstring": null
        },
        {
          "name": "min",
          "docstring": "Minimum value of given dtype."
        },
        {
          "name": "max",
          "docstring": "Maximum value of given dtype."
        }
      ]
    }
  ],
  "functions": [
    {
      "name": "smallest_subnormal",
      "docstring": "Return the value for the smallest subnormal.\n\nReturns\n-------\nsmallest_subnormal : float\n    value for the smallest subnormal.\n\nWarns\n-----\nUserWarning\n    If the calculated value for the smallest subnormal is zero."
    },
    {
      "name": "smallest_normal",
      "docstring": "Return the value for the smallest normal.\n\nReturns\n-------\nsmallest_normal : float\n    Value for the smallest normal.\n\nWarns\n-----\nUserWarning\n    If the calculated value for the smallest normal is requested for\n    double-double."
    },
    {
      "name": "tiny",
      "docstring": "Return the value for tiny, alias of smallest_normal.\n\nReturns\n-------\ntiny : float\n    Value for the smallest normal, alias of smallest_normal.\n\nWarns\n-----\nUserWarning\n    If the calculated value for the smallest normal is requested for\n    double-double."
    },
    {
      "name": "min",
      "docstring": "Minimum value of given dtype."
    },
    {
      "name": "max",
      "docstring": "Maximum value of given dtype."
    }
  ],
  "innovations": []
}