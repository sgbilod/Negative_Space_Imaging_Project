{
  "file_path": "c:\\Users\\sgbil\\OneDrive\\Desktop\\Negative_Space_Imaging_Project\\.venv\\Lib\\site-packages\\numpy\\_core\\shape_base.py",
  "classes": [],
  "functions": [
    {
      "name": "atleast_1d",
      "docstring": "Convert inputs to arrays with at least one dimension.\n\nScalar inputs are converted to 1-dimensional arrays, whilst\nhigher-dimensional inputs are preserved.\n\nParameters\n----------\narys1, arys2, ... : array_like\n    One or more input arrays.\n\nReturns\n-------\nret : ndarray\n    An array, or tuple of arrays, each with ``a.ndim >= 1``.\n    Copies are made only if necessary.\n\nSee Also\n--------\natleast_2d, atleast_3d\n\nExamples\n--------\n>>> import numpy as np\n>>> np.atleast_1d(1.0)\narray([1.])\n\n>>> x = np.arange(9.0).reshape(3,3)\n>>> np.atleast_1d(x)\narray([[0., 1., 2.],\n       [3., 4., 5.],\n       [6., 7., 8.]])\n>>> np.atleast_1d(x) is x\nTrue\n\n>>> np.atleast_1d(1, [3, 4])\n(array([1]), array([3, 4]))"
    },
    {
      "name": "atleast_2d",
      "docstring": "View inputs as arrays with at least two dimensions.\n\nParameters\n----------\narys1, arys2, ... : array_like\n    One or more array-like sequences.  Non-array inputs are converted\n    to arrays.  Arrays that already have two or more dimensions are\n    preserved.\n\nReturns\n-------\nres, res2, ... : ndarray\n    An array, or tuple of arrays, each with ``a.ndim >= 2``.\n    Copies are avoided where possible, and views with two or more\n    dimensions are returned.\n\nSee Also\n--------\natleast_1d, atleast_3d\n\nExamples\n--------\n>>> import numpy as np\n>>> np.atleast_2d(3.0)\narray([[3.]])\n\n>>> x = np.arange(3.0)\n>>> np.atleast_2d(x)\narray([[0., 1., 2.]])\n>>> np.atleast_2d(x).base is x\nTrue\n\n>>> np.atleast_2d(1, [1, 2], [[1, 2]])\n(array([[1]]), array([[1, 2]]), array([[1, 2]]))"
    },
    {
      "name": "atleast_3d",
      "docstring": "View inputs as arrays with at least three dimensions.\n\nParameters\n----------\narys1, arys2, ... : array_like\n    One or more array-like sequences.  Non-array inputs are converted to\n    arrays.  Arrays that already have three or more dimensions are\n    preserved.\n\nReturns\n-------\nres1, res2, ... : ndarray\n    An array, or tuple of arrays, each with ``a.ndim >= 3``.  Copies are\n    avoided where possible, and views with three or more dimensions are\n    returned.  For example, a 1-D array of shape ``(N,)`` becomes a view\n    of shape ``(1, N, 1)``, and a 2-D array of shape ``(M, N)`` becomes a\n    view of shape ``(M, N, 1)``.\n\nSee Also\n--------\natleast_1d, atleast_2d\n\nExamples\n--------\n>>> import numpy as np\n>>> np.atleast_3d(3.0)\narray([[[3.]]])\n\n>>> x = np.arange(3.0)\n>>> np.atleast_3d(x).shape\n(1, 3, 1)\n\n>>> x = np.arange(12.0).reshape(4,3)\n>>> np.atleast_3d(x).shape\n(4, 3, 1)\n>>> np.atleast_3d(x).base is x.base  # x is a reshape, so not base itself\nTrue\n\n>>> for arr in np.atleast_3d([1, 2], [[1, 2]], [[[1, 2]]]):\n...     print(arr, arr.shape) # doctest: +SKIP\n...\n[[[1]\n  [2]]] (1, 2, 1)\n[[[1]\n  [2]]] (1, 2, 1)\n[[[1 2]]] (1, 1, 2)"
    },
    {
      "name": "vstack",
      "docstring": "Stack arrays in sequence vertically (row wise).\n\nThis is equivalent to concatenation along the first axis after 1-D arrays\nof shape `(N,)` have been reshaped to `(1,N)`. Rebuilds arrays divided by\n`vsplit`.\n\nThis function makes most sense for arrays with up to 3 dimensions. For\ninstance, for pixel-data with a height (first axis), width (second axis),\nand r/g/b channels (third axis). The functions `concatenate`, `stack` and\n`block` provide more general stacking and concatenation operations.\n\nParameters\n----------\ntup : sequence of ndarrays\n    The arrays must have the same shape along all but the first axis.\n    1-D arrays must have the same length. In the case of a single\n    array_like input, it will be treated as a sequence of arrays; i.e.,\n    each element along the zeroth axis is treated as a separate array.\n\ndtype : str or dtype\n    If provided, the destination array will have this dtype. Cannot be\n    provided together with `out`.\n\n    .. versionadded:: 1.24\n\ncasting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\n    Controls what kind of data casting may occur. Defaults to 'same_kind'.\n\n    .. versionadded:: 1.24\n\nReturns\n-------\nstacked : ndarray\n    The array formed by stacking the given arrays, will be at least 2-D.\n\nSee Also\n--------\nconcatenate : Join a sequence of arrays along an existing axis.\nstack : Join a sequence of arrays along a new axis.\nblock : Assemble an nd-array from nested lists of blocks.\nhstack : Stack arrays in sequence horizontally (column wise).\ndstack : Stack arrays in sequence depth wise (along third axis).\ncolumn_stack : Stack 1-D arrays as columns into a 2-D array.\nvsplit : Split an array into multiple sub-arrays vertically (row-wise).\nunstack : Split an array into a tuple of sub-arrays along an axis.\n\nExamples\n--------\n>>> import numpy as np\n>>> a = np.array([1, 2, 3])\n>>> b = np.array([4, 5, 6])\n>>> np.vstack((a,b))\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n>>> a = np.array([[1], [2], [3]])\n>>> b = np.array([[4], [5], [6]])\n>>> np.vstack((a,b))\narray([[1],\n       [2],\n       [3],\n       [4],\n       [5],\n       [6]])"
    },
    {
      "name": "hstack",
      "docstring": "Stack arrays in sequence horizontally (column wise).\n\nThis is equivalent to concatenation along the second axis, except for 1-D\narrays where it concatenates along the first axis. Rebuilds arrays divided\nby `hsplit`.\n\nThis function makes most sense for arrays with up to 3 dimensions. For\ninstance, for pixel-data with a height (first axis), width (second axis),\nand r/g/b channels (third axis). The functions `concatenate`, `stack` and\n`block` provide more general stacking and concatenation operations.\n\nParameters\n----------\ntup : sequence of ndarrays\n    The arrays must have the same shape along all but the second axis,\n    except 1-D arrays which can be any length. In the case of a single\n    array_like input, it will be treated as a sequence of arrays; i.e.,\n    each element along the zeroth axis is treated as a separate array.\n\ndtype : str or dtype\n    If provided, the destination array will have this dtype. Cannot be\n    provided together with `out`.\n\n    .. versionadded:: 1.24\n\ncasting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\n    Controls what kind of data casting may occur. Defaults to 'same_kind'.\n\n    .. versionadded:: 1.24\n\nReturns\n-------\nstacked : ndarray\n    The array formed by stacking the given arrays.\n\nSee Also\n--------\nconcatenate : Join a sequence of arrays along an existing axis.\nstack : Join a sequence of arrays along a new axis.\nblock : Assemble an nd-array from nested lists of blocks.\nvstack : Stack arrays in sequence vertically (row wise).\ndstack : Stack arrays in sequence depth wise (along third axis).\ncolumn_stack : Stack 1-D arrays as columns into a 2-D array.\nhsplit : Split an array into multiple sub-arrays\n         horizontally (column-wise).\nunstack : Split an array into a tuple of sub-arrays along an axis.\n\nExamples\n--------\n>>> import numpy as np\n>>> a = np.array((1,2,3))\n>>> b = np.array((4,5,6))\n>>> np.hstack((a,b))\narray([1, 2, 3, 4, 5, 6])\n>>> a = np.array([[1],[2],[3]])\n>>> b = np.array([[4],[5],[6]])\n>>> np.hstack((a,b))\narray([[1, 4],\n       [2, 5],\n       [3, 6]])"
    },
    {
      "name": "stack",
      "docstring": "Join a sequence of arrays along a new axis.\n\nThe ``axis`` parameter specifies the index of the new axis in the\ndimensions of the result. For example, if ``axis=0`` it will be the first\ndimension and if ``axis=-1`` it will be the last dimension.\n\nParameters\n----------\narrays : sequence of ndarrays\n    Each array must have the same shape. In the case of a single ndarray\n    array_like input, it will be treated as a sequence of arrays; i.e.,\n    each element along the zeroth axis is treated as a separate array.\n\naxis : int, optional\n    The axis in the result array along which the input arrays are stacked.\n\nout : ndarray, optional\n    If provided, the destination to place the result. The shape must be\n    correct, matching that of what stack would have returned if no\n    out argument were specified.\n\ndtype : str or dtype\n    If provided, the destination array will have this dtype. Cannot be\n    provided together with `out`.\n\n    .. versionadded:: 1.24\n\ncasting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\n    Controls what kind of data casting may occur. Defaults to 'same_kind'.\n\n    .. versionadded:: 1.24\n\n\nReturns\n-------\nstacked : ndarray\n    The stacked array has one more dimension than the input arrays.\n\nSee Also\n--------\nconcatenate : Join a sequence of arrays along an existing axis.\nblock : Assemble an nd-array from nested lists of blocks.\nsplit : Split array into a list of multiple sub-arrays of equal size.\nunstack : Split an array into a tuple of sub-arrays along an axis.\n\nExamples\n--------\n>>> import numpy as np\n>>> rng = np.random.default_rng()\n>>> arrays = [rng.normal(size=(3,4)) for _ in range(10)]\n>>> np.stack(arrays, axis=0).shape\n(10, 3, 4)\n\n>>> np.stack(arrays, axis=1).shape\n(3, 10, 4)\n\n>>> np.stack(arrays, axis=2).shape\n(3, 4, 10)\n\n>>> a = np.array([1, 2, 3])\n>>> b = np.array([4, 5, 6])\n>>> np.stack((a, b))\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n>>> np.stack((a, b), axis=-1)\narray([[1, 4],\n       [2, 5],\n       [3, 6]])"
    },
    {
      "name": "unstack",
      "docstring": "Split an array into a sequence of arrays along the given axis.\n\nThe ``axis`` parameter specifies the dimension along which the array will\nbe split. For example, if ``axis=0`` (the default) it will be the first\ndimension and if ``axis=-1`` it will be the last dimension.\n\nThe result is a tuple of arrays split along ``axis``.\n\n.. versionadded:: 2.1.0\n\nParameters\n----------\nx : ndarray\n    The array to be unstacked.\naxis : int, optional\n    Axis along which the array will be split. Default: ``0``.\n\nReturns\n-------\nunstacked : tuple of ndarrays\n    The unstacked arrays.\n\nSee Also\n--------\nstack : Join a sequence of arrays along a new axis.\nconcatenate : Join a sequence of arrays along an existing axis.\nblock : Assemble an nd-array from nested lists of blocks.\nsplit : Split array into a list of multiple sub-arrays of equal size.\n\nNotes\n-----\n``unstack`` serves as the reverse operation of :py:func:`stack`, i.e.,\n``stack(unstack(x, axis=axis), axis=axis) == x``.\n\nThis function is equivalent to ``tuple(np.moveaxis(x, axis, 0))``, since\niterating on an array iterates along the first axis.\n\nExamples\n--------\n>>> arr = np.arange(24).reshape((2, 3, 4))\n>>> np.unstack(arr)\n(array([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]]),\n array([[12, 13, 14, 15],\n        [16, 17, 18, 19],\n        [20, 21, 22, 23]]))\n>>> np.unstack(arr, axis=1)\n(array([[ 0,  1,  2,  3],\n        [12, 13, 14, 15]]),\n array([[ 4,  5,  6,  7],\n        [16, 17, 18, 19]]),\n array([[ 8,  9, 10, 11],\n        [20, 21, 22, 23]]))\n>>> arr2 = np.stack(np.unstack(arr, axis=1), axis=1)\n>>> arr2.shape\n(2, 3, 4)\n>>> np.all(arr == arr2)\nnp.True_"
    },
    {
      "name": "block",
      "docstring": "Assemble an nd-array from nested lists of blocks.\n\nBlocks in the innermost lists are concatenated (see `concatenate`) along\nthe last dimension (-1), then these are concatenated along the\nsecond-last dimension (-2), and so on until the outermost list is reached.\n\nBlocks can be of any dimension, but will not be broadcasted using\nthe normal rules. Instead, leading axes of size 1 are inserted,\nto make ``block.ndim`` the same for all blocks. This is primarily useful\nfor working with scalars, and means that code like ``np.block([v, 1])``\nis valid, where ``v.ndim == 1``.\n\nWhen the nested list is two levels deep, this allows block matrices to be\nconstructed from their components.\n\nParameters\n----------\narrays : nested list of array_like or scalars (but not tuples)\n    If passed a single ndarray or scalar (a nested list of depth 0), this\n    is returned unmodified (and not copied).\n\n    Elements shapes must match along the appropriate axes (without\n    broadcasting), but leading 1s will be prepended to the shape as\n    necessary to make the dimensions match.\n\nReturns\n-------\nblock_array : ndarray\n    The array assembled from the given blocks.\n\n    The dimensionality of the output is equal to the greatest of:\n\n    * the dimensionality of all the inputs\n    * the depth to which the input list is nested\n\nRaises\n------\nValueError\n    * If list depths are mismatched - for instance, ``[[a, b], c]`` is\n      illegal, and should be spelt ``[[a, b], [c]]``\n    * If lists are empty - for instance, ``[[a, b], []]``\n\nSee Also\n--------\nconcatenate : Join a sequence of arrays along an existing axis.\nstack : Join a sequence of arrays along a new axis.\nvstack : Stack arrays in sequence vertically (row wise).\nhstack : Stack arrays in sequence horizontally (column wise).\ndstack : Stack arrays in sequence depth wise (along third axis).\ncolumn_stack : Stack 1-D arrays as columns into a 2-D array.\nvsplit : Split an array into multiple sub-arrays vertically (row-wise).\nunstack : Split an array into a tuple of sub-arrays along an axis.\n\nNotes\n-----\nWhen called with only scalars, ``np.block`` is equivalent to an ndarray\ncall. So ``np.block([[1, 2], [3, 4]])`` is equivalent to\n``np.array([[1, 2], [3, 4]])``.\n\nThis function does not enforce that the blocks lie on a fixed grid.\n``np.block([[a, b], [c, d]])`` is not restricted to arrays of the form::\n\n    AAAbb\n    AAAbb\n    cccDD\n\nBut is also allowed to produce, for some ``a, b, c, d``::\n\n    AAAbb\n    AAAbb\n    cDDDD\n\nSince concatenation happens along the last axis first, `block` is *not*\ncapable of producing the following directly::\n\n    AAAbb\n    cccbb\n    cccDD\n\nMatlab's \"square bracket stacking\", ``[A, B, ...; p, q, ...]``, is\nequivalent to ``np.block([[A, B, ...], [p, q, ...]])``.\n\nExamples\n--------\nThe most common use of this function is to build a block matrix:\n\n>>> import numpy as np\n>>> A = np.eye(2) * 2\n>>> B = np.eye(3) * 3\n>>> np.block([\n...     [A,               np.zeros((2, 3))],\n...     [np.ones((3, 2)), B               ]\n... ])\narray([[2., 0., 0., 0., 0.],\n       [0., 2., 0., 0., 0.],\n       [1., 1., 3., 0., 0.],\n       [1., 1., 0., 3., 0.],\n       [1., 1., 0., 0., 3.]])\n\nWith a list of depth 1, `block` can be used as `hstack`:\n\n>>> np.block([1, 2, 3])              # hstack([1, 2, 3])\narray([1, 2, 3])\n\n>>> a = np.array([1, 2, 3])\n>>> b = np.array([4, 5, 6])\n>>> np.block([a, b, 10])             # hstack([a, b, 10])\narray([ 1,  2,  3,  4,  5,  6, 10])\n\n>>> A = np.ones((2, 2), int)\n>>> B = 2 * A\n>>> np.block([A, B])                 # hstack([A, B])\narray([[1, 1, 2, 2],\n       [1, 1, 2, 2]])\n\nWith a list of depth 2, `block` can be used in place of `vstack`:\n\n>>> a = np.array([1, 2, 3])\n>>> b = np.array([4, 5, 6])\n>>> np.block([[a], [b]])             # vstack([a, b])\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n>>> A = np.ones((2, 2), int)\n>>> B = 2 * A\n>>> np.block([[A], [B]])             # vstack([A, B])\narray([[1, 1],\n       [1, 1],\n       [2, 2],\n       [2, 2]])\n\nIt can also be used in place of `atleast_1d` and `atleast_2d`:\n\n>>> a = np.array(0)\n>>> b = np.array([1])\n>>> np.block([a])                    # atleast_1d(a)\narray([0])\n>>> np.block([b])                    # atleast_1d(b)\narray([1])\n\n>>> np.block([[a]])                  # atleast_2d(a)\narray([[0]])\n>>> np.block([[b]])                  # atleast_2d(b)\narray([[1]])"
    }
  ],
  "innovations": []
}