{
  "file_path": "c:\\Users\\sgbil\\OneDrive\\Desktop\\Negative_Space_Imaging_Project\\.venv\\Lib\\site-packages\\fontTools\\pens\\freetypePen.py",
  "classes": [
    {
      "name": "FreeTypePen",
      "docstring": "Pen to rasterize paths with FreeType. Requires `freetype-py` module.\n\nConstructs ``FT_Outline`` from the paths, and renders it within a bitmap\nbuffer.\n\nFor ``array()`` and ``show()``, `numpy` and `matplotlib` must be installed.\nFor ``image()``, `Pillow` is required. Each module is lazily loaded when the\ncorresponding method is called.\n\nArgs:\n    glyphSet: a dictionary of drawable glyph objects keyed by name\n        used to resolve component references in composite glyphs.\n\nExamples:\n    If `numpy` and `matplotlib` is available, the following code will\n    show the glyph image of `fi` in a new window::\n\n        from fontTools.ttLib import TTFont\n        from fontTools.pens.freetypePen import FreeTypePen\n        from fontTools.misc.transform import Offset\n        pen = FreeTypePen(None)\n        font = TTFont('SourceSansPro-Regular.otf')\n        glyph = font.getGlyphSet()['fi']\n        glyph.draw(pen)\n        width, ascender, descender = glyph.width, font['OS/2'].usWinAscent, -font['OS/2'].usWinDescent\n        height = ascender - descender\n        pen.show(width=width, height=height, transform=Offset(0, -descender))\n\n    Combining with `uharfbuzz`, you can typeset a chunk of glyphs in a pen::\n\n        import uharfbuzz as hb\n        from fontTools.pens.freetypePen import FreeTypePen\n        from fontTools.pens.transformPen import TransformPen\n        from fontTools.misc.transform import Offset\n\n        en1, en2, ar, ja = 'Typesetting', 'Jeff', '\u0635\u0641 \u0627\u0644\u062d\u0631\u0648\u0641', '\u305f\u3044\u3077\u305b\u3063\u3068'\n        for text, font_path, direction, typo_ascender, typo_descender, vhea_ascender, vhea_descender, contain, features in (\n            (en1, 'NotoSans-Regular.ttf',       'ltr', 2189, -600, None, None, False, {\"kern\": True, \"liga\": True}),\n            (en2, 'NotoSans-Regular.ttf',       'ltr', 2189, -600, None, None, True,  {\"kern\": True, \"liga\": True}),\n            (ar,  'NotoSansArabic-Regular.ttf', 'rtl', 1374, -738, None, None, False, {\"kern\": True, \"liga\": True}),\n            (ja,  'NotoSansJP-Regular.otf',     'ltr', 880,  -120, 500,  -500, False, {\"palt\": True, \"kern\": True}),\n            (ja,  'NotoSansJP-Regular.otf',     'ttb', 880,  -120, 500,  -500, False, {\"vert\": True, \"vpal\": True, \"vkrn\": True})\n        ):\n            blob = hb.Blob.from_file_path(font_path)\n            face = hb.Face(blob)\n            font = hb.Font(face)\n            buf = hb.Buffer()\n            buf.direction = direction\n            buf.add_str(text)\n            buf.guess_segment_properties()\n            hb.shape(font, buf, features)\n\n            x, y = 0, 0\n            pen = FreeTypePen(None)\n            for info, pos in zip(buf.glyph_infos, buf.glyph_positions):\n                gid = info.codepoint\n                transformed = TransformPen(pen, Offset(x + pos.x_offset, y + pos.y_offset))\n                font.draw_glyph_with_pen(gid, transformed)\n                x += pos.x_advance\n                y += pos.y_advance\n\n            offset, width, height = None, None, None\n            if direction in ('ltr', 'rtl'):\n                offset = (0, -typo_descender)\n                width  = x\n                height = typo_ascender - typo_descender\n            else:\n                offset = (-vhea_descender, -y)\n                width  = vhea_ascender - vhea_descender\n                height = -y\n            pen.show(width=width, height=height, transform=Offset(*offset), contain=contain)\n\n    For Jupyter Notebook, the rendered image will be displayed in a cell if\n    you replace ``show()`` with ``image()`` in the examples.",
      "methods": [
        {
          "name": "__init__",
          "docstring": null
        },
        {
          "name": "outline",
          "docstring": "Converts the current contours to ``FT_Outline``.\n\nArgs:\n    transform: An optional 6-tuple containing an affine transformation,\n        or a ``Transform`` object from the ``fontTools.misc.transform``\n        module.\n    evenOdd: Pass ``True`` for even-odd fill instead of non-zero."
        },
        {
          "name": "buffer",
          "docstring": "Renders the current contours within a bitmap buffer.\n\nArgs:\n    width: Image width of the bitmap in pixels. If omitted, it\n        automatically fits to the bounding box of the contours.\n    height: Image height of the bitmap in pixels. If omitted, it\n        automatically fits to the bounding box of the contours.\n    transform: An optional 6-tuple containing an affine transformation,\n        or a ``Transform`` object from the ``fontTools.misc.transform``\n        module. The bitmap size is not affected by this matrix.\n    contain: If ``True``, the image size will be automatically expanded\n        so that it fits to the bounding box of the paths. Useful for\n        rendering glyphs with negative sidebearings without clipping.\n    evenOdd: Pass ``True`` for even-odd fill instead of non-zero.\n\nReturns:\n    A tuple of ``(buffer, size)``, where ``buffer`` is a ``bytes``\n    object of the resulted bitmap and ``size`` is a 2-tuple of its\n    dimension.\n\nNotes:\n    The image size should always be given explicitly if you need to get\n    a proper glyph image. When ``width`` and ``height`` are omitted, it\n    forcifully fits to the bounding box and the side bearings get\n    cropped. If you pass ``0`` to both ``width`` and ``height`` and set\n    ``contain`` to ``True``, it expands to the bounding box while\n    maintaining the origin of the contours, meaning that LSB will be\n    maintained but RSB won\u2019t. The difference between the two becomes\n    more obvious when rotate or skew transformation is applied.\n\nExample:\n    .. code-block:: pycon\n\n        >>>\n        >> pen = FreeTypePen(None)\n        >> glyph.draw(pen)\n        >> buf, size = pen.buffer(width=500, height=1000)\n        >> type(buf), len(buf), size\n        (<class 'bytes'>, 500000, (500, 1000))"
        },
        {
          "name": "array",
          "docstring": "Returns the rendered contours as a numpy array. Requires `numpy`.\n\nArgs:\n    width: Image width of the bitmap in pixels. If omitted, it\n        automatically fits to the bounding box of the contours.\n    height: Image height of the bitmap in pixels. If omitted, it\n        automatically fits to the bounding box of the contours.\n    transform: An optional 6-tuple containing an affine transformation,\n        or a ``Transform`` object from the ``fontTools.misc.transform``\n        module. The bitmap size is not affected by this matrix.\n    contain: If ``True``, the image size will be automatically expanded\n        so that it fits to the bounding box of the paths. Useful for\n        rendering glyphs with negative sidebearings without clipping.\n    evenOdd: Pass ``True`` for even-odd fill instead of non-zero.\n\nReturns:\n    A ``numpy.ndarray`` object with a shape of ``(height, width)``.\n    Each element takes a value in the range of ``[0.0, 1.0]``.\n\nNotes:\n    The image size should always be given explicitly if you need to get\n    a proper glyph image. When ``width`` and ``height`` are omitted, it\n    forcifully fits to the bounding box and the side bearings get\n    cropped. If you pass ``0`` to both ``width`` and ``height`` and set\n    ``contain`` to ``True``, it expands to the bounding box while\n    maintaining the origin of the contours, meaning that LSB will be\n    maintained but RSB won\u2019t. The difference between the two becomes\n    more obvious when rotate or skew transformation is applied.\n\nExample:\n    .. code-block:: pycon\n\n        >>>\n        >> pen = FreeTypePen(None)\n        >> glyph.draw(pen)\n        >> arr = pen.array(width=500, height=1000)\n        >> type(a), a.shape\n        (<class 'numpy.ndarray'>, (1000, 500))"
        },
        {
          "name": "show",
          "docstring": "Plots the rendered contours with `pyplot`. Requires `numpy` and\n`matplotlib`.\n\nArgs:\n    width: Image width of the bitmap in pixels. If omitted, it\n        automatically fits to the bounding box of the contours.\n    height: Image height of the bitmap in pixels. If omitted, it\n        automatically fits to the bounding box of the contours.\n    transform: An optional 6-tuple containing an affine transformation,\n        or a ``Transform`` object from the ``fontTools.misc.transform``\n        module. The bitmap size is not affected by this matrix.\n    contain: If ``True``, the image size will be automatically expanded\n        so that it fits to the bounding box of the paths. Useful for\n        rendering glyphs with negative sidebearings without clipping.\n    evenOdd: Pass ``True`` for even-odd fill instead of non-zero.\n\nNotes:\n    The image size should always be given explicitly if you need to get\n    a proper glyph image. When ``width`` and ``height`` are omitted, it\n    forcifully fits to the bounding box and the side bearings get\n    cropped. If you pass ``0`` to both ``width`` and ``height`` and set\n    ``contain`` to ``True``, it expands to the bounding box while\n    maintaining the origin of the contours, meaning that LSB will be\n    maintained but RSB won\u2019t. The difference between the two becomes\n    more obvious when rotate or skew transformation is applied.\n\nExample:\n    .. code-block:: pycon\n\n        >>>\n        >> pen = FreeTypePen(None)\n        >> glyph.draw(pen)\n        >> pen.show(width=500, height=1000)"
        },
        {
          "name": "image",
          "docstring": "Returns the rendered contours as a PIL image. Requires `Pillow`.\nCan be used to display a glyph image in Jupyter Notebook.\n\nArgs:\n    width: Image width of the bitmap in pixels. If omitted, it\n        automatically fits to the bounding box of the contours.\n    height: Image height of the bitmap in pixels. If omitted, it\n        automatically fits to the bounding box of the contours.\n    transform: An optional 6-tuple containing an affine transformation,\n        or a ``Transform`` object from the ``fontTools.misc.transform``\n        module. The bitmap size is not affected by this matrix.\n    contain: If ``True``, the image size will be automatically expanded\n        so that it fits to the bounding box of the paths. Useful for\n        rendering glyphs with negative sidebearings without clipping.\n    evenOdd: Pass ``True`` for even-odd fill instead of non-zero.\n\nReturns:\n    A ``PIL.image`` object. The image is filled in black with alpha\n    channel obtained from the rendered bitmap.\n\nNotes:\n    The image size should always be given explicitly if you need to get\n    a proper glyph image. When ``width`` and ``height`` are omitted, it\n    forcifully fits to the bounding box and the side bearings get\n    cropped. If you pass ``0`` to both ``width`` and ``height`` and set\n    ``contain`` to ``True``, it expands to the bounding box while\n    maintaining the origin of the contours, meaning that LSB will be\n    maintained but RSB won\u2019t. The difference between the two becomes\n    more obvious when rotate or skew transformation is applied.\n\nExample:\n    .. code-block:: pycon\n\n        >>>\n        >> pen = FreeTypePen(None)\n        >> glyph.draw(pen)\n        >> img = pen.image(width=500, height=1000)\n        >> type(img), img.size\n        (<class 'PIL.Image.Image'>, (500, 1000))"
        },
        {
          "name": "bbox",
          "docstring": "Computes the exact bounding box of an outline.\n\nReturns:\n    A tuple of ``(xMin, yMin, xMax, yMax)``."
        },
        {
          "name": "cbox",
          "docstring": "Returns an outline's \u2018control box\u2019.\n\nReturns:\n    A tuple of ``(xMin, yMin, xMax, yMax)``."
        }
      ]
    }
  ],
  "functions": [
    {
      "name": "outline",
      "docstring": "Converts the current contours to ``FT_Outline``.\n\nArgs:\n    transform: An optional 6-tuple containing an affine transformation,\n        or a ``Transform`` object from the ``fontTools.misc.transform``\n        module.\n    evenOdd: Pass ``True`` for even-odd fill instead of non-zero."
    },
    {
      "name": "buffer",
      "docstring": "Renders the current contours within a bitmap buffer.\n\nArgs:\n    width: Image width of the bitmap in pixels. If omitted, it\n        automatically fits to the bounding box of the contours.\n    height: Image height of the bitmap in pixels. If omitted, it\n        automatically fits to the bounding box of the contours.\n    transform: An optional 6-tuple containing an affine transformation,\n        or a ``Transform`` object from the ``fontTools.misc.transform``\n        module. The bitmap size is not affected by this matrix.\n    contain: If ``True``, the image size will be automatically expanded\n        so that it fits to the bounding box of the paths. Useful for\n        rendering glyphs with negative sidebearings without clipping.\n    evenOdd: Pass ``True`` for even-odd fill instead of non-zero.\n\nReturns:\n    A tuple of ``(buffer, size)``, where ``buffer`` is a ``bytes``\n    object of the resulted bitmap and ``size`` is a 2-tuple of its\n    dimension.\n\nNotes:\n    The image size should always be given explicitly if you need to get\n    a proper glyph image. When ``width`` and ``height`` are omitted, it\n    forcifully fits to the bounding box and the side bearings get\n    cropped. If you pass ``0`` to both ``width`` and ``height`` and set\n    ``contain`` to ``True``, it expands to the bounding box while\n    maintaining the origin of the contours, meaning that LSB will be\n    maintained but RSB won\u2019t. The difference between the two becomes\n    more obvious when rotate or skew transformation is applied.\n\nExample:\n    .. code-block:: pycon\n\n        >>>\n        >> pen = FreeTypePen(None)\n        >> glyph.draw(pen)\n        >> buf, size = pen.buffer(width=500, height=1000)\n        >> type(buf), len(buf), size\n        (<class 'bytes'>, 500000, (500, 1000))"
    },
    {
      "name": "array",
      "docstring": "Returns the rendered contours as a numpy array. Requires `numpy`.\n\nArgs:\n    width: Image width of the bitmap in pixels. If omitted, it\n        automatically fits to the bounding box of the contours.\n    height: Image height of the bitmap in pixels. If omitted, it\n        automatically fits to the bounding box of the contours.\n    transform: An optional 6-tuple containing an affine transformation,\n        or a ``Transform`` object from the ``fontTools.misc.transform``\n        module. The bitmap size is not affected by this matrix.\n    contain: If ``True``, the image size will be automatically expanded\n        so that it fits to the bounding box of the paths. Useful for\n        rendering glyphs with negative sidebearings without clipping.\n    evenOdd: Pass ``True`` for even-odd fill instead of non-zero.\n\nReturns:\n    A ``numpy.ndarray`` object with a shape of ``(height, width)``.\n    Each element takes a value in the range of ``[0.0, 1.0]``.\n\nNotes:\n    The image size should always be given explicitly if you need to get\n    a proper glyph image. When ``width`` and ``height`` are omitted, it\n    forcifully fits to the bounding box and the side bearings get\n    cropped. If you pass ``0`` to both ``width`` and ``height`` and set\n    ``contain`` to ``True``, it expands to the bounding box while\n    maintaining the origin of the contours, meaning that LSB will be\n    maintained but RSB won\u2019t. The difference between the two becomes\n    more obvious when rotate or skew transformation is applied.\n\nExample:\n    .. code-block:: pycon\n\n        >>>\n        >> pen = FreeTypePen(None)\n        >> glyph.draw(pen)\n        >> arr = pen.array(width=500, height=1000)\n        >> type(a), a.shape\n        (<class 'numpy.ndarray'>, (1000, 500))"
    },
    {
      "name": "show",
      "docstring": "Plots the rendered contours with `pyplot`. Requires `numpy` and\n`matplotlib`.\n\nArgs:\n    width: Image width of the bitmap in pixels. If omitted, it\n        automatically fits to the bounding box of the contours.\n    height: Image height of the bitmap in pixels. If omitted, it\n        automatically fits to the bounding box of the contours.\n    transform: An optional 6-tuple containing an affine transformation,\n        or a ``Transform`` object from the ``fontTools.misc.transform``\n        module. The bitmap size is not affected by this matrix.\n    contain: If ``True``, the image size will be automatically expanded\n        so that it fits to the bounding box of the paths. Useful for\n        rendering glyphs with negative sidebearings without clipping.\n    evenOdd: Pass ``True`` for even-odd fill instead of non-zero.\n\nNotes:\n    The image size should always be given explicitly if you need to get\n    a proper glyph image. When ``width`` and ``height`` are omitted, it\n    forcifully fits to the bounding box and the side bearings get\n    cropped. If you pass ``0`` to both ``width`` and ``height`` and set\n    ``contain`` to ``True``, it expands to the bounding box while\n    maintaining the origin of the contours, meaning that LSB will be\n    maintained but RSB won\u2019t. The difference between the two becomes\n    more obvious when rotate or skew transformation is applied.\n\nExample:\n    .. code-block:: pycon\n\n        >>>\n        >> pen = FreeTypePen(None)\n        >> glyph.draw(pen)\n        >> pen.show(width=500, height=1000)"
    },
    {
      "name": "image",
      "docstring": "Returns the rendered contours as a PIL image. Requires `Pillow`.\nCan be used to display a glyph image in Jupyter Notebook.\n\nArgs:\n    width: Image width of the bitmap in pixels. If omitted, it\n        automatically fits to the bounding box of the contours.\n    height: Image height of the bitmap in pixels. If omitted, it\n        automatically fits to the bounding box of the contours.\n    transform: An optional 6-tuple containing an affine transformation,\n        or a ``Transform`` object from the ``fontTools.misc.transform``\n        module. The bitmap size is not affected by this matrix.\n    contain: If ``True``, the image size will be automatically expanded\n        so that it fits to the bounding box of the paths. Useful for\n        rendering glyphs with negative sidebearings without clipping.\n    evenOdd: Pass ``True`` for even-odd fill instead of non-zero.\n\nReturns:\n    A ``PIL.image`` object. The image is filled in black with alpha\n    channel obtained from the rendered bitmap.\n\nNotes:\n    The image size should always be given explicitly if you need to get\n    a proper glyph image. When ``width`` and ``height`` are omitted, it\n    forcifully fits to the bounding box and the side bearings get\n    cropped. If you pass ``0`` to both ``width`` and ``height`` and set\n    ``contain`` to ``True``, it expands to the bounding box while\n    maintaining the origin of the contours, meaning that LSB will be\n    maintained but RSB won\u2019t. The difference between the two becomes\n    more obvious when rotate or skew transformation is applied.\n\nExample:\n    .. code-block:: pycon\n\n        >>>\n        >> pen = FreeTypePen(None)\n        >> glyph.draw(pen)\n        >> img = pen.image(width=500, height=1000)\n        >> type(img), img.size\n        (<class 'PIL.Image.Image'>, (500, 1000))"
    },
    {
      "name": "bbox",
      "docstring": "Computes the exact bounding box of an outline.\n\nReturns:\n    A tuple of ``(xMin, yMin, xMax, yMax)``."
    },
    {
      "name": "cbox",
      "docstring": "Returns an outline's \u2018control box\u2019.\n\nReturns:\n    A tuple of ``(xMin, yMin, xMax, yMax)``."
    }
  ],
  "innovations": []
}