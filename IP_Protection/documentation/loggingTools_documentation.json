{
  "file_path": "c:\\Users\\sgbil\\OneDrive\\Desktop\\Negative_Space_Imaging_Project\\.venv\\Lib\\site-packages\\fontTools\\misc\\loggingTools.py",
  "classes": [
    {
      "name": "LevelFormatter",
      "docstring": "Log formatter with level-specific formatting.\n\nFormatter class which optionally takes a dict of logging levels to\nformat strings, allowing to customise the log records appearance for\nspecific levels.\n\n\nAttributes:\n        fmt: A dictionary mapping logging levels to format strings.\n                The ``*`` key identifies the default format string.\n        datefmt: As per py:class:`logging.Formatter`\n        style: As per py:class:`logging.Formatter`\n\n>>> import sys\n>>> handler = logging.StreamHandler(sys.stdout)\n>>> formatter = LevelFormatter(\n...     fmt={\n...         '*':     '[%(levelname)s] %(message)s',\n...         'DEBUG': '%(name)s [%(levelname)s] %(message)s',\n...         'INFO':  '%(message)s',\n...     })\n>>> handler.setFormatter(formatter)\n>>> log = logging.getLogger('test')\n>>> log.setLevel(logging.DEBUG)\n>>> log.addHandler(handler)\n>>> log.debug('this uses a custom format string')\ntest [DEBUG] this uses a custom format string\n>>> log.info('this also uses a custom format string')\nthis also uses a custom format string\n>>> log.warning(\"this one uses the default format string\")\n[WARNING] this one uses the default format string",
      "methods": [
        {
          "name": "__init__",
          "docstring": null
        },
        {
          "name": "format",
          "docstring": null
        }
      ]
    },
    {
      "name": "Timer",
      "docstring": "Keeps track of overall time and split/lap times.\n\n>>> import time\n>>> timer = Timer()\n>>> time.sleep(0.01)\n>>> print(\"First lap:\", timer.split())\nFirst lap: ...\n>>> time.sleep(0.02)\n>>> print(\"Second lap:\", timer.split())\nSecond lap: ...\n>>> print(\"Overall time:\", timer.time())\nOverall time: ...\n\nCan be used as a context manager inside with-statements.\n\n>>> with Timer() as t:\n...     time.sleep(0.01)\n>>> print(\"%0.3f seconds\" % t.elapsed)\n0... seconds\n\nIf initialised with a logger, it can log the elapsed time automatically\nupon exiting the with-statement.\n\n>>> import logging\n>>> log = logging.getLogger(\"my-fancy-timer-logger\")\n>>> configLogger(logger=log, level=\"DEBUG\", format=\"%(message)s\", stream=sys.stdout)\n>>> with Timer(log, 'do something'):\n...     time.sleep(0.01)\nTook ... to do something\n\nThe same Timer instance, holding a reference to a logger, can be reused\nin multiple with-statements, optionally with different messages or levels.\n\n>>> timer = Timer(log)\n>>> with timer():\n...     time.sleep(0.01)\nelapsed time: ...s\n>>> with timer('redo it', level=logging.INFO):\n...     time.sleep(0.02)\nTook ... to redo it\n\nIt can also be used as a function decorator to log the time elapsed to run\nthe decorated function.\n\n>>> @timer()\n... def test1():\n...    time.sleep(0.01)\n>>> @timer('run test 2', level=logging.INFO)\n... def test2():\n...    time.sleep(0.02)\n>>> test1()\nTook ... to run 'test1'\n>>> test2()\nTook ... to run test 2",
      "methods": [
        {
          "name": "__init__",
          "docstring": null
        },
        {
          "name": "reset",
          "docstring": "Reset timer to 'start_time' or the current time."
        },
        {
          "name": "time",
          "docstring": "Return the overall time (in seconds) since the timer started."
        },
        {
          "name": "split",
          "docstring": "Split and return the lap time (in seconds) in between splits."
        },
        {
          "name": "formatTime",
          "docstring": "Format 'time' value in 'msg' and return formatted string.\nIf 'msg' contains a '%(time)' format string, try to use that.\nOtherwise, use the predefined 'default_format'.\nIf 'msg' is empty or None, fall back to 'default_msg'."
        }
      ]
    },
    {
      "name": "ChannelsFilter",
      "docstring": "Provides a hierarchical filter for log entries based on channel names.\n\nFilters out records emitted from a list of enabled channel names,\nincluding their children. It works the same as the ``logging.Filter``\nclass, but allows the user to specify multiple channel names.\n\n>>> import sys\n>>> handler = logging.StreamHandler(sys.stdout)\n>>> handler.setFormatter(logging.Formatter(\"%(message)s\"))\n>>> filter = ChannelsFilter(\"A.B\", \"C.D\")\n>>> handler.addFilter(filter)\n>>> root = logging.getLogger()\n>>> root.addHandler(handler)\n>>> root.setLevel(level=logging.DEBUG)\n>>> logging.getLogger('A.B').debug('this record passes through')\nthis record passes through\n>>> logging.getLogger('A.B.C').debug('records from children also pass')\nrecords from children also pass\n>>> logging.getLogger('C.D').debug('this one as well')\nthis one as well\n>>> logging.getLogger('A.B.').debug('also this one')\nalso this one\n>>> logging.getLogger('A.F').debug('but this one does not!')\n>>> logging.getLogger('C.DE').debug('neither this one!')",
      "methods": [
        {
          "name": "__init__",
          "docstring": null
        },
        {
          "name": "filter",
          "docstring": null
        }
      ]
    },
    {
      "name": "CapturingLogHandler",
      "docstring": null,
      "methods": [
        {
          "name": "__init__",
          "docstring": null
        },
        {
          "name": "emit",
          "docstring": null
        },
        {
          "name": "assertRegex",
          "docstring": null
        }
      ]
    },
    {
      "name": "LogMixin",
      "docstring": "Mixin class that adds logging functionality to another class.\n\nYou can define a new class that subclasses from ``LogMixin`` as well as\nother base classes through multiple inheritance.\nAll instances of that class will have a ``log`` property that returns\na ``logging.Logger`` named after their respective ``<module>.<class>``.\n\nFor example:\n\n>>> class BaseClass(object):\n...     pass\n>>> class MyClass(LogMixin, BaseClass):\n...     pass\n>>> a = MyClass()\n>>> isinstance(a.log, logging.Logger)\nTrue\n>>> print(a.log.name)\nfontTools.misc.loggingTools.MyClass\n>>> class AnotherClass(MyClass):\n...     pass\n>>> b = AnotherClass()\n>>> isinstance(b.log, logging.Logger)\nTrue\n>>> print(b.log.name)\nfontTools.misc.loggingTools.AnotherClass",
      "methods": [
        {
          "name": "log",
          "docstring": null
        }
      ]
    }
  ],
  "functions": [
    {
      "name": "configLogger",
      "docstring": "A more sophisticated logging system configuation manager.\n\nThis is more or less the same as :py:func:`logging.basicConfig`,\nwith some additional options and defaults.\n\nThe default behaviour is to create a ``StreamHandler`` which writes to\nsys.stderr, set a formatter using the ``DEFAULT_FORMATS`` strings, and add\nthe handler to the top-level library logger (\"fontTools\").\n\nA number of optional keyword arguments may be specified, which can alter\nthe default behaviour.\n\nArgs:\n\n        logger: Specifies the logger name or a Logger instance to be\n                configured. (Defaults to \"fontTools\" logger). Unlike ``basicConfig``,\n                this function can be called multiple times to reconfigure a logger.\n                If the logger or any of its children already exists before the call is\n                made, they will be reset before the new configuration is applied.\n        filename: Specifies that a ``FileHandler`` be created, using the\n                specified filename, rather than a ``StreamHandler``.\n        filemode: Specifies the mode to open the file, if filename is\n                specified. (If filemode is unspecified, it defaults to ``a``).\n        format: Use the specified format string for the handler. This\n                argument also accepts a dictionary of format strings keyed by\n                level name, to allow customising the records appearance for\n                specific levels. The special ``'*'`` key is for 'any other' level.\n        datefmt: Use the specified date/time format.\n        level: Set the logger level to the specified level.\n        stream: Use the specified stream to initialize the StreamHandler. Note\n                that this argument is incompatible with ``filename`` - if both\n                are present, ``stream`` is ignored.\n        handlers: If specified, this should be an iterable of already created\n                handlers, which will be added to the logger. Any handler in the\n                list which does not have a formatter assigned will be assigned the\n                formatter created in this function.\n        filters: If specified, this should be an iterable of already created\n                filters. If the ``handlers`` do not already have filters assigned,\n                these filters will be added to them.\n        propagate: All loggers have a ``propagate`` attribute which determines\n                whether to continue searching for handlers up the logging hierarchy.\n                If not provided, the \"propagate\" attribute will be set to ``False``."
    },
    {
      "name": "deprecateArgument",
      "docstring": "Raise a warning about deprecated function argument 'name'."
    },
    {
      "name": "deprecateFunction",
      "docstring": "Decorator to raise a warning when a deprecated function is called."
    },
    {
      "name": "format",
      "docstring": null
    },
    {
      "name": "reset",
      "docstring": "Reset timer to 'start_time' or the current time."
    },
    {
      "name": "time",
      "docstring": "Return the overall time (in seconds) since the timer started."
    },
    {
      "name": "split",
      "docstring": "Split and return the lap time (in seconds) in between splits."
    },
    {
      "name": "formatTime",
      "docstring": "Format 'time' value in 'msg' and return formatted string.\nIf 'msg' contains a '%(time)' format string, try to use that.\nOtherwise, use the predefined 'default_format'.\nIf 'msg' is empty or None, fall back to 'default_msg'."
    },
    {
      "name": "filter",
      "docstring": null
    },
    {
      "name": "emit",
      "docstring": null
    },
    {
      "name": "assertRegex",
      "docstring": null
    },
    {
      "name": "log",
      "docstring": null
    },
    {
      "name": "decorator",
      "docstring": null
    },
    {
      "name": "wrapper",
      "docstring": null
    },
    {
      "name": "wrapper",
      "docstring": null
    }
  ],
  "innovations": []
}