{
  "file_path": "c:\\Users\\sgbil\\OneDrive\\Desktop\\Negative_Space_Imaging_Project\\.venv\\Lib\\site-packages\\numpy\\lib\\_type_check_impl.py",
  "classes": [],
  "functions": [
    {
      "name": "mintypecode",
      "docstring": "Return the character for the minimum-size type to which given types can\nbe safely cast.\n\nThe returned type character must represent the smallest size dtype such\nthat an array of the returned type can handle the data from an array of\nall types in `typechars` (or if `typechars` is an array, then its\ndtype.char).\n\nParameters\n----------\ntypechars : list of str or array_like\n    If a list of strings, each string should represent a dtype.\n    If array_like, the character representation of the array dtype is used.\ntypeset : str or list of str, optional\n    The set of characters that the returned character is chosen from.\n    The default set is 'GDFgdf'.\ndefault : str, optional\n    The default character, this is returned if none of the characters in\n    `typechars` matches a character in `typeset`.\n\nReturns\n-------\ntypechar : str\n    The character representing the minimum-size type that was found.\n\nSee Also\n--------\ndtype\n\nExamples\n--------\n>>> import numpy as np\n>>> np.mintypecode(['d', 'f', 'S'])\n'd'\n>>> x = np.array([1.1, 2-3.j])\n>>> np.mintypecode(x)\n'D'\n\n>>> np.mintypecode('abceh', default='G')\n'G'"
    },
    {
      "name": "real",
      "docstring": "Return the real part of the complex argument.\n\nParameters\n----------\nval : array_like\n    Input array.\n\nReturns\n-------\nout : ndarray or scalar\n    The real component of the complex argument. If `val` is real, the type\n    of `val` is used for the output.  If `val` has complex elements, the\n    returned type is float.\n\nSee Also\n--------\nreal_if_close, imag, angle\n\nExamples\n--------\n>>> import numpy as np\n>>> a = np.array([1+2j, 3+4j, 5+6j])\n>>> a.real\narray([1.,  3.,  5.])\n>>> a.real = 9\n>>> a\narray([9.+2.j,  9.+4.j,  9.+6.j])\n>>> a.real = np.array([9, 8, 7])\n>>> a\narray([9.+2.j,  8.+4.j,  7.+6.j])\n>>> np.real(1 + 1j)\n1.0"
    },
    {
      "name": "imag",
      "docstring": "Return the imaginary part of the complex argument.\n\nParameters\n----------\nval : array_like\n    Input array.\n\nReturns\n-------\nout : ndarray or scalar\n    The imaginary component of the complex argument. If `val` is real,\n    the type of `val` is used for the output.  If `val` has complex\n    elements, the returned type is float.\n\nSee Also\n--------\nreal, angle, real_if_close\n\nExamples\n--------\n>>> import numpy as np\n>>> a = np.array([1+2j, 3+4j, 5+6j])\n>>> a.imag\narray([2.,  4.,  6.])\n>>> a.imag = np.array([8, 10, 12])\n>>> a\narray([1. +8.j,  3.+10.j,  5.+12.j])\n>>> np.imag(1 + 1j)\n1.0"
    },
    {
      "name": "iscomplex",
      "docstring": "Returns a bool array, where True if input element is complex.\n\nWhat is tested is whether the input has a non-zero imaginary part, not if\nthe input type is complex.\n\nParameters\n----------\nx : array_like\n    Input array.\n\nReturns\n-------\nout : ndarray of bools\n    Output array.\n\nSee Also\n--------\nisreal\niscomplexobj : Return True if x is a complex type or an array of complex\n               numbers.\n\nExamples\n--------\n>>> import numpy as np\n>>> np.iscomplex([1+1j, 1+0j, 4.5, 3, 2, 2j])\narray([ True, False, False, False, False,  True])"
    },
    {
      "name": "isreal",
      "docstring": "Returns a bool array, where True if input element is real.\n\nIf element has complex type with zero imaginary part, the return value\nfor that element is True.\n\nParameters\n----------\nx : array_like\n    Input array.\n\nReturns\n-------\nout : ndarray, bool\n    Boolean array of same shape as `x`.\n\nNotes\n-----\n`isreal` may behave unexpectedly for string or object arrays (see examples)\n\nSee Also\n--------\niscomplex\nisrealobj : Return True if x is not a complex type.\n\nExamples\n--------\n>>> import numpy as np\n>>> a = np.array([1+1j, 1+0j, 4.5, 3, 2, 2j], dtype=complex)\n>>> np.isreal(a)\narray([False,  True,  True,  True,  True, False])\n\nThe function does not work on string arrays.\n\n>>> a = np.array([2j, \"a\"], dtype=\"U\")\n>>> np.isreal(a)  # Warns about non-elementwise comparison\nFalse\n\nReturns True for all elements in input array of ``dtype=object`` even if\nany of the elements is complex.\n\n>>> a = np.array([1, \"2\", 3+4j], dtype=object)\n>>> np.isreal(a)\narray([ True,  True,  True])\n\nisreal should not be used with object arrays\n\n>>> a = np.array([1+2j, 2+1j], dtype=object)\n>>> np.isreal(a)\narray([ True,  True])"
    },
    {
      "name": "iscomplexobj",
      "docstring": "Check for a complex type or an array of complex numbers.\n\nThe type of the input is checked, not the value. Even if the input\nhas an imaginary part equal to zero, `iscomplexobj` evaluates to True.\n\nParameters\n----------\nx : any\n    The input can be of any type and shape.\n\nReturns\n-------\niscomplexobj : bool\n    The return value, True if `x` is of a complex type or has at least\n    one complex element.\n\nSee Also\n--------\nisrealobj, iscomplex\n\nExamples\n--------\n>>> import numpy as np\n>>> np.iscomplexobj(1)\nFalse\n>>> np.iscomplexobj(1+0j)\nTrue\n>>> np.iscomplexobj([3, 1+0j, True])\nTrue"
    },
    {
      "name": "isrealobj",
      "docstring": "Return True if x is a not complex type or an array of complex numbers.\n\nThe type of the input is checked, not the value. So even if the input\nhas an imaginary part equal to zero, `isrealobj` evaluates to False\nif the data type is complex.\n\nParameters\n----------\nx : any\n    The input can be of any type and shape.\n\nReturns\n-------\ny : bool\n    The return value, False if `x` is of a complex type.\n\nSee Also\n--------\niscomplexobj, isreal\n\nNotes\n-----\nThe function is only meant for arrays with numerical values but it\naccepts all other objects. Since it assumes array input, the return\nvalue of other objects may be True.\n\n>>> np.isrealobj('A string')\nTrue\n>>> np.isrealobj(False)\nTrue\n>>> np.isrealobj(None)\nTrue\n\nExamples\n--------\n>>> import numpy as np\n>>> np.isrealobj(1)\nTrue\n>>> np.isrealobj(1+0j)\nFalse\n>>> np.isrealobj([3, 1+0j, True])\nFalse"
    },
    {
      "name": "nan_to_num",
      "docstring": "Replace NaN with zero and infinity with large finite numbers (default\nbehaviour) or with the numbers defined by the user using the `nan`,\n`posinf` and/or `neginf` keywords.\n\nIf `x` is inexact, NaN is replaced by zero or by the user defined value in\n`nan` keyword, infinity is replaced by the largest finite floating point\nvalues representable by ``x.dtype`` or by the user defined value in\n`posinf` keyword and -infinity is replaced by the most negative finite\nfloating point values representable by ``x.dtype`` or by the user defined\nvalue in `neginf` keyword.\n\nFor complex dtypes, the above is applied to each of the real and\nimaginary components of `x` separately.\n\nIf `x` is not inexact, then no replacements are made.\n\nParameters\n----------\nx : scalar or array_like\n    Input data.\ncopy : bool, optional\n    Whether to create a copy of `x` (True) or to replace values\n    in-place (False). The in-place operation only occurs if\n    casting to an array does not require a copy.\n    Default is True.\nnan : int, float, optional\n    Value to be used to fill NaN values. If no value is passed\n    then NaN values will be replaced with 0.0.\nposinf : int, float, optional\n    Value to be used to fill positive infinity values. If no value is\n    passed then positive infinity values will be replaced with a very\n    large number.\nneginf : int, float, optional\n    Value to be used to fill negative infinity values. If no value is\n    passed then negative infinity values will be replaced with a very\n    small (or negative) number.\n\nReturns\n-------\nout : ndarray\n    `x`, with the non-finite values replaced. If `copy` is False, this may\n    be `x` itself.\n\nSee Also\n--------\nisinf : Shows which elements are positive or negative infinity.\nisneginf : Shows which elements are negative infinity.\nisposinf : Shows which elements are positive infinity.\nisnan : Shows which elements are Not a Number (NaN).\nisfinite : Shows which elements are finite (not NaN, not infinity)\n\nNotes\n-----\nNumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n(IEEE 754). This means that Not a Number is not equivalent to infinity.\n\nExamples\n--------\n>>> import numpy as np\n>>> np.nan_to_num(np.inf)\n1.7976931348623157e+308\n>>> np.nan_to_num(-np.inf)\n-1.7976931348623157e+308\n>>> np.nan_to_num(np.nan)\n0.0\n>>> x = np.array([np.inf, -np.inf, np.nan, -128, 128])\n>>> np.nan_to_num(x)\narray([ 1.79769313e+308, -1.79769313e+308,  0.00000000e+000, # may vary\n       -1.28000000e+002,  1.28000000e+002])\n>>> np.nan_to_num(x, nan=-9999, posinf=33333333, neginf=33333333)\narray([ 3.3333333e+07,  3.3333333e+07, -9.9990000e+03,\n       -1.2800000e+02,  1.2800000e+02])\n>>> y = np.array([complex(np.inf, np.nan), np.nan, complex(np.nan, np.inf)])\narray([  1.79769313e+308,  -1.79769313e+308,   0.00000000e+000, # may vary\n     -1.28000000e+002,   1.28000000e+002])\n>>> np.nan_to_num(y)\narray([  1.79769313e+308 +0.00000000e+000j, # may vary\n         0.00000000e+000 +0.00000000e+000j,\n         0.00000000e+000 +1.79769313e+308j])\n>>> np.nan_to_num(y, nan=111111, posinf=222222)\narray([222222.+111111.j, 111111.     +0.j, 111111.+222222.j])"
    },
    {
      "name": "real_if_close",
      "docstring": "If input is complex with all imaginary parts close to zero, return\nreal parts.\n\n\"Close to zero\" is defined as `tol` * (machine epsilon of the type for\n`a`).\n\nParameters\n----------\na : array_like\n    Input array.\ntol : float\n    Tolerance in machine epsilons for the complex part of the elements\n    in the array. If the tolerance is <=1, then the absolute tolerance\n    is used.\n\nReturns\n-------\nout : ndarray\n    If `a` is real, the type of `a` is used for the output.  If `a`\n    has complex elements, the returned type is float.\n\nSee Also\n--------\nreal, imag, angle\n\nNotes\n-----\nMachine epsilon varies from machine to machine and between data types\nbut Python floats on most platforms have a machine epsilon equal to\n2.2204460492503131e-16.  You can use 'np.finfo(float).eps' to print\nout the machine epsilon for floats.\n\nExamples\n--------\n>>> import numpy as np\n>>> np.finfo(float).eps\n2.2204460492503131e-16 # may vary\n\n>>> np.real_if_close([2.1 + 4e-14j, 5.2 + 3e-15j], tol=1000)\narray([2.1, 5.2])\n>>> np.real_if_close([2.1 + 4e-13j, 5.2 + 3e-15j], tol=1000)\narray([2.1+4.e-13j, 5.2 + 3e-15j])"
    },
    {
      "name": "typename",
      "docstring": "Return a description for the given data type code.\n\nParameters\n----------\nchar : str\n    Data type code.\n\nReturns\n-------\nout : str\n    Description of the input data type code.\n\nSee Also\n--------\ndtype\n\nExamples\n--------\n>>> import numpy as np\n>>> typechars = ['S1', '?', 'B', 'D', 'G', 'F', 'I', 'H', 'L', 'O', 'Q',\n...              'S', 'U', 'V', 'b', 'd', 'g', 'f', 'i', 'h', 'l', 'q']\n>>> for typechar in typechars:\n...     print(typechar, ' : ', np.typename(typechar))\n...\nS1  :  character\n?  :  bool\nB  :  unsigned char\nD  :  complex double precision\nG  :  complex long double precision\nF  :  complex single precision\nI  :  unsigned integer\nH  :  unsigned short\nL  :  unsigned long integer\nO  :  object\nQ  :  unsigned long long integer\nS  :  string\nU  :  unicode\nV  :  void\nb  :  signed char\nd  :  double precision\ng  :  long precision\nf  :  single precision\ni  :  integer\nh  :  short\nl  :  long integer\nq  :  long long integer"
    },
    {
      "name": "common_type",
      "docstring": "Return a scalar type which is common to the input arrays.\n\nThe return type will always be an inexact (i.e. floating point) scalar\ntype, even if all the arrays are integer arrays. If one of the inputs is\nan integer array, the minimum precision type that is returned is a\n64-bit floating point dtype.\n\nAll input arrays except int64 and uint64 can be safely cast to the\nreturned dtype without loss of information.\n\nParameters\n----------\narray1, array2, ... : ndarrays\n    Input arrays.\n\nReturns\n-------\nout : data type code\n    Data type code.\n\nSee Also\n--------\ndtype, mintypecode\n\nExamples\n--------\n>>> np.common_type(np.arange(2, dtype=np.float32))\n<class 'numpy.float32'>\n>>> np.common_type(np.arange(2, dtype=np.float32), np.arange(2))\n<class 'numpy.float64'>\n>>> np.common_type(np.arange(4), np.array([45, 6.j]), np.array([45.0]))\n<class 'numpy.complex128'>"
    }
  ],
  "innovations": []
}