{
  "file_path": "c:\\Users\\sgbil\\OneDrive\\Desktop\\Negative_Space_Imaging_Project\\.venv\\Lib\\site-packages\\fontTools\\misc\\bezierTools.py",
  "classes": [],
  "functions": [
    {
      "name": "calcCubicArcLength",
      "docstring": "Calculates the arc length for a cubic Bezier segment.\n\nWhereas :func:`approximateCubicArcLength` approximates the length, this\nfunction calculates it by \"measuring\", recursively dividing the curve\nuntil the divided segments are shorter than ``tolerance``.\n\nArgs:\n    pt1,pt2,pt3,pt4: Control points of the Bezier as 2D tuples.\n    tolerance: Controls the precision of the calcuation.\n\nReturns:\n    Arc length value."
    },
    {
      "name": "calcCubicArcLengthC",
      "docstring": "Calculates the arc length for a cubic Bezier segment.\n\nArgs:\n    pt1,pt2,pt3,pt4: Control points of the Bezier as complex numbers.\n    tolerance: Controls the precision of the calcuation.\n\nReturns:\n    Arc length value."
    },
    {
      "name": "calcQuadraticArcLength",
      "docstring": "Calculates the arc length for a quadratic Bezier segment.\n\nArgs:\n    pt1: Start point of the Bezier as 2D tuple.\n    pt2: Handle point of the Bezier as 2D tuple.\n    pt3: End point of the Bezier as 2D tuple.\n\nReturns:\n    Arc length value.\n\nExample::\n\n    >>> calcQuadraticArcLength((0, 0), (0, 0), (0, 0)) # empty segment\n    0.0\n    >>> calcQuadraticArcLength((0, 0), (50, 0), (80, 0)) # collinear points\n    80.0\n    >>> calcQuadraticArcLength((0, 0), (0, 50), (0, 80)) # collinear points vertical\n    80.0\n    >>> calcQuadraticArcLength((0, 0), (50, 20), (100, 40)) # collinear points\n    107.70329614269008\n    >>> calcQuadraticArcLength((0, 0), (0, 100), (100, 0))\n    154.02976155645263\n    >>> calcQuadraticArcLength((0, 0), (0, 50), (100, 0))\n    120.21581243984076\n    >>> calcQuadraticArcLength((0, 0), (50, -10), (80, 50))\n    102.53273816445825\n    >>> calcQuadraticArcLength((0, 0), (40, 0), (-40, 0)) # collinear points, control point outside\n    66.66666666666667\n    >>> calcQuadraticArcLength((0, 0), (40, 0), (0, 0)) # collinear points, looping back\n    40.0"
    },
    {
      "name": "calcQuadraticArcLengthC",
      "docstring": "Calculates the arc length for a quadratic Bezier segment.\n\nArgs:\n    pt1: Start point of the Bezier as a complex number.\n    pt2: Handle point of the Bezier as a complex number.\n    pt3: End point of the Bezier as a complex number.\n\nReturns:\n    Arc length value."
    },
    {
      "name": "approximateQuadraticArcLength",
      "docstring": "Calculates the arc length for a quadratic Bezier segment.\n\nUses Gauss-Legendre quadrature for a branch-free approximation.\nSee :func:`calcQuadraticArcLength` for a slower but more accurate result.\n\nArgs:\n    pt1: Start point of the Bezier as 2D tuple.\n    pt2: Handle point of the Bezier as 2D tuple.\n    pt3: End point of the Bezier as 2D tuple.\n\nReturns:\n    Approximate arc length value."
    },
    {
      "name": "approximateQuadraticArcLengthC",
      "docstring": "Calculates the arc length for a quadratic Bezier segment.\n\nUses Gauss-Legendre quadrature for a branch-free approximation.\nSee :func:`calcQuadraticArcLength` for a slower but more accurate result.\n\nArgs:\n    pt1: Start point of the Bezier as a complex number.\n    pt2: Handle point of the Bezier as a complex number.\n    pt3: End point of the Bezier as a complex number.\n\nReturns:\n    Approximate arc length value."
    },
    {
      "name": "calcQuadraticBounds",
      "docstring": "Calculates the bounding rectangle for a quadratic Bezier segment.\n\nArgs:\n    pt1: Start point of the Bezier as a 2D tuple.\n    pt2: Handle point of the Bezier as a 2D tuple.\n    pt3: End point of the Bezier as a 2D tuple.\n\nReturns:\n    A four-item tuple representing the bounding rectangle ``(xMin, yMin, xMax, yMax)``.\n\nExample::\n\n    >>> calcQuadraticBounds((0, 0), (50, 100), (100, 0))\n    (0, 0, 100, 50.0)\n    >>> calcQuadraticBounds((0, 0), (100, 0), (100, 100))\n    (0.0, 0.0, 100, 100)"
    },
    {
      "name": "approximateCubicArcLength",
      "docstring": "Approximates the arc length for a cubic Bezier segment.\n\nUses Gauss-Lobatto quadrature with n=5 points to approximate arc length.\nSee :func:`calcCubicArcLength` for a slower but more accurate result.\n\nArgs:\n    pt1,pt2,pt3,pt4: Control points of the Bezier as 2D tuples.\n\nReturns:\n    Arc length value.\n\nExample::\n\n    >>> approximateCubicArcLength((0, 0), (25, 100), (75, 100), (100, 0))\n    190.04332968932817\n    >>> approximateCubicArcLength((0, 0), (50, 0), (100, 50), (100, 100))\n    154.8852074945903\n    >>> approximateCubicArcLength((0, 0), (50, 0), (100, 0), (150, 0)) # line; exact result should be 150.\n    149.99999999999991\n    >>> approximateCubicArcLength((0, 0), (50, 0), (100, 0), (-50, 0)) # cusp; exact result should be 150.\n    136.9267662156362\n    >>> approximateCubicArcLength((0, 0), (50, 0), (100, -50), (-50, 0)) # cusp\n    154.80848416537057"
    },
    {
      "name": "approximateCubicArcLengthC",
      "docstring": "Approximates the arc length for a cubic Bezier segment.\n\nArgs:\n    pt1,pt2,pt3,pt4: Control points of the Bezier as complex numbers.\n\nReturns:\n    Arc length value."
    },
    {
      "name": "calcCubicBounds",
      "docstring": "Calculates the bounding rectangle for a quadratic Bezier segment.\n\nArgs:\n    pt1,pt2,pt3,pt4: Control points of the Bezier as 2D tuples.\n\nReturns:\n    A four-item tuple representing the bounding rectangle ``(xMin, yMin, xMax, yMax)``.\n\nExample::\n\n    >>> calcCubicBounds((0, 0), (25, 100), (75, 100), (100, 0))\n    (0, 0, 100, 75.0)\n    >>> calcCubicBounds((0, 0), (50, 0), (100, 50), (100, 100))\n    (0.0, 0.0, 100, 100)\n    >>> print(\"%f %f %f %f\" % calcCubicBounds((50, 0), (0, 100), (100, 100), (50, 0)))\n    35.566243 0.000000 64.433757 75.000000"
    },
    {
      "name": "splitLine",
      "docstring": "Split a line at a given coordinate.\n\nArgs:\n    pt1: Start point of line as 2D tuple.\n    pt2: End point of line as 2D tuple.\n    where: Position at which to split the line.\n    isHorizontal: Direction of the ray splitting the line. If true,\n        ``where`` is interpreted as a Y coordinate; if false, then\n        ``where`` is interpreted as an X coordinate.\n\nReturns:\n    A list of two line segments (each line segment being two 2D tuples)\n    if the line was successfully split, or a list containing the original\n    line.\n\nExample::\n\n    >>> printSegments(splitLine((0, 0), (100, 100), 50, True))\n    ((0, 0), (50, 50))\n    ((50, 50), (100, 100))\n    >>> printSegments(splitLine((0, 0), (100, 100), 100, True))\n    ((0, 0), (100, 100))\n    >>> printSegments(splitLine((0, 0), (100, 100), 0, True))\n    ((0, 0), (0, 0))\n    ((0, 0), (100, 100))\n    >>> printSegments(splitLine((0, 0), (100, 100), 0, False))\n    ((0, 0), (0, 0))\n    ((0, 0), (100, 100))\n    >>> printSegments(splitLine((100, 0), (0, 0), 50, False))\n    ((100, 0), (50, 0))\n    ((50, 0), (0, 0))\n    >>> printSegments(splitLine((0, 100), (0, 0), 50, True))\n    ((0, 100), (0, 50))\n    ((0, 50), (0, 0))"
    },
    {
      "name": "splitQuadratic",
      "docstring": "Split a quadratic Bezier curve at a given coordinate.\n\nArgs:\n    pt1,pt2,pt3: Control points of the Bezier as 2D tuples.\n    where: Position at which to split the curve.\n    isHorizontal: Direction of the ray splitting the curve. If true,\n        ``where`` is interpreted as a Y coordinate; if false, then\n        ``where`` is interpreted as an X coordinate.\n\nReturns:\n    A list of two curve segments (each curve segment being three 2D tuples)\n    if the curve was successfully split, or a list containing the original\n    curve.\n\nExample::\n\n    >>> printSegments(splitQuadratic((0, 0), (50, 100), (100, 0), 150, False))\n    ((0, 0), (50, 100), (100, 0))\n    >>> printSegments(splitQuadratic((0, 0), (50, 100), (100, 0), 50, False))\n    ((0, 0), (25, 50), (50, 50))\n    ((50, 50), (75, 50), (100, 0))\n    >>> printSegments(splitQuadratic((0, 0), (50, 100), (100, 0), 25, False))\n    ((0, 0), (12.5, 25), (25, 37.5))\n    ((25, 37.5), (62.5, 75), (100, 0))\n    >>> printSegments(splitQuadratic((0, 0), (50, 100), (100, 0), 25, True))\n    ((0, 0), (7.32233, 14.6447), (14.6447, 25))\n    ((14.6447, 25), (50, 75), (85.3553, 25))\n    ((85.3553, 25), (92.6777, 14.6447), (100, -7.10543e-15))\n    >>> # XXX I'm not at all sure if the following behavior is desirable:\n    >>> printSegments(splitQuadratic((0, 0), (50, 100), (100, 0), 50, True))\n    ((0, 0), (25, 50), (50, 50))\n    ((50, 50), (50, 50), (50, 50))\n    ((50, 50), (75, 50), (100, 0))"
    },
    {
      "name": "splitCubic",
      "docstring": "Split a cubic Bezier curve at a given coordinate.\n\nArgs:\n    pt1,pt2,pt3,pt4: Control points of the Bezier as 2D tuples.\n    where: Position at which to split the curve.\n    isHorizontal: Direction of the ray splitting the curve. If true,\n        ``where`` is interpreted as a Y coordinate; if false, then\n        ``where`` is interpreted as an X coordinate.\n\nReturns:\n    A list of two curve segments (each curve segment being four 2D tuples)\n    if the curve was successfully split, or a list containing the original\n    curve.\n\nExample::\n\n    >>> printSegments(splitCubic((0, 0), (25, 100), (75, 100), (100, 0), 150, False))\n    ((0, 0), (25, 100), (75, 100), (100, 0))\n    >>> printSegments(splitCubic((0, 0), (25, 100), (75, 100), (100, 0), 50, False))\n    ((0, 0), (12.5, 50), (31.25, 75), (50, 75))\n    ((50, 75), (68.75, 75), (87.5, 50), (100, 0))\n    >>> printSegments(splitCubic((0, 0), (25, 100), (75, 100), (100, 0), 25, True))\n    ((0, 0), (2.29379, 9.17517), (4.79804, 17.5085), (7.47414, 25))\n    ((7.47414, 25), (31.2886, 91.6667), (68.7114, 91.6667), (92.5259, 25))\n    ((92.5259, 25), (95.202, 17.5085), (97.7062, 9.17517), (100, 1.77636e-15))"
    },
    {
      "name": "splitQuadraticAtT",
      "docstring": "Split a quadratic Bezier curve at one or more values of t.\n\nArgs:\n    pt1,pt2,pt3: Control points of the Bezier as 2D tuples.\n    *ts: Positions at which to split the curve.\n\nReturns:\n    A list of curve segments (each curve segment being three 2D tuples).\n\nExamples::\n\n    >>> printSegments(splitQuadraticAtT((0, 0), (50, 100), (100, 0), 0.5))\n    ((0, 0), (25, 50), (50, 50))\n    ((50, 50), (75, 50), (100, 0))\n    >>> printSegments(splitQuadraticAtT((0, 0), (50, 100), (100, 0), 0.5, 0.75))\n    ((0, 0), (25, 50), (50, 50))\n    ((50, 50), (62.5, 50), (75, 37.5))\n    ((75, 37.5), (87.5, 25), (100, 0))"
    },
    {
      "name": "splitCubicAtT",
      "docstring": "Split a cubic Bezier curve at one or more values of t.\n\nArgs:\n    pt1,pt2,pt3,pt4: Control points of the Bezier as 2D tuples.\n    *ts: Positions at which to split the curve.\n\nReturns:\n    A list of curve segments (each curve segment being four 2D tuples).\n\nExamples::\n\n    >>> printSegments(splitCubicAtT((0, 0), (25, 100), (75, 100), (100, 0), 0.5))\n    ((0, 0), (12.5, 50), (31.25, 75), (50, 75))\n    ((50, 75), (68.75, 75), (87.5, 50), (100, 0))\n    >>> printSegments(splitCubicAtT((0, 0), (25, 100), (75, 100), (100, 0), 0.5, 0.75))\n    ((0, 0), (12.5, 50), (31.25, 75), (50, 75))\n    ((50, 75), (59.375, 75), (68.75, 68.75), (77.3438, 56.25))\n    ((77.3438, 56.25), (85.9375, 43.75), (93.75, 25), (100, 0))"
    },
    {
      "name": "splitCubicAtTC",
      "docstring": "Split a cubic Bezier curve at one or more values of t.\n\nArgs:\n    pt1,pt2,pt3,pt4: Control points of the Bezier as complex numbers..\n    *ts: Positions at which to split the curve.\n\nYields:\n    Curve segments (each curve segment being four complex numbers)."
    },
    {
      "name": "splitCubicIntoTwoAtTC",
      "docstring": "Split a cubic Bezier curve at t.\n\nArgs:\n    pt1,pt2,pt3,pt4: Control points of the Bezier as complex numbers.\n    t: Position at which to split the curve.\n\nReturns:\n    A tuple of two curve segments (each curve segment being four complex numbers)."
    },
    {
      "name": "solveQuadratic",
      "docstring": "Solve a quadratic equation.\n\nSolves *a*x*x + b*x + c = 0* where a, b and c are real.\n\nArgs:\n    a: coefficient of *x\u00b2*\n    b: coefficient of *x*\n    c: constant term\n\nReturns:\n    A list of roots. Note that the returned list is neither guaranteed to\n    be sorted nor to contain unique values!"
    },
    {
      "name": "solveCubic",
      "docstring": "Solve a cubic equation.\n\nSolves *a*x*x*x + b*x*x + c*x + d = 0* where a, b, c and d are real.\n\nArgs:\n    a: coefficient of *x\u00b3*\n    b: coefficient of *x\u00b2*\n    c: coefficient of *x*\n    d: constant term\n\nReturns:\n    A list of roots. Note that the returned list is neither guaranteed to\n    be sorted nor to contain unique values!\n\nExamples::\n\n    >>> solveCubic(1, 1, -6, 0)\n    [-3.0, -0.0, 2.0]\n    >>> solveCubic(-10.0, -9.0, 48.0, -29.0)\n    [-2.9, 1.0, 1.0]\n    >>> solveCubic(-9.875, -9.0, 47.625, -28.75)\n    [-2.911392, 1.0, 1.0]\n    >>> solveCubic(1.0, -4.5, 6.75, -3.375)\n    [1.5, 1.5, 1.5]\n    >>> solveCubic(-12.0, 18.0, -9.0, 1.50023651123)\n    [0.5, 0.5, 0.5]\n    >>> solveCubic(\n    ...     9.0, 0.0, 0.0, -7.62939453125e-05\n    ... ) == [-0.0, -0.0, -0.0]\n    True"
    },
    {
      "name": "calcQuadraticParameters",
      "docstring": null
    },
    {
      "name": "calcCubicParameters",
      "docstring": null
    },
    {
      "name": "calcCubicParametersC",
      "docstring": null
    },
    {
      "name": "calcQuadraticPoints",
      "docstring": null
    },
    {
      "name": "calcCubicPoints",
      "docstring": null
    },
    {
      "name": "calcCubicPointsC",
      "docstring": null
    },
    {
      "name": "linePointAtT",
      "docstring": "Finds the point at time `t` on a line.\n\nArgs:\n    pt1, pt2: Coordinates of the line as 2D tuples.\n    t: The time along the line.\n\nReturns:\n    A 2D tuple with the coordinates of the point."
    },
    {
      "name": "quadraticPointAtT",
      "docstring": "Finds the point at time `t` on a quadratic curve.\n\nArgs:\n    pt1, pt2, pt3: Coordinates of the curve as 2D tuples.\n    t: The time along the curve.\n\nReturns:\n    A 2D tuple with the coordinates of the point."
    },
    {
      "name": "cubicPointAtT",
      "docstring": "Finds the point at time `t` on a cubic curve.\n\nArgs:\n    pt1, pt2, pt3, pt4: Coordinates of the curve as 2D tuples.\n    t: The time along the curve.\n\nReturns:\n    A 2D tuple with the coordinates of the point."
    },
    {
      "name": "cubicPointAtTC",
      "docstring": "Finds the point at time `t` on a cubic curve.\n\nArgs:\n    pt1, pt2, pt3, pt4: Coordinates of the curve as complex numbers.\n    t: The time along the curve.\n\nReturns:\n    A complex number with the coordinates of the point."
    },
    {
      "name": "segmentPointAtT",
      "docstring": null
    },
    {
      "name": "lineLineIntersections",
      "docstring": "Finds intersections between two line segments.\n\nArgs:\n    s1, e1: Coordinates of the first line as 2D tuples.\n    s2, e2: Coordinates of the second line as 2D tuples.\n\nReturns:\n    A list of ``Intersection`` objects, each object having ``pt``, ``t1``\n    and ``t2`` attributes containing the intersection point, time on first\n    segment and time on second segment respectively.\n\nExamples::\n\n    >>> a = lineLineIntersections( (310,389), (453, 222), (289, 251), (447, 367))\n    >>> len(a)\n    1\n    >>> intersection = a[0]\n    >>> intersection.pt\n    (374.44882952482897, 313.73458370177315)\n    >>> (intersection.t1, intersection.t2)\n    (0.45069111555824465, 0.5408153767394238)"
    },
    {
      "name": "curveLineIntersections",
      "docstring": "Finds intersections between a curve and a line.\n\nArgs:\n    curve: List of coordinates of the curve segment as 2D tuples.\n    line: List of coordinates of the line segment as 2D tuples.\n\nReturns:\n    A list of ``Intersection`` objects, each object having ``pt``, ``t1``\n    and ``t2`` attributes containing the intersection point, time on first\n    segment and time on second segment respectively.\n\nExamples::\n    >>> curve = [ (100, 240), (30, 60), (210, 230), (160, 30) ]\n    >>> line  = [ (25, 260), (230, 20) ]\n    >>> intersections = curveLineIntersections(curve, line)\n    >>> len(intersections)\n    3\n    >>> intersections[0].pt\n    (84.9000930760723, 189.87306176459828)"
    },
    {
      "name": "curveCurveIntersections",
      "docstring": "Finds intersections between a curve and a curve.\n\nArgs:\n    curve1: List of coordinates of the first curve segment as 2D tuples.\n    curve2: List of coordinates of the second curve segment as 2D tuples.\n\nReturns:\n    A list of ``Intersection`` objects, each object having ``pt``, ``t1``\n    and ``t2`` attributes containing the intersection point, time on first\n    segment and time on second segment respectively.\n\nExamples::\n    >>> curve1 = [ (10,100), (90,30), (40,140), (220,220) ]\n    >>> curve2 = [ (5,150), (180,20), (80,250), (210,190) ]\n    >>> intersections = curveCurveIntersections(curve1, curve2)\n    >>> len(intersections)\n    3\n    >>> intersections[0].pt\n    (81.7831487395506, 109.88904552375288)"
    },
    {
      "name": "segmentSegmentIntersections",
      "docstring": "Finds intersections between two segments.\n\nArgs:\n    seg1: List of coordinates of the first segment as 2D tuples.\n    seg2: List of coordinates of the second segment as 2D tuples.\n\nReturns:\n    A list of ``Intersection`` objects, each object having ``pt``, ``t1``\n    and ``t2`` attributes containing the intersection point, time on first\n    segment and time on second segment respectively.\n\nExamples::\n    >>> curve1 = [ (10,100), (90,30), (40,140), (220,220) ]\n    >>> curve2 = [ (5,150), (180,20), (80,250), (210,190) ]\n    >>> intersections = segmentSegmentIntersections(curve1, curve2)\n    >>> len(intersections)\n    3\n    >>> intersections[0].pt\n    (81.7831487395506, 109.88904552375288)\n    >>> curve3 = [ (100, 240), (30, 60), (210, 230), (160, 30) ]\n    >>> line  = [ (25, 260), (230, 20) ]\n    >>> intersections = segmentSegmentIntersections(curve3, line)\n    >>> len(intersections)\n    3\n    >>> intersections[0].pt\n    (84.9000930760723, 189.87306176459828)"
    },
    {
      "name": "printSegments",
      "docstring": "Helper for the doctests, displaying each segment in a list of\nsegments on a single line as a tuple."
    },
    {
      "name": "midpoint",
      "docstring": null
    }
  ],
  "innovations": []
}