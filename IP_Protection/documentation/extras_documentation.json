{
  "file_path": "c:\\Users\\sgbil\\OneDrive\\Desktop\\Negative_Space_Imaging_Project\\.venv\\Lib\\site-packages\\numpy\\ma\\extras.py",
  "classes": [
    {
      "name": "_fromnxfunction",
      "docstring": "Defines a wrapper to adapt NumPy functions to masked arrays.\n\n\nAn instance of `_fromnxfunction` can be called with the same parameters\nas the wrapped NumPy function. The docstring of `newfunc` is adapted from\nthe wrapped function as well, see `getdoc`.\n\nThis class should not be used directly. Instead, one of its extensions that\nprovides support for a specific type of input should be used.\n\nParameters\n----------\nfuncname : str\n    The name of the function to be adapted. The function should be\n    in the NumPy namespace (i.e. ``np.funcname``).",
      "methods": [
        {
          "name": "__init__",
          "docstring": null
        },
        {
          "name": "getdoc",
          "docstring": "Retrieve the docstring and signature from the function.\n\nThe ``__doc__`` attribute of the function is used as the docstring for\nthe new masked array version of the function. A note on application\nof the function to the mask is appended.\n\nParameters\n----------\nNone"
        }
      ]
    },
    {
      "name": "_fromnxfunction_single",
      "docstring": "A version of `_fromnxfunction` that is called with a single array\nargument followed by auxiliary args that are passed verbatim for\nboth the data and mask calls.",
      "methods": []
    },
    {
      "name": "_fromnxfunction_seq",
      "docstring": "A version of `_fromnxfunction` that is called with a single sequence\nof arrays followed by auxiliary args that are passed verbatim for\nboth the data and mask calls.",
      "methods": []
    },
    {
      "name": "_fromnxfunction_args",
      "docstring": "A version of `_fromnxfunction` that is called with multiple array\narguments. The first non-array-like input marks the beginning of the\narguments that are passed verbatim for both the data and mask calls.\nArray arguments are processed independently and the results are\nreturned in a list. If only one array is found, the return value is\njust the processed array instead of a list.",
      "methods": []
    },
    {
      "name": "_fromnxfunction_allargs",
      "docstring": "A version of `_fromnxfunction` that is called with multiple array\narguments. Similar to `_fromnxfunction_args` except that all args\nare converted to arrays even if they are not so already. This makes\nit possible to process scalars as 1-D arrays. Only keyword arguments\nare passed through verbatim for the data and mask calls. Arrays\narguments are processed independently and the results are returned\nin a list. If only one arg is present, the return value is just the\nprocessed array instead of a list.",
      "methods": []
    },
    {
      "name": "MAxisConcatenator",
      "docstring": "Translate slice objects to concatenation along an axis.\n\nFor documentation on usage, see `mr_class`.\n\nSee Also\n--------\nmr_class",
      "methods": [
        {
          "name": "makemat",
          "docstring": null
        }
      ]
    },
    {
      "name": "mr_class",
      "docstring": "Translate slice objects to concatenation along the first axis.\n\nThis is the masked array version of `r_`.\n\nSee Also\n--------\nr_\n\nExamples\n--------\n>>> import numpy as np\n>>> np.ma.mr_[np.ma.array([1,2,3]), 0, 0, np.ma.array([4,5,6])]\nmasked_array(data=[1, 2, 3, ..., 4, 5, 6],\n             mask=False,\n       fill_value=999999)",
      "methods": [
        {
          "name": "__init__",
          "docstring": null
        }
      ]
    }
  ],
  "functions": [
    {
      "name": "issequence",
      "docstring": "Is seq a sequence (ndarray, list or tuple)?"
    },
    {
      "name": "count_masked",
      "docstring": "Count the number of masked elements along the given axis.\n\nParameters\n----------\narr : array_like\n    An array with (possibly) masked elements.\naxis : int, optional\n    Axis along which to count. If None (default), a flattened\n    version of the array is used.\n\nReturns\n-------\ncount : int, ndarray\n    The total number of masked elements (axis=None) or the number\n    of masked elements along each slice of the given axis.\n\nSee Also\n--------\nMaskedArray.count : Count non-masked elements.\n\nExamples\n--------\n>>> import numpy as np\n>>> a = np.arange(9).reshape((3,3))\n>>> a = np.ma.array(a)\n>>> a[1, 0] = np.ma.masked\n>>> a[1, 2] = np.ma.masked\n>>> a[2, 1] = np.ma.masked\n>>> a\nmasked_array(\n  data=[[0, 1, 2],\n        [--, 4, --],\n        [6, --, 8]],\n  mask=[[False, False, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n>>> np.ma.count_masked(a)\n3\n\nWhen the `axis` keyword is used an array is returned.\n\n>>> np.ma.count_masked(a, axis=0)\narray([1, 1, 1])\n>>> np.ma.count_masked(a, axis=1)\narray([0, 2, 1])"
    },
    {
      "name": "masked_all",
      "docstring": "Empty masked array with all elements masked.\n\nReturn an empty masked array of the given shape and dtype, where all the\ndata are masked.\n\nParameters\n----------\nshape : int or tuple of ints\n    Shape of the required MaskedArray, e.g., ``(2, 3)`` or ``2``.\ndtype : dtype, optional\n    Data type of the output.\n\nReturns\n-------\na : MaskedArray\n    A masked array with all data masked.\n\nSee Also\n--------\nmasked_all_like : Empty masked array modelled on an existing array.\n\nNotes\n-----\nUnlike other masked array creation functions (e.g. `numpy.ma.zeros`,\n`numpy.ma.ones`, `numpy.ma.full`), `masked_all` does not initialize the\nvalues of the array, and may therefore be marginally faster. However,\nthe values stored in the newly allocated array are arbitrary. For\nreproducible behavior, be sure to set each element of the array before\nreading.\n\nExamples\n--------\n>>> import numpy as np\n>>> np.ma.masked_all((3, 3))\nmasked_array(\n  data=[[--, --, --],\n        [--, --, --],\n        [--, --, --]],\n  mask=[[ True,  True,  True],\n        [ True,  True,  True],\n        [ True,  True,  True]],\n  fill_value=1e+20,\n  dtype=float64)\n\nThe `dtype` parameter defines the underlying data type.\n\n>>> a = np.ma.masked_all((3, 3))\n>>> a.dtype\ndtype('float64')\n>>> a = np.ma.masked_all((3, 3), dtype=np.int32)\n>>> a.dtype\ndtype('int32')"
    },
    {
      "name": "masked_all_like",
      "docstring": "Empty masked array with the properties of an existing array.\n\nReturn an empty masked array of the same shape and dtype as\nthe array `arr`, where all the data are masked.\n\nParameters\n----------\narr : ndarray\n    An array describing the shape and dtype of the required MaskedArray.\n\nReturns\n-------\na : MaskedArray\n    A masked array with all data masked.\n\nRaises\n------\nAttributeError\n    If `arr` doesn't have a shape attribute (i.e. not an ndarray)\n\nSee Also\n--------\nmasked_all : Empty masked array with all elements masked.\n\nNotes\n-----\nUnlike other masked array creation functions (e.g. `numpy.ma.zeros_like`,\n`numpy.ma.ones_like`, `numpy.ma.full_like`), `masked_all_like` does not\ninitialize the values of the array, and may therefore be marginally\nfaster. However, the values stored in the newly allocated array are\narbitrary. For reproducible behavior, be sure to set each element of the\narray before reading.\n\nExamples\n--------\n>>> import numpy as np\n>>> arr = np.zeros((2, 3), dtype=np.float32)\n>>> arr\narray([[0., 0., 0.],\n       [0., 0., 0.]], dtype=float32)\n>>> np.ma.masked_all_like(arr)\nmasked_array(\n  data=[[--, --, --],\n        [--, --, --]],\n  mask=[[ True,  True,  True],\n        [ True,  True,  True]],\n  fill_value=np.float64(1e+20),\n  dtype=float32)\n\nThe dtype of the masked array matches the dtype of `arr`.\n\n>>> arr.dtype\ndtype('float32')\n>>> np.ma.masked_all_like(arr).dtype\ndtype('float32')"
    },
    {
      "name": "flatten_inplace",
      "docstring": "Flatten a sequence in place."
    },
    {
      "name": "apply_along_axis",
      "docstring": "(This docstring should be overwritten)"
    },
    {
      "name": "apply_over_axes",
      "docstring": "(This docstring will be overwritten)"
    },
    {
      "name": "average",
      "docstring": "Return the weighted average of array over the given axis.\n\nParameters\n----------\na : array_like\n    Data to be averaged.\n    Masked entries are not taken into account in the computation.\naxis : None or int or tuple of ints, optional\n    Axis or axes along which to average `a`.  The default,\n    `axis=None`, will average over all of the elements of the input array.\n    If axis is a tuple of ints, averaging is performed on all of the axes\n    specified in the tuple instead of a single axis or all the axes as\n    before.\nweights : array_like, optional\n    An array of weights associated with the values in `a`. Each value in\n    `a` contributes to the average according to its associated weight.\n    The array of weights must be the same shape as `a` if no axis is\n    specified, otherwise the weights must have dimensions and shape\n    consistent with `a` along the specified axis.\n    If `weights=None`, then all data in `a` are assumed to have a\n    weight equal to one.\n    The calculation is::\n\n        avg = sum(a * weights) / sum(weights)\n\n    where the sum is over all included elements.\n    The only constraint on the values of `weights` is that `sum(weights)`\n    must not be 0.\nreturned : bool, optional\n    Flag indicating whether a tuple ``(result, sum of weights)``\n    should be returned as output (True), or just the result (False).\n    Default is False.\nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left\n    in the result as dimensions with size one. With this option,\n    the result will broadcast correctly against the original `a`.\n    *Note:* `keepdims` will not work with instances of `numpy.matrix`\n    or other classes whose methods do not support `keepdims`.\n\n    .. versionadded:: 1.23.0\n\nReturns\n-------\naverage, [sum_of_weights] : (tuple of) scalar or MaskedArray\n    The average along the specified axis. When returned is `True`,\n    return a tuple with the average as the first element and the sum\n    of the weights as the second element. The return type is `np.float64`\n    if `a` is of integer type and floats smaller than `float64`, or the\n    input data-type, otherwise. If returned, `sum_of_weights` is always\n    `float64`.\n\nRaises\n------\nZeroDivisionError\n    When all weights along axis are zero. See `numpy.ma.average` for a\n    version robust to this type of error.\nTypeError\n    When `weights` does not have the same shape as `a`, and `axis=None`.\nValueError\n    When `weights` does not have dimensions and shape consistent with `a`\n    along specified `axis`.\n\nExamples\n--------\n>>> import numpy as np\n>>> a = np.ma.array([1., 2., 3., 4.], mask=[False, False, True, True])\n>>> np.ma.average(a, weights=[3, 1, 0, 0])\n1.25\n\n>>> x = np.ma.arange(6.).reshape(3, 2)\n>>> x\nmasked_array(\n  data=[[0., 1.],\n        [2., 3.],\n        [4., 5.]],\n  mask=False,\n  fill_value=1e+20)\n>>> data = np.arange(8).reshape((2, 2, 2))\n>>> data\narray([[[0, 1],\n        [2, 3]],\n       [[4, 5],\n        [6, 7]]])\n>>> np.ma.average(data, axis=(0, 1), weights=[[1./4, 3./4], [1., 1./2]])\nmasked_array(data=[3.4, 4.4],\n         mask=[False, False],\n   fill_value=1e+20)\n>>> np.ma.average(data, axis=0, weights=[[1./4, 3./4], [1., 1./2]])\nTraceback (most recent call last):\n    ...\nValueError: Shape of weights must be consistent\nwith shape of a along specified axis.\n\n>>> avg, sumweights = np.ma.average(x, axis=0, weights=[1, 2, 3],\n...                                 returned=True)\n>>> avg\nmasked_array(data=[2.6666666666666665, 3.6666666666666665],\n             mask=[False, False],\n       fill_value=1e+20)\n\nWith ``keepdims=True``, the following result has shape (3, 1).\n\n>>> np.ma.average(x, axis=1, keepdims=True)\nmasked_array(\n  data=[[0.5],\n        [2.5],\n        [4.5]],\n  mask=False,\n  fill_value=1e+20)"
    },
    {
      "name": "median",
      "docstring": "Compute the median along the specified axis.\n\nReturns the median of the array elements.\n\nParameters\n----------\na : array_like\n    Input array or object that can be converted to an array.\naxis : int, optional\n    Axis along which the medians are computed. The default (None) is\n    to compute the median along a flattened version of the array.\nout : ndarray, optional\n    Alternative output array in which to place the result. It must\n    have the same shape and buffer length as the expected output\n    but the type will be cast if necessary.\noverwrite_input : bool, optional\n    If True, then allow use of memory of input array (a) for\n    calculations. The input array will be modified by the call to\n    median. This will save memory when you do not need to preserve\n    the contents of the input array. Treat the input as undefined,\n    but it will probably be fully or partially sorted. Default is\n    False. Note that, if `overwrite_input` is True, and the input\n    is not already an `ndarray`, an error will be raised.\nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left\n    in the result as dimensions with size one. With this option,\n    the result will broadcast correctly against the input array.\n\nReturns\n-------\nmedian : ndarray\n    A new array holding the result is returned unless out is\n    specified, in which case a reference to out is returned.\n    Return data-type is `float64` for integers and floats smaller than\n    `float64`, or the input data-type, otherwise.\n\nSee Also\n--------\nmean\n\nNotes\n-----\nGiven a vector ``V`` with ``N`` non masked values, the median of ``V``\nis the middle value of a sorted copy of ``V`` (``Vs``) - i.e.\n``Vs[(N-1)/2]``, when ``N`` is odd, or ``{Vs[N/2 - 1] + Vs[N/2]}/2``\nwhen ``N`` is even.\n\nExamples\n--------\n>>> import numpy as np\n>>> x = np.ma.array(np.arange(8), mask=[0]*4 + [1]*4)\n>>> np.ma.median(x)\n1.5\n\n>>> x = np.ma.array(np.arange(10).reshape(2, 5), mask=[0]*6 + [1]*4)\n>>> np.ma.median(x)\n2.5\n>>> np.ma.median(x, axis=-1, overwrite_input=True)\nmasked_array(data=[2.0, 5.0],\n             mask=[False, False],\n       fill_value=1e+20)"
    },
    {
      "name": "compress_nd",
      "docstring": "Suppress slices from multiple dimensions which contain masked values.\n\nParameters\n----------\nx : array_like, MaskedArray\n    The array to operate on. If not a MaskedArray instance (or if no array\n    elements are masked), `x` is interpreted as a MaskedArray with `mask`\n    set to `nomask`.\naxis : tuple of ints or int, optional\n    Which dimensions to suppress slices from can be configured with this\n    parameter.\n    - If axis is a tuple of ints, those are the axes to suppress slices from.\n    - If axis is an int, then that is the only axis to suppress slices from.\n    - If axis is None, all axis are selected.\n\nReturns\n-------\ncompress_array : ndarray\n    The compressed array.\n\nExamples\n--------\n>>> import numpy as np\n>>> arr = [[1, 2], [3, 4]]\n>>> mask = [[0, 1], [0, 0]]\n>>> x = np.ma.array(arr, mask=mask)\n>>> np.ma.compress_nd(x, axis=0)\narray([[3, 4]])\n>>> np.ma.compress_nd(x, axis=1)\narray([[1],\n       [3]])\n>>> np.ma.compress_nd(x)\narray([[3]])"
    },
    {
      "name": "compress_rowcols",
      "docstring": "Suppress the rows and/or columns of a 2-D array that contain\nmasked values.\n\nThe suppression behavior is selected with the `axis` parameter.\n\n- If axis is None, both rows and columns are suppressed.\n- If axis is 0, only rows are suppressed.\n- If axis is 1 or -1, only columns are suppressed.\n\nParameters\n----------\nx : array_like, MaskedArray\n    The array to operate on.  If not a MaskedArray instance (or if no array\n    elements are masked), `x` is interpreted as a MaskedArray with\n    `mask` set to `nomask`. Must be a 2D array.\naxis : int, optional\n    Axis along which to perform the operation. Default is None.\n\nReturns\n-------\ncompressed_array : ndarray\n    The compressed array.\n\nExamples\n--------\n>>> import numpy as np\n>>> x = np.ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],\n...                                                   [1, 0, 0],\n...                                                   [0, 0, 0]])\n>>> x\nmasked_array(\n  data=[[--, 1, 2],\n        [--, 4, 5],\n        [6, 7, 8]],\n  mask=[[ True, False, False],\n        [ True, False, False],\n        [False, False, False]],\n  fill_value=999999)\n\n>>> np.ma.compress_rowcols(x)\narray([[7, 8]])\n>>> np.ma.compress_rowcols(x, 0)\narray([[6, 7, 8]])\n>>> np.ma.compress_rowcols(x, 1)\narray([[1, 2],\n       [4, 5],\n       [7, 8]])"
    },
    {
      "name": "compress_rows",
      "docstring": "Suppress whole rows of a 2-D array that contain masked values.\n\nThis is equivalent to ``np.ma.compress_rowcols(a, 0)``, see\n`compress_rowcols` for details.\n\nParameters\n----------\nx : array_like, MaskedArray\n    The array to operate on. If not a MaskedArray instance (or if no array\n    elements are masked), `x` is interpreted as a MaskedArray with\n    `mask` set to `nomask`. Must be a 2D array.\n\nReturns\n-------\ncompressed_array : ndarray\n    The compressed array.\n\nSee Also\n--------\ncompress_rowcols\n\nExamples\n--------\n>>> import numpy as np\n>>> a = np.ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],\n...                                                   [1, 0, 0],\n...                                                   [0, 0, 0]])\n>>> np.ma.compress_rows(a)\narray([[6, 7, 8]])"
    },
    {
      "name": "compress_cols",
      "docstring": "Suppress whole columns of a 2-D array that contain masked values.\n\nThis is equivalent to ``np.ma.compress_rowcols(a, 1)``, see\n`compress_rowcols` for details.\n\nParameters\n----------\nx : array_like, MaskedArray\n    The array to operate on.  If not a MaskedArray instance (or if no array\n    elements are masked), `x` is interpreted as a MaskedArray with\n    `mask` set to `nomask`. Must be a 2D array.\n\nReturns\n-------\ncompressed_array : ndarray\n    The compressed array.\n\nSee Also\n--------\ncompress_rowcols\n\nExamples\n--------\n>>> import numpy as np\n>>> a = np.ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],\n...                                                   [1, 0, 0],\n...                                                   [0, 0, 0]])\n>>> np.ma.compress_cols(a)\narray([[1, 2],\n       [4, 5],\n       [7, 8]])"
    },
    {
      "name": "mask_rowcols",
      "docstring": "Mask rows and/or columns of a 2D array that contain masked values.\n\nMask whole rows and/or columns of a 2D array that contain\nmasked values.  The masking behavior is selected using the\n`axis` parameter.\n\n  - If `axis` is None, rows *and* columns are masked.\n  - If `axis` is 0, only rows are masked.\n  - If `axis` is 1 or -1, only columns are masked.\n\nParameters\n----------\na : array_like, MaskedArray\n    The array to mask.  If not a MaskedArray instance (or if no array\n    elements are masked), the result is a MaskedArray with `mask` set\n    to `nomask` (False). Must be a 2D array.\naxis : int, optional\n    Axis along which to perform the operation. If None, applies to a\n    flattened version of the array.\n\nReturns\n-------\na : MaskedArray\n    A modified version of the input array, masked depending on the value\n    of the `axis` parameter.\n\nRaises\n------\nNotImplementedError\n    If input array `a` is not 2D.\n\nSee Also\n--------\nmask_rows : Mask rows of a 2D array that contain masked values.\nmask_cols : Mask cols of a 2D array that contain masked values.\nmasked_where : Mask where a condition is met.\n\nNotes\n-----\nThe input array's mask is modified by this function.\n\nExamples\n--------\n>>> import numpy as np\n>>> a = np.zeros((3, 3), dtype=int)\n>>> a[1, 1] = 1\n>>> a\narray([[0, 0, 0],\n       [0, 1, 0],\n       [0, 0, 0]])\n>>> a = np.ma.masked_equal(a, 1)\n>>> a\nmasked_array(\n  data=[[0, 0, 0],\n        [0, --, 0],\n        [0, 0, 0]],\n  mask=[[False, False, False],\n        [False,  True, False],\n        [False, False, False]],\n  fill_value=1)\n>>> np.ma.mask_rowcols(a)\nmasked_array(\n  data=[[0, --, 0],\n        [--, --, --],\n        [0, --, 0]],\n  mask=[[False,  True, False],\n        [ True,  True,  True],\n        [False,  True, False]],\n  fill_value=1)"
    },
    {
      "name": "mask_rows",
      "docstring": "Mask rows of a 2D array that contain masked values.\n\nThis function is a shortcut to ``mask_rowcols`` with `axis` equal to 0.\n\nSee Also\n--------\nmask_rowcols : Mask rows and/or columns of a 2D array.\nmasked_where : Mask where a condition is met.\n\nExamples\n--------\n>>> import numpy as np\n>>> a = np.zeros((3, 3), dtype=int)\n>>> a[1, 1] = 1\n>>> a\narray([[0, 0, 0],\n       [0, 1, 0],\n       [0, 0, 0]])\n>>> a = np.ma.masked_equal(a, 1)\n>>> a\nmasked_array(\n  data=[[0, 0, 0],\n        [0, --, 0],\n        [0, 0, 0]],\n  mask=[[False, False, False],\n        [False,  True, False],\n        [False, False, False]],\n  fill_value=1)\n\n>>> np.ma.mask_rows(a)\nmasked_array(\n  data=[[0, 0, 0],\n        [--, --, --],\n        [0, 0, 0]],\n  mask=[[False, False, False],\n        [ True,  True,  True],\n        [False, False, False]],\n  fill_value=1)"
    },
    {
      "name": "mask_cols",
      "docstring": "Mask columns of a 2D array that contain masked values.\n\nThis function is a shortcut to ``mask_rowcols`` with `axis` equal to 1.\n\nSee Also\n--------\nmask_rowcols : Mask rows and/or columns of a 2D array.\nmasked_where : Mask where a condition is met.\n\nExamples\n--------\n>>> import numpy as np\n>>> a = np.zeros((3, 3), dtype=int)\n>>> a[1, 1] = 1\n>>> a\narray([[0, 0, 0],\n       [0, 1, 0],\n       [0, 0, 0]])\n>>> a = np.ma.masked_equal(a, 1)\n>>> a\nmasked_array(\n  data=[[0, 0, 0],\n        [0, --, 0],\n        [0, 0, 0]],\n  mask=[[False, False, False],\n        [False,  True, False],\n        [False, False, False]],\n  fill_value=1)\n>>> np.ma.mask_cols(a)\nmasked_array(\n  data=[[0, --, 0],\n        [0, --, 0],\n        [0, --, 0]],\n  mask=[[False,  True, False],\n        [False,  True, False],\n        [False,  True, False]],\n  fill_value=1)"
    },
    {
      "name": "ediff1d",
      "docstring": "Compute the differences between consecutive elements of an array.\n\nThis function is the equivalent of `numpy.ediff1d` that takes masked\nvalues into account, see `numpy.ediff1d` for details.\n\nSee Also\n--------\nnumpy.ediff1d : Equivalent function for ndarrays.\n\nExamples\n--------\n>>> import numpy as np\n>>> arr = np.ma.array([1, 2, 4, 7, 0])\n>>> np.ma.ediff1d(arr)\nmasked_array(data=[ 1,  2,  3, -7],\n             mask=False,\n       fill_value=999999)"
    },
    {
      "name": "unique",
      "docstring": "Finds the unique elements of an array.\n\nMasked values are considered the same element (masked). The output array\nis always a masked array. See `numpy.unique` for more details.\n\nSee Also\n--------\nnumpy.unique : Equivalent function for ndarrays.\n\nExamples\n--------\n>>> import numpy as np\n>>> a = [1, 2, 1000, 2, 3]\n>>> mask = [0, 0, 1, 0, 0]\n>>> masked_a = np.ma.masked_array(a, mask)\n>>> masked_a\nmasked_array(data=[1, 2, --, 2, 3],\n            mask=[False, False,  True, False, False],\n    fill_value=999999)\n>>> np.ma.unique(masked_a)\nmasked_array(data=[1, 2, 3, --],\n            mask=[False, False, False,  True],\n    fill_value=999999)\n>>> np.ma.unique(masked_a, return_index=True)\n(masked_array(data=[1, 2, 3, --],\n            mask=[False, False, False,  True],\n    fill_value=999999), array([0, 1, 4, 2]))\n>>> np.ma.unique(masked_a, return_inverse=True)\n(masked_array(data=[1, 2, 3, --],\n            mask=[False, False, False,  True],\n    fill_value=999999), array([0, 1, 3, 1, 2]))\n>>> np.ma.unique(masked_a, return_index=True, return_inverse=True)\n(masked_array(data=[1, 2, 3, --],\n            mask=[False, False, False,  True],\n    fill_value=999999), array([0, 1, 4, 2]), array([0, 1, 3, 1, 2]))"
    },
    {
      "name": "intersect1d",
      "docstring": "Returns the unique elements common to both arrays.\n\nMasked values are considered equal one to the other.\nThe output is always a masked array.\n\nSee `numpy.intersect1d` for more details.\n\nSee Also\n--------\nnumpy.intersect1d : Equivalent function for ndarrays.\n\nExamples\n--------\n>>> import numpy as np\n>>> x = np.ma.array([1, 3, 3, 3], mask=[0, 0, 0, 1])\n>>> y = np.ma.array([3, 1, 1, 1], mask=[0, 0, 0, 1])\n>>> np.ma.intersect1d(x, y)\nmasked_array(data=[1, 3, --],\n             mask=[False, False,  True],\n       fill_value=999999)"
    },
    {
      "name": "setxor1d",
      "docstring": "Set exclusive-or of 1-D arrays with unique elements.\n\nThe output is always a masked array. See `numpy.setxor1d` for more details.\n\nSee Also\n--------\nnumpy.setxor1d : Equivalent function for ndarrays.\n\nExamples\n--------\n>>> import numpy as np\n>>> ar1 = np.ma.array([1, 2, 3, 2, 4])\n>>> ar2 = np.ma.array([2, 3, 5, 7, 5])\n>>> np.ma.setxor1d(ar1, ar2)\nmasked_array(data=[1, 4, 5, 7],\n             mask=False,\n       fill_value=999999)"
    },
    {
      "name": "in1d",
      "docstring": "Test whether each element of an array is also present in a second\narray.\n\nThe output is always a masked array. See `numpy.in1d` for more details.\n\nWe recommend using :func:`isin` instead of `in1d` for new code.\n\nSee Also\n--------\nisin       : Version of this function that preserves the shape of ar1.\nnumpy.in1d : Equivalent function for ndarrays.\n\nExamples\n--------\n>>> import numpy as np\n>>> ar1 = np.ma.array([0, 1, 2, 5, 0])\n>>> ar2 = [0, 2]\n>>> np.ma.in1d(ar1, ar2)\nmasked_array(data=[ True, False,  True, False,  True],\n             mask=False,\n       fill_value=True)"
    },
    {
      "name": "isin",
      "docstring": "Calculates `element in test_elements`, broadcasting over\n`element` only.\n\nThe output is always a masked array of the same shape as `element`.\nSee `numpy.isin` for more details.\n\nSee Also\n--------\nin1d       : Flattened version of this function.\nnumpy.isin : Equivalent function for ndarrays.\n\nExamples\n--------\n>>> import numpy as np\n>>> element = np.ma.array([1, 2, 3, 4, 5, 6])\n>>> test_elements = [0, 2]\n>>> np.ma.isin(element, test_elements)\nmasked_array(data=[False,  True, False, False, False, False],\n             mask=False,\n       fill_value=True)"
    },
    {
      "name": "union1d",
      "docstring": "Union of two arrays.\n\nThe output is always a masked array. See `numpy.union1d` for more details.\n\nSee Also\n--------\nnumpy.union1d : Equivalent function for ndarrays.\n\nExamples\n--------\n>>> import numpy as np\n>>> ar1 = np.ma.array([1, 2, 3, 4])\n>>> ar2 = np.ma.array([3, 4, 5, 6])\n>>> np.ma.union1d(ar1, ar2)\nmasked_array(data=[1, 2, 3, 4, 5, 6],\n         mask=False,\n   fill_value=999999)"
    },
    {
      "name": "setdiff1d",
      "docstring": "Set difference of 1D arrays with unique elements.\n\nThe output is always a masked array. See `numpy.setdiff1d` for more\ndetails.\n\nSee Also\n--------\nnumpy.setdiff1d : Equivalent function for ndarrays.\n\nExamples\n--------\n>>> import numpy as np\n>>> x = np.ma.array([1, 2, 3, 4], mask=[0, 1, 0, 1])\n>>> np.ma.setdiff1d(x, [1, 2])\nmasked_array(data=[3, --],\n             mask=[False,  True],\n       fill_value=999999)"
    },
    {
      "name": "cov",
      "docstring": "Estimate the covariance matrix.\n\nExcept for the handling of missing data this function does the same as\n`numpy.cov`. For more details and examples, see `numpy.cov`.\n\nBy default, masked values are recognized as such. If `x` and `y` have the\nsame shape, a common mask is allocated: if ``x[i,j]`` is masked, then\n``y[i,j]`` will also be masked.\nSetting `allow_masked` to False will raise an exception if values are\nmissing in either of the input arrays.\n\nParameters\n----------\nx : array_like\n    A 1-D or 2-D array containing multiple variables and observations.\n    Each row of `x` represents a variable, and each column a single\n    observation of all those variables. Also see `rowvar` below.\ny : array_like, optional\n    An additional set of variables and observations. `y` has the same\n    shape as `x`.\nrowvar : bool, optional\n    If `rowvar` is True (default), then each row represents a\n    variable, with observations in the columns. Otherwise, the relationship\n    is transposed: each column represents a variable, while the rows\n    contain observations.\nbias : bool, optional\n    Default normalization (False) is by ``(N-1)``, where ``N`` is the\n    number of observations given (unbiased estimate). If `bias` is True,\n    then normalization is by ``N``. This keyword can be overridden by\n    the keyword ``ddof`` in numpy versions >= 1.5.\nallow_masked : bool, optional\n    If True, masked values are propagated pair-wise: if a value is masked\n    in `x`, the corresponding value is masked in `y`.\n    If False, raises a `ValueError` exception when some values are missing.\nddof : {None, int}, optional\n    If not ``None`` normalization is by ``(N - ddof)``, where ``N`` is\n    the number of observations; this overrides the value implied by\n    ``bias``. The default value is ``None``.\n\nRaises\n------\nValueError\n    Raised if some values are missing and `allow_masked` is False.\n\nSee Also\n--------\nnumpy.cov\n\nExamples\n--------\n>>> import numpy as np\n>>> x = np.ma.array([[0, 1], [1, 1]], mask=[0, 1, 0, 1])\n>>> y = np.ma.array([[1, 0], [0, 1]], mask=[0, 0, 1, 1])\n>>> np.ma.cov(x, y)\nmasked_array(\ndata=[[--, --, --, --],\n      [--, --, --, --],\n      [--, --, --, --],\n      [--, --, --, --]],\nmask=[[ True,  True,  True,  True],\n      [ True,  True,  True,  True],\n      [ True,  True,  True,  True],\n      [ True,  True,  True,  True]],\nfill_value=1e+20,\ndtype=float64)"
    },
    {
      "name": "corrcoef",
      "docstring": "Return Pearson product-moment correlation coefficients.\n\nExcept for the handling of missing data this function does the same as\n`numpy.corrcoef`. For more details and examples, see `numpy.corrcoef`.\n\nParameters\n----------\nx : array_like\n    A 1-D or 2-D array containing multiple variables and observations.\n    Each row of `x` represents a variable, and each column a single\n    observation of all those variables. Also see `rowvar` below.\ny : array_like, optional\n    An additional set of variables and observations. `y` has the same\n    shape as `x`.\nrowvar : bool, optional\n    If `rowvar` is True (default), then each row represents a\n    variable, with observations in the columns. Otherwise, the relationship\n    is transposed: each column represents a variable, while the rows\n    contain observations.\nbias : _NoValue, optional\n    Has no effect, do not use.\n\n    .. deprecated:: 1.10.0\nallow_masked : bool, optional\n    If True, masked values are propagated pair-wise: if a value is masked\n    in `x`, the corresponding value is masked in `y`.\n    If False, raises an exception.  Because `bias` is deprecated, this\n    argument needs to be treated as keyword only to avoid a warning.\nddof : _NoValue, optional\n    Has no effect, do not use.\n\n    .. deprecated:: 1.10.0\n\nSee Also\n--------\nnumpy.corrcoef : Equivalent function in top-level NumPy module.\ncov : Estimate the covariance matrix.\n\nNotes\n-----\nThis function accepts but discards arguments `bias` and `ddof`.  This is\nfor backwards compatibility with previous versions of this function.  These\narguments had no effect on the return values of the function and can be\nsafely ignored in this and previous versions of numpy.\n\nExamples\n--------\n>>> import numpy as np\n>>> x = np.ma.array([[0, 1], [1, 1]], mask=[0, 1, 0, 1])\n>>> np.ma.corrcoef(x)\nmasked_array(\n  data=[[--, --],\n        [--, --]],\n  mask=[[ True,  True],\n        [ True,  True]],\n  fill_value=1e+20,\n  dtype=float64)"
    },
    {
      "name": "ndenumerate",
      "docstring": "Multidimensional index iterator.\n\nReturn an iterator yielding pairs of array coordinates and values,\nskipping elements that are masked. With `compressed=False`,\n`ma.masked` is yielded as the value of masked elements. This\nbehavior differs from that of `numpy.ndenumerate`, which yields the\nvalue of the underlying data array.\n\nNotes\n-----\n.. versionadded:: 1.23.0\n\nParameters\n----------\na : array_like\n    An array with (possibly) masked elements.\ncompressed : bool, optional\n    If True (default), masked elements are skipped.\n\nSee Also\n--------\nnumpy.ndenumerate : Equivalent function ignoring any mask.\n\nExamples\n--------\n>>> import numpy as np\n>>> a = np.ma.arange(9).reshape((3, 3))\n>>> a[1, 0] = np.ma.masked\n>>> a[1, 2] = np.ma.masked\n>>> a[2, 1] = np.ma.masked\n>>> a\nmasked_array(\n  data=[[0, 1, 2],\n        [--, 4, --],\n        [6, --, 8]],\n  mask=[[False, False, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n>>> for index, x in np.ma.ndenumerate(a):\n...     print(index, x)\n(0, 0) 0\n(0, 1) 1\n(0, 2) 2\n(1, 1) 4\n(2, 0) 6\n(2, 2) 8\n\n>>> for index, x in np.ma.ndenumerate(a, compressed=False):\n...     print(index, x)\n(0, 0) 0\n(0, 1) 1\n(0, 2) 2\n(1, 0) --\n(1, 1) 4\n(1, 2) --\n(2, 0) 6\n(2, 1) --\n(2, 2) 8"
    },
    {
      "name": "flatnotmasked_edges",
      "docstring": "Find the indices of the first and last unmasked values.\n\nExpects a 1-D `MaskedArray`, returns None if all values are masked.\n\nParameters\n----------\na : array_like\n    Input 1-D `MaskedArray`\n\nReturns\n-------\nedges : ndarray or None\n    The indices of first and last non-masked value in the array.\n    Returns None if all values are masked.\n\nSee Also\n--------\nflatnotmasked_contiguous, notmasked_contiguous, notmasked_edges\nclump_masked, clump_unmasked\n\nNotes\n-----\nOnly accepts 1-D arrays.\n\nExamples\n--------\n>>> import numpy as np\n>>> a = np.ma.arange(10)\n>>> np.ma.flatnotmasked_edges(a)\narray([0, 9])\n\n>>> mask = (a < 3) | (a > 8) | (a == 5)\n>>> a[mask] = np.ma.masked\n>>> np.array(a[~a.mask])\narray([3, 4, 6, 7, 8])\n\n>>> np.ma.flatnotmasked_edges(a)\narray([3, 8])\n\n>>> a[:] = np.ma.masked\n>>> print(np.ma.flatnotmasked_edges(a))\nNone"
    },
    {
      "name": "notmasked_edges",
      "docstring": "Find the indices of the first and last unmasked values along an axis.\n\nIf all values are masked, return None.  Otherwise, return a list\nof two tuples, corresponding to the indices of the first and last\nunmasked values respectively.\n\nParameters\n----------\na : array_like\n    The input array.\naxis : int, optional\n    Axis along which to perform the operation.\n    If None (default), applies to a flattened version of the array.\n\nReturns\n-------\nedges : ndarray or list\n    An array of start and end indexes if there are any masked data in\n    the array. If there are no masked data in the array, `edges` is a\n    list of the first and last index.\n\nSee Also\n--------\nflatnotmasked_contiguous, flatnotmasked_edges, notmasked_contiguous\nclump_masked, clump_unmasked\n\nExamples\n--------\n>>> import numpy as np\n>>> a = np.arange(9).reshape((3, 3))\n>>> m = np.zeros_like(a)\n>>> m[1:, 1:] = 1\n\n>>> am = np.ma.array(a, mask=m)\n>>> np.array(am[~am.mask])\narray([0, 1, 2, 3, 6])\n\n>>> np.ma.notmasked_edges(am)\narray([0, 6])"
    },
    {
      "name": "flatnotmasked_contiguous",
      "docstring": "Find contiguous unmasked data in a masked array.\n\nParameters\n----------\na : array_like\n    The input array.\n\nReturns\n-------\nslice_list : list\n    A sorted sequence of `slice` objects (start index, end index).\n\nSee Also\n--------\nflatnotmasked_edges, notmasked_contiguous, notmasked_edges\nclump_masked, clump_unmasked\n\nNotes\n-----\nOnly accepts 2-D arrays at most.\n\nExamples\n--------\n>>> import numpy as np\n>>> a = np.ma.arange(10)\n>>> np.ma.flatnotmasked_contiguous(a)\n[slice(0, 10, None)]\n\n>>> mask = (a < 3) | (a > 8) | (a == 5)\n>>> a[mask] = np.ma.masked\n>>> np.array(a[~a.mask])\narray([3, 4, 6, 7, 8])\n\n>>> np.ma.flatnotmasked_contiguous(a)\n[slice(3, 5, None), slice(6, 9, None)]\n>>> a[:] = np.ma.masked\n>>> np.ma.flatnotmasked_contiguous(a)\n[]"
    },
    {
      "name": "notmasked_contiguous",
      "docstring": "Find contiguous unmasked data in a masked array along the given axis.\n\nParameters\n----------\na : array_like\n    The input array.\naxis : int, optional\n    Axis along which to perform the operation.\n    If None (default), applies to a flattened version of the array, and this\n    is the same as `flatnotmasked_contiguous`.\n\nReturns\n-------\nendpoints : list\n    A list of slices (start and end indexes) of unmasked indexes\n    in the array.\n\n    If the input is 2d and axis is specified, the result is a list of lists.\n\nSee Also\n--------\nflatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges\nclump_masked, clump_unmasked\n\nNotes\n-----\nOnly accepts 2-D arrays at most.\n\nExamples\n--------\n>>> import numpy as np\n>>> a = np.arange(12).reshape((3, 4))\n>>> mask = np.zeros_like(a)\n>>> mask[1:, :-1] = 1; mask[0, 1] = 1; mask[-1, 0] = 0\n>>> ma = np.ma.array(a, mask=mask)\n>>> ma\nmasked_array(\n  data=[[0, --, 2, 3],\n        [--, --, --, 7],\n        [8, --, --, 11]],\n  mask=[[False,  True, False, False],\n        [ True,  True,  True, False],\n        [False,  True,  True, False]],\n  fill_value=999999)\n>>> np.array(ma[~ma.mask])\narray([ 0,  2,  3,  7, 8, 11])\n\n>>> np.ma.notmasked_contiguous(ma)\n[slice(0, 1, None), slice(2, 4, None), slice(7, 9, None), slice(11, 12, None)]\n\n>>> np.ma.notmasked_contiguous(ma, axis=0)\n[[slice(0, 1, None), slice(2, 3, None)], [], [slice(0, 1, None)], [slice(0, 3, None)]]\n\n>>> np.ma.notmasked_contiguous(ma, axis=1)\n[[slice(0, 1, None), slice(2, 4, None)], [slice(3, 4, None)], [slice(0, 1, None), slice(3, 4, None)]]"
    },
    {
      "name": "clump_unmasked",
      "docstring": "Return list of slices corresponding to the unmasked clumps of a 1-D array.\n(A \"clump\" is defined as a contiguous region of the array).\n\nParameters\n----------\na : ndarray\n    A one-dimensional masked array.\n\nReturns\n-------\nslices : list of slice\n    The list of slices, one for each continuous region of unmasked\n    elements in `a`.\n\nSee Also\n--------\nflatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges\nnotmasked_contiguous, clump_masked\n\nExamples\n--------\n>>> import numpy as np\n>>> a = np.ma.masked_array(np.arange(10))\n>>> a[[0, 1, 2, 6, 8, 9]] = np.ma.masked\n>>> np.ma.clump_unmasked(a)\n[slice(3, 6, None), slice(7, 8, None)]"
    },
    {
      "name": "clump_masked",
      "docstring": "Returns a list of slices corresponding to the masked clumps of a 1-D array.\n(A \"clump\" is defined as a contiguous region of the array).\n\nParameters\n----------\na : ndarray\n    A one-dimensional masked array.\n\nReturns\n-------\nslices : list of slice\n    The list of slices, one for each continuous region of masked elements\n    in `a`.\n\nSee Also\n--------\nflatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges\nnotmasked_contiguous, clump_unmasked\n\nExamples\n--------\n>>> import numpy as np\n>>> a = np.ma.masked_array(np.arange(10))\n>>> a[[0, 1, 2, 6, 8, 9]] = np.ma.masked\n>>> np.ma.clump_masked(a)\n[slice(0, 3, None), slice(6, 7, None), slice(8, 10, None)]"
    },
    {
      "name": "vander",
      "docstring": "Masked values in the input array result in rows of zeros."
    },
    {
      "name": "polyfit",
      "docstring": "Any masked values in x is propagated in y, and vice-versa."
    },
    {
      "name": "getdoc",
      "docstring": "Retrieve the docstring and signature from the function.\n\nThe ``__doc__`` attribute of the function is used as the docstring for\nthe new masked array version of the function. A note on application\nof the function to the mask is appended.\n\nParameters\n----------\nNone"
    },
    {
      "name": "replace_masked",
      "docstring": null
    },
    {
      "name": "makemat",
      "docstring": null
    }
  ],
  "innovations": []
}