{
  "file_path": "c:\\Users\\sgbil\\OneDrive\\Desktop\\Negative_Space_Imaging_Project\\.venv\\Lib\\site-packages\\numpy\\lib\\_polynomial_impl.py",
  "classes": [
    {
      "name": "poly1d",
      "docstring": "A one-dimensional polynomial class.\n\n.. note::\n   This forms part of the old polynomial API. Since version 1.4, the\n   new polynomial API defined in `numpy.polynomial` is preferred.\n   A summary of the differences can be found in the\n   :doc:`transition guide </reference/routines.polynomials>`.\n\nA convenience class, used to encapsulate \"natural\" operations on\npolynomials so that said operations may take on their customary\nform in code (see Examples).\n\nParameters\n----------\nc_or_r : array_like\n    The polynomial's coefficients, in decreasing powers, or if\n    the value of the second parameter is True, the polynomial's\n    roots (values where the polynomial evaluates to 0).  For example,\n    ``poly1d([1, 2, 3])`` returns an object that represents\n    :math:`x^2 + 2x + 3`, whereas ``poly1d([1, 2, 3], True)`` returns\n    one that represents :math:`(x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x -6`.\nr : bool, optional\n    If True, `c_or_r` specifies the polynomial's roots; the default\n    is False.\nvariable : str, optional\n    Changes the variable used when printing `p` from `x` to `variable`\n    (see Examples).\n\nExamples\n--------\nConstruct the polynomial :math:`x^2 + 2x + 3`:\n\n>>> import numpy as np\n\n>>> p = np.poly1d([1, 2, 3])\n>>> print(np.poly1d(p))\n   2\n1 x + 2 x + 3\n\nEvaluate the polynomial at :math:`x = 0.5`:\n\n>>> p(0.5)\n4.25\n\nFind the roots:\n\n>>> p.r\narray([-1.+1.41421356j, -1.-1.41421356j])\n>>> p(p.r)\narray([ -4.44089210e-16+0.j,  -4.44089210e-16+0.j]) # may vary\n\nThese numbers in the previous line represent (0, 0) to machine precision\n\nShow the coefficients:\n\n>>> p.c\narray([1, 2, 3])\n\nDisplay the order (the leading zero-coefficients are removed):\n\n>>> p.order\n2\n\nShow the coefficient of the k-th power in the polynomial\n(which is equivalent to ``p.c[-(i+1)]``):\n\n>>> p[1]\n2\n\nPolynomials can be added, subtracted, multiplied, and divided\n(returns quotient and remainder):\n\n>>> p * p\npoly1d([ 1,  4, 10, 12,  9])\n\n>>> (p**3 + 4) / p\n(poly1d([ 1.,  4., 10., 12.,  9.]), poly1d([4.]))\n\n``asarray(p)`` gives the coefficient array, so polynomials can be\nused in all functions that accept arrays:\n\n>>> p**2 # square of polynomial\npoly1d([ 1,  4, 10, 12,  9])\n\n>>> np.square(p) # square of individual coefficients\narray([1, 4, 9])\n\nThe variable used in the string representation of `p` can be modified,\nusing the `variable` parameter:\n\n>>> p = np.poly1d([1,2,3], variable='z')\n>>> print(p)\n   2\n1 z + 2 z + 3\n\nConstruct a polynomial from its roots:\n\n>>> np.poly1d([1, 2], True)\npoly1d([ 1., -3.,  2.])\n\nThis is the same polynomial as obtained by:\n\n>>> np.poly1d([1, -1]) * np.poly1d([1, -2])\npoly1d([ 1, -3,  2])",
      "methods": [
        {
          "name": "coeffs",
          "docstring": "The polynomial coefficients "
        },
        {
          "name": "coeffs",
          "docstring": null
        },
        {
          "name": "variable",
          "docstring": "The name of the polynomial variable "
        },
        {
          "name": "order",
          "docstring": "The order or degree of the polynomial "
        },
        {
          "name": "roots",
          "docstring": "The roots of the polynomial, where self(x) == 0 "
        },
        {
          "name": "__init__",
          "docstring": null
        },
        {
          "name": "integ",
          "docstring": "Return an antiderivative (indefinite integral) of this polynomial.\n\nRefer to `polyint` for full documentation.\n\nSee Also\n--------\npolyint : equivalent function"
        },
        {
          "name": "deriv",
          "docstring": "Return a derivative of this polynomial.\n\nRefer to `polyder` for full documentation.\n\nSee Also\n--------\npolyder : equivalent function"
        }
      ]
    }
  ],
  "functions": [
    {
      "name": "poly",
      "docstring": "Find the coefficients of a polynomial with the given sequence of roots.\n\n.. note::\n   This forms part of the old polynomial API. Since version 1.4, the\n   new polynomial API defined in `numpy.polynomial` is preferred.\n   A summary of the differences can be found in the\n   :doc:`transition guide </reference/routines.polynomials>`.\n\nReturns the coefficients of the polynomial whose leading coefficient\nis one for the given sequence of zeros (multiple roots must be included\nin the sequence as many times as their multiplicity; see Examples).\nA square matrix (or array, which will be treated as a matrix) can also\nbe given, in which case the coefficients of the characteristic polynomial\nof the matrix are returned.\n\nParameters\n----------\nseq_of_zeros : array_like, shape (N,) or (N, N)\n    A sequence of polynomial roots, or a square array or matrix object.\n\nReturns\n-------\nc : ndarray\n    1D array of polynomial coefficients from highest to lowest degree:\n\n    ``c[0] * x**(N) + c[1] * x**(N-1) + ... + c[N-1] * x + c[N]``\n    where c[0] always equals 1.\n\nRaises\n------\nValueError\n    If input is the wrong shape (the input must be a 1-D or square\n    2-D array).\n\nSee Also\n--------\npolyval : Compute polynomial values.\nroots : Return the roots of a polynomial.\npolyfit : Least squares polynomial fit.\npoly1d : A one-dimensional polynomial class.\n\nNotes\n-----\nSpecifying the roots of a polynomial still leaves one degree of\nfreedom, typically represented by an undetermined leading\ncoefficient. [1]_ In the case of this function, that coefficient -\nthe first one in the returned array - is always taken as one. (If\nfor some reason you have one other point, the only automatic way\npresently to leverage that information is to use ``polyfit``.)\n\nThe characteristic polynomial, :math:`p_a(t)`, of an `n`-by-`n`\nmatrix **A** is given by\n\n:math:`p_a(t) = \\mathrm{det}(t\\, \\mathbf{I} - \\mathbf{A})`,\n\nwhere **I** is the `n`-by-`n` identity matrix. [2]_\n\nReferences\n----------\n.. [1] M. Sullivan and M. Sullivan, III, \"Algebra and Trigonometry,\n   Enhanced With Graphing Utilities,\" Prentice-Hall, pg. 318, 1996.\n\n.. [2] G. Strang, \"Linear Algebra and Its Applications, 2nd Edition,\"\n   Academic Press, pg. 182, 1980.\n\nExamples\n--------\nGiven a sequence of a polynomial's zeros:\n\n>>> import numpy as np\n\n>>> np.poly((0, 0, 0)) # Multiple root example\narray([1., 0., 0., 0.])\n\nThe line above represents z**3 + 0*z**2 + 0*z + 0.\n\n>>> np.poly((-1./2, 0, 1./2))\narray([ 1.  ,  0.  , -0.25,  0.  ])\n\nThe line above represents z**3 - z/4\n\n>>> np.poly((np.random.random(1)[0], 0, np.random.random(1)[0]))\narray([ 1.        , -0.77086955,  0.08618131,  0.        ]) # random\n\nGiven a square array object:\n\n>>> P = np.array([[0, 1./3], [-1./2, 0]])\n>>> np.poly(P)\narray([1.        , 0.        , 0.16666667])\n\nNote how in all cases the leading coefficient is always 1."
    },
    {
      "name": "roots",
      "docstring": "Return the roots of a polynomial with coefficients given in p.\n\n.. note::\n   This forms part of the old polynomial API. Since version 1.4, the\n   new polynomial API defined in `numpy.polynomial` is preferred.\n   A summary of the differences can be found in the\n   :doc:`transition guide </reference/routines.polynomials>`.\n\nThe values in the rank-1 array `p` are coefficients of a polynomial.\nIf the length of `p` is n+1 then the polynomial is described by::\n\n  p[0] * x**n + p[1] * x**(n-1) + ... + p[n-1]*x + p[n]\n\nParameters\n----------\np : array_like\n    Rank-1 array of polynomial coefficients.\n\nReturns\n-------\nout : ndarray\n    An array containing the roots of the polynomial.\n\nRaises\n------\nValueError\n    When `p` cannot be converted to a rank-1 array.\n\nSee also\n--------\npoly : Find the coefficients of a polynomial with a given sequence\n       of roots.\npolyval : Compute polynomial values.\npolyfit : Least squares polynomial fit.\npoly1d : A one-dimensional polynomial class.\n\nNotes\n-----\nThe algorithm relies on computing the eigenvalues of the\ncompanion matrix [1]_.\n\nReferences\n----------\n.. [1] R. A. Horn & C. R. Johnson, *Matrix Analysis*.  Cambridge, UK:\n    Cambridge University Press, 1999, pp. 146-7.\n\nExamples\n--------\n>>> import numpy as np\n>>> coeff = [3.2, 2, 1]\n>>> np.roots(coeff)\narray([-0.3125+0.46351241j, -0.3125-0.46351241j])"
    },
    {
      "name": "polyint",
      "docstring": "Return an antiderivative (indefinite integral) of a polynomial.\n\n.. note::\n   This forms part of the old polynomial API. Since version 1.4, the\n   new polynomial API defined in `numpy.polynomial` is preferred.\n   A summary of the differences can be found in the\n   :doc:`transition guide </reference/routines.polynomials>`.\n\nThe returned order `m` antiderivative `P` of polynomial `p` satisfies\n:math:`\\frac{d^m}{dx^m}P(x) = p(x)` and is defined up to `m - 1`\nintegration constants `k`. The constants determine the low-order\npolynomial part\n\n.. math:: \\frac{k_{m-1}}{0!} x^0 + \\ldots + \\frac{k_0}{(m-1)!}x^{m-1}\n\nof `P` so that :math:`P^{(j)}(0) = k_{m-j-1}`.\n\nParameters\n----------\np : array_like or poly1d\n    Polynomial to integrate.\n    A sequence is interpreted as polynomial coefficients, see `poly1d`.\nm : int, optional\n    Order of the antiderivative. (Default: 1)\nk : list of `m` scalars or scalar, optional\n    Integration constants. They are given in the order of integration:\n    those corresponding to highest-order terms come first.\n\n    If ``None`` (default), all constants are assumed to be zero.\n    If `m = 1`, a single scalar can be given instead of a list.\n\nSee Also\n--------\npolyder : derivative of a polynomial\npoly1d.integ : equivalent method\n\nExamples\n--------\nThe defining property of the antiderivative:\n\n>>> import numpy as np\n\n>>> p = np.poly1d([1,1,1])\n>>> P = np.polyint(p)\n>>> P\n poly1d([ 0.33333333,  0.5       ,  1.        ,  0.        ]) # may vary\n>>> np.polyder(P) == p\nTrue\n\nThe integration constants default to zero, but can be specified:\n\n>>> P = np.polyint(p, 3)\n>>> P(0)\n0.0\n>>> np.polyder(P)(0)\n0.0\n>>> np.polyder(P, 2)(0)\n0.0\n>>> P = np.polyint(p, 3, k=[6,5,3])\n>>> P\npoly1d([ 0.01666667,  0.04166667,  0.16666667,  3. ,  5. ,  3. ]) # may vary\n\nNote that 3 = 6 / 2!, and that the constants are given in the order of\nintegrations. Constant of the highest-order polynomial term comes first:\n\n>>> np.polyder(P, 2)(0)\n6.0\n>>> np.polyder(P, 1)(0)\n5.0\n>>> P(0)\n3.0"
    },
    {
      "name": "polyder",
      "docstring": "Return the derivative of the specified order of a polynomial.\n\n.. note::\n   This forms part of the old polynomial API. Since version 1.4, the\n   new polynomial API defined in `numpy.polynomial` is preferred.\n   A summary of the differences can be found in the\n   :doc:`transition guide </reference/routines.polynomials>`.\n\nParameters\n----------\np : poly1d or sequence\n    Polynomial to differentiate.\n    A sequence is interpreted as polynomial coefficients, see `poly1d`.\nm : int, optional\n    Order of differentiation (default: 1)\n\nReturns\n-------\nder : poly1d\n    A new polynomial representing the derivative.\n\nSee Also\n--------\npolyint : Anti-derivative of a polynomial.\npoly1d : Class for one-dimensional polynomials.\n\nExamples\n--------\nThe derivative of the polynomial :math:`x^3 + x^2 + x^1 + 1` is:\n\n>>> import numpy as np\n\n>>> p = np.poly1d([1,1,1,1])\n>>> p2 = np.polyder(p)\n>>> p2\npoly1d([3, 2, 1])\n\nwhich evaluates to:\n\n>>> p2(2.)\n17.0\n\nWe can verify this, approximating the derivative with\n``(f(x + h) - f(x))/h``:\n\n>>> (p(2. + 0.001) - p(2.)) / 0.001\n17.007000999997857\n\nThe fourth-order derivative of a 3rd-order polynomial is zero:\n\n>>> np.polyder(p, 2)\npoly1d([6, 2])\n>>> np.polyder(p, 3)\npoly1d([6])\n>>> np.polyder(p, 4)\npoly1d([0])"
    },
    {
      "name": "polyfit",
      "docstring": "Least squares polynomial fit.\n\n.. note::\n   This forms part of the old polynomial API. Since version 1.4, the\n   new polynomial API defined in `numpy.polynomial` is preferred.\n   A summary of the differences can be found in the\n   :doc:`transition guide </reference/routines.polynomials>`.\n\nFit a polynomial ``p(x) = p[0] * x**deg + ... + p[deg]`` of degree `deg`\nto points `(x, y)`. Returns a vector of coefficients `p` that minimises\nthe squared error in the order `deg`, `deg-1`, ... `0`.\n\nThe `Polynomial.fit <numpy.polynomial.polynomial.Polynomial.fit>` class\nmethod is recommended for new code as it is more stable numerically. See\nthe documentation of the method for more information.\n\nParameters\n----------\nx : array_like, shape (M,)\n    x-coordinates of the M sample points ``(x[i], y[i])``.\ny : array_like, shape (M,) or (M, K)\n    y-coordinates of the sample points. Several data sets of sample\n    points sharing the same x-coordinates can be fitted at once by\n    passing in a 2D-array that contains one dataset per column.\ndeg : int\n    Degree of the fitting polynomial\nrcond : float, optional\n    Relative condition number of the fit. Singular values smaller than\n    this relative to the largest singular value will be ignored. The\n    default value is len(x)*eps, where eps is the relative precision of\n    the float type, about 2e-16 in most cases.\nfull : bool, optional\n    Switch determining nature of return value. When it is False (the\n    default) just the coefficients are returned, when True diagnostic\n    information from the singular value decomposition is also returned.\nw : array_like, shape (M,), optional\n    Weights. If not None, the weight ``w[i]`` applies to the unsquared\n    residual ``y[i] - y_hat[i]`` at ``x[i]``. Ideally the weights are\n    chosen so that the errors of the products ``w[i]*y[i]`` all have the\n    same variance.  When using inverse-variance weighting, use\n    ``w[i] = 1/sigma(y[i])``.  The default value is None.\ncov : bool or str, optional\n    If given and not `False`, return not just the estimate but also its\n    covariance matrix. By default, the covariance are scaled by\n    chi2/dof, where dof = M - (deg + 1), i.e., the weights are presumed\n    to be unreliable except in a relative sense and everything is scaled\n    such that the reduced chi2 is unity. This scaling is omitted if\n    ``cov='unscaled'``, as is relevant for the case that the weights are\n    w = 1/sigma, with sigma known to be a reliable estimate of the\n    uncertainty.\n\nReturns\n-------\np : ndarray, shape (deg + 1,) or (deg + 1, K)\n    Polynomial coefficients, highest power first.  If `y` was 2-D, the\n    coefficients for `k`-th data set are in ``p[:,k]``.\n\nresiduals, rank, singular_values, rcond\n    These values are only returned if ``full == True``\n\n    - residuals -- sum of squared residuals of the least squares fit\n    - rank -- the effective rank of the scaled Vandermonde\n       coefficient matrix\n    - singular_values -- singular values of the scaled Vandermonde\n       coefficient matrix\n    - rcond -- value of `rcond`.\n\n    For more details, see `numpy.linalg.lstsq`.\n\nV : ndarray, shape (deg + 1, deg + 1) or (deg + 1, deg + 1, K)\n    Present only if ``full == False`` and ``cov == True``.  The covariance\n    matrix of the polynomial coefficient estimates.  The diagonal of\n    this matrix are the variance estimates for each coefficient.  If y\n    is a 2-D array, then the covariance matrix for the `k`-th data set\n    are in ``V[:,:,k]``\n\n\nWarns\n-----\nRankWarning\n    The rank of the coefficient matrix in the least-squares fit is\n    deficient. The warning is only raised if ``full == False``.\n\n    The warnings can be turned off by\n\n    >>> import warnings\n    >>> warnings.simplefilter('ignore', np.exceptions.RankWarning)\n\nSee Also\n--------\npolyval : Compute polynomial values.\nlinalg.lstsq : Computes a least-squares fit.\nscipy.interpolate.UnivariateSpline : Computes spline fits.\n\nNotes\n-----\nThe solution minimizes the squared error\n\n.. math::\n    E = \\sum_{j=0}^k |p(x_j) - y_j|^2\n\nin the equations::\n\n    x[0]**n * p[0] + ... + x[0] * p[n-1] + p[n] = y[0]\n    x[1]**n * p[0] + ... + x[1] * p[n-1] + p[n] = y[1]\n    ...\n    x[k]**n * p[0] + ... + x[k] * p[n-1] + p[n] = y[k]\n\nThe coefficient matrix of the coefficients `p` is a Vandermonde matrix.\n\n`polyfit` issues a `~exceptions.RankWarning` when the least-squares fit is\nbadly conditioned. This implies that the best fit is not well-defined due\nto numerical error. The results may be improved by lowering the polynomial\ndegree or by replacing `x` by `x` - `x`.mean(). The `rcond` parameter\ncan also be set to a value smaller than its default, but the resulting\nfit may be spurious: including contributions from the small singular\nvalues can add numerical noise to the result.\n\nNote that fitting polynomial coefficients is inherently badly conditioned\nwhen the degree of the polynomial is large or the interval of sample points\nis badly centered. The quality of the fit should always be checked in these\ncases. When polynomial fits are not satisfactory, splines may be a good\nalternative.\n\nReferences\n----------\n.. [1] Wikipedia, \"Curve fitting\",\n       https://en.wikipedia.org/wiki/Curve_fitting\n.. [2] Wikipedia, \"Polynomial interpolation\",\n       https://en.wikipedia.org/wiki/Polynomial_interpolation\n\nExamples\n--------\n>>> import numpy as np\n>>> import warnings\n>>> x = np.array([0.0, 1.0, 2.0, 3.0,  4.0,  5.0])\n>>> y = np.array([0.0, 0.8, 0.9, 0.1, -0.8, -1.0])\n>>> z = np.polyfit(x, y, 3)\n>>> z\narray([ 0.08703704, -0.81349206,  1.69312169, -0.03968254]) # may vary\n\nIt is convenient to use `poly1d` objects for dealing with polynomials:\n\n>>> p = np.poly1d(z)\n>>> p(0.5)\n0.6143849206349179 # may vary\n>>> p(3.5)\n-0.34732142857143039 # may vary\n>>> p(10)\n22.579365079365115 # may vary\n\nHigh-order polynomials may oscillate wildly:\n\n>>> with warnings.catch_warnings():\n...     warnings.simplefilter('ignore', np.exceptions.RankWarning)\n...     p30 = np.poly1d(np.polyfit(x, y, 30))\n...\n>>> p30(4)\n-0.80000000000000204 # may vary\n>>> p30(5)\n-0.99999999999999445 # may vary\n>>> p30(4.5)\n-0.10547061179440398 # may vary\n\nIllustration:\n\n>>> import matplotlib.pyplot as plt\n>>> xp = np.linspace(-2, 6, 100)\n>>> _ = plt.plot(x, y, '.', xp, p(xp), '-', xp, p30(xp), '--')\n>>> plt.ylim(-2,2)\n(-2, 2)\n>>> plt.show()"
    },
    {
      "name": "polyval",
      "docstring": "Evaluate a polynomial at specific values.\n\n.. note::\n   This forms part of the old polynomial API. Since version 1.4, the\n   new polynomial API defined in `numpy.polynomial` is preferred.\n   A summary of the differences can be found in the\n   :doc:`transition guide </reference/routines.polynomials>`.\n\nIf `p` is of length N, this function returns the value::\n\n    p[0]*x**(N-1) + p[1]*x**(N-2) + ... + p[N-2]*x + p[N-1]\n\nIf `x` is a sequence, then ``p(x)`` is returned for each element of ``x``.\nIf `x` is another polynomial then the composite polynomial ``p(x(t))``\nis returned.\n\nParameters\n----------\np : array_like or poly1d object\n   1D array of polynomial coefficients (including coefficients equal\n   to zero) from highest degree to the constant term, or an\n   instance of poly1d.\nx : array_like or poly1d object\n   A number, an array of numbers, or an instance of poly1d, at\n   which to evaluate `p`.\n\nReturns\n-------\nvalues : ndarray or poly1d\n   If `x` is a poly1d instance, the result is the composition of the two\n   polynomials, i.e., `x` is \"substituted\" in `p` and the simplified\n   result is returned. In addition, the type of `x` - array_like or\n   poly1d - governs the type of the output: `x` array_like => `values`\n   array_like, `x` a poly1d object => `values` is also.\n\nSee Also\n--------\npoly1d: A polynomial class.\n\nNotes\n-----\nHorner's scheme [1]_ is used to evaluate the polynomial. Even so,\nfor polynomials of high degree the values may be inaccurate due to\nrounding errors. Use carefully.\n\nIf `x` is a subtype of `ndarray` the return value will be of the same type.\n\nReferences\n----------\n.. [1] I. N. Bronshtein, K. A. Semendyayev, and K. A. Hirsch (Eng.\n   trans. Ed.), *Handbook of Mathematics*, New York, Van Nostrand\n   Reinhold Co., 1985, pg. 720.\n\nExamples\n--------\n>>> import numpy as np\n>>> np.polyval([3,0,1], 5)  # 3 * 5**2 + 0 * 5**1 + 1\n76\n>>> np.polyval([3,0,1], np.poly1d(5))\npoly1d([76])\n>>> np.polyval(np.poly1d([3,0,1]), 5)\n76\n>>> np.polyval(np.poly1d([3,0,1]), np.poly1d(5))\npoly1d([76])"
    },
    {
      "name": "polyadd",
      "docstring": "Find the sum of two polynomials.\n\n.. note::\n   This forms part of the old polynomial API. Since version 1.4, the\n   new polynomial API defined in `numpy.polynomial` is preferred.\n   A summary of the differences can be found in the\n   :doc:`transition guide </reference/routines.polynomials>`.\n\nReturns the polynomial resulting from the sum of two input polynomials.\nEach input must be either a poly1d object or a 1D sequence of polynomial\ncoefficients, from highest to lowest degree.\n\nParameters\n----------\na1, a2 : array_like or poly1d object\n    Input polynomials.\n\nReturns\n-------\nout : ndarray or poly1d object\n    The sum of the inputs. If either input is a poly1d object, then the\n    output is also a poly1d object. Otherwise, it is a 1D array of\n    polynomial coefficients from highest to lowest degree.\n\nSee Also\n--------\npoly1d : A one-dimensional polynomial class.\npoly, polyadd, polyder, polydiv, polyfit, polyint, polysub, polyval\n\nExamples\n--------\n>>> import numpy as np\n>>> np.polyadd([1, 2], [9, 5, 4])\narray([9, 6, 6])\n\nUsing poly1d objects:\n\n>>> p1 = np.poly1d([1, 2])\n>>> p2 = np.poly1d([9, 5, 4])\n>>> print(p1)\n1 x + 2\n>>> print(p2)\n   2\n9 x + 5 x + 4\n>>> print(np.polyadd(p1, p2))\n   2\n9 x + 6 x + 6"
    },
    {
      "name": "polysub",
      "docstring": "Difference (subtraction) of two polynomials.\n\n.. note::\n   This forms part of the old polynomial API. Since version 1.4, the\n   new polynomial API defined in `numpy.polynomial` is preferred.\n   A summary of the differences can be found in the\n   :doc:`transition guide </reference/routines.polynomials>`.\n\nGiven two polynomials `a1` and `a2`, returns ``a1 - a2``.\n`a1` and `a2` can be either array_like sequences of the polynomials'\ncoefficients (including coefficients equal to zero), or `poly1d` objects.\n\nParameters\n----------\na1, a2 : array_like or poly1d\n    Minuend and subtrahend polynomials, respectively.\n\nReturns\n-------\nout : ndarray or poly1d\n    Array or `poly1d` object of the difference polynomial's coefficients.\n\nSee Also\n--------\npolyval, polydiv, polymul, polyadd\n\nExamples\n--------\n.. math:: (2 x^2 + 10 x - 2) - (3 x^2 + 10 x -4) = (-x^2 + 2)\n\n>>> import numpy as np\n\n>>> np.polysub([2, 10, -2], [3, 10, -4])\narray([-1,  0,  2])"
    },
    {
      "name": "polymul",
      "docstring": "Find the product of two polynomials.\n\n.. note::\n   This forms part of the old polynomial API. Since version 1.4, the\n   new polynomial API defined in `numpy.polynomial` is preferred.\n   A summary of the differences can be found in the\n   :doc:`transition guide </reference/routines.polynomials>`.\n\nFinds the polynomial resulting from the multiplication of the two input\npolynomials. Each input must be either a poly1d object or a 1D sequence\nof polynomial coefficients, from highest to lowest degree.\n\nParameters\n----------\na1, a2 : array_like or poly1d object\n    Input polynomials.\n\nReturns\n-------\nout : ndarray or poly1d object\n    The polynomial resulting from the multiplication of the inputs. If\n    either inputs is a poly1d object, then the output is also a poly1d\n    object. Otherwise, it is a 1D array of polynomial coefficients from\n    highest to lowest degree.\n\nSee Also\n--------\npoly1d : A one-dimensional polynomial class.\npoly, polyadd, polyder, polydiv, polyfit, polyint, polysub, polyval\nconvolve : Array convolution. Same output as polymul, but has parameter\n           for overlap mode.\n\nExamples\n--------\n>>> import numpy as np\n>>> np.polymul([1, 2, 3], [9, 5, 1])\narray([ 9, 23, 38, 17,  3])\n\nUsing poly1d objects:\n\n>>> p1 = np.poly1d([1, 2, 3])\n>>> p2 = np.poly1d([9, 5, 1])\n>>> print(p1)\n   2\n1 x + 2 x + 3\n>>> print(p2)\n   2\n9 x + 5 x + 1\n>>> print(np.polymul(p1, p2))\n   4      3      2\n9 x + 23 x + 38 x + 17 x + 3"
    },
    {
      "name": "polydiv",
      "docstring": "Returns the quotient and remainder of polynomial division.\n\n.. note::\n   This forms part of the old polynomial API. Since version 1.4, the\n   new polynomial API defined in `numpy.polynomial` is preferred.\n   A summary of the differences can be found in the\n   :doc:`transition guide </reference/routines.polynomials>`.\n\nThe input arrays are the coefficients (including any coefficients\nequal to zero) of the \"numerator\" (dividend) and \"denominator\"\n(divisor) polynomials, respectively.\n\nParameters\n----------\nu : array_like or poly1d\n    Dividend polynomial's coefficients.\n\nv : array_like or poly1d\n    Divisor polynomial's coefficients.\n\nReturns\n-------\nq : ndarray\n    Coefficients, including those equal to zero, of the quotient.\nr : ndarray\n    Coefficients, including those equal to zero, of the remainder.\n\nSee Also\n--------\npoly, polyadd, polyder, polydiv, polyfit, polyint, polymul, polysub\npolyval\n\nNotes\n-----\nBoth `u` and `v` must be 0-d or 1-d (ndim = 0 or 1), but `u.ndim` need\nnot equal `v.ndim`. In other words, all four possible combinations -\n``u.ndim = v.ndim = 0``, ``u.ndim = v.ndim = 1``,\n``u.ndim = 1, v.ndim = 0``, and ``u.ndim = 0, v.ndim = 1`` - work.\n\nExamples\n--------\n.. math:: \\frac{3x^2 + 5x + 2}{2x + 1} = 1.5x + 1.75, remainder 0.25\n\n>>> import numpy as np\n>>> x = np.array([3.0, 5.0, 2.0])\n>>> y = np.array([2.0, 1.0])\n>>> np.polydiv(x, y)\n(array([1.5 , 1.75]), array([0.25]))"
    },
    {
      "name": "coeffs",
      "docstring": "The polynomial coefficients "
    },
    {
      "name": "coeffs",
      "docstring": null
    },
    {
      "name": "variable",
      "docstring": "The name of the polynomial variable "
    },
    {
      "name": "order",
      "docstring": "The order or degree of the polynomial "
    },
    {
      "name": "roots",
      "docstring": "The roots of the polynomial, where self(x) == 0 "
    },
    {
      "name": "integ",
      "docstring": "Return an antiderivative (indefinite integral) of this polynomial.\n\nRefer to `polyint` for full documentation.\n\nSee Also\n--------\npolyint : equivalent function"
    },
    {
      "name": "deriv",
      "docstring": "Return a derivative of this polynomial.\n\nRefer to `polyder` for full documentation.\n\nSee Also\n--------\npolyder : equivalent function"
    },
    {
      "name": "fmt_float",
      "docstring": null
    }
  ],
  "innovations": [
    {
      "type": "potential_innovation",
      "marker": "enhanced",
      "context": "    References\n    ----------\n    .. [1] M. Sullivan and M. Sullivan, III, \"Algebra and Trigonometry,\n       Enhanced With Graphing Utilities,\" Prentice-Hall, pg. 318, 1996.\n\n    .. [2] G. Strang, \"Linear Algebra and Its Applications, 2nd Edition,\"\n       Academic Press, pg. 182, 1980."
    }
  ]
}