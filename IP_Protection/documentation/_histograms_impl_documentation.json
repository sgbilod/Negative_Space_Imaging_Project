{
  "file_path": "c:\\Users\\sgbil\\OneDrive\\Desktop\\Negative_Space_Imaging_Project\\.venv\\Lib\\site-packages\\numpy\\lib\\_histograms_impl.py",
  "classes": [],
  "functions": [
    {
      "name": "histogram_bin_edges",
      "docstring": "Function to calculate only the edges of the bins used by the `histogram`\nfunction.\n\nParameters\n----------\na : array_like\n    Input data. The histogram is computed over the flattened array.\nbins : int or sequence of scalars or str, optional\n    If `bins` is an int, it defines the number of equal-width\n    bins in the given range (10, by default). If `bins` is a\n    sequence, it defines the bin edges, including the rightmost\n    edge, allowing for non-uniform bin widths.\n\n    If `bins` is a string from the list below, `histogram_bin_edges` will\n    use the method chosen to calculate the optimal bin width and\n    consequently the number of bins (see the Notes section for more detail\n    on the estimators) from the data that falls within the requested range.\n    While the bin width will be optimal for the actual data\n    in the range, the number of bins will be computed to fill the\n    entire range, including the empty portions. For visualisation,\n    using the 'auto' option is suggested. Weighted data is not\n    supported for automated bin size selection.\n\n    'auto'\n        Minimum bin width between the 'sturges' and 'fd' estimators.\n        Provides good all-around performance.\n\n    'fd' (Freedman Diaconis Estimator)\n        Robust (resilient to outliers) estimator that takes into\n        account data variability and data size.\n\n    'doane'\n        An improved version of Sturges' estimator that works better\n        with non-normal datasets.\n\n    'scott'\n        Less robust estimator that takes into account data variability\n        and data size.\n\n    'stone'\n        Estimator based on leave-one-out cross-validation estimate of\n        the integrated squared error. Can be regarded as a generalization\n        of Scott's rule.\n\n    'rice'\n        Estimator does not take variability into account, only data\n        size. Commonly overestimates number of bins required.\n\n    'sturges'\n        R's default method, only accounts for data size. Only\n        optimal for gaussian data and underestimates number of bins\n        for large non-gaussian datasets.\n\n    'sqrt'\n        Square root (of data size) estimator, used by Excel and\n        other programs for its speed and simplicity.\n\nrange : (float, float), optional\n    The lower and upper range of the bins.  If not provided, range\n    is simply ``(a.min(), a.max())``.  Values outside the range are\n    ignored. The first element of the range must be less than or\n    equal to the second. `range` affects the automatic bin\n    computation as well. While bin width is computed to be optimal\n    based on the actual data within `range`, the bin count will fill\n    the entire range including portions containing no data.\n\nweights : array_like, optional\n    An array of weights, of the same shape as `a`.  Each value in\n    `a` only contributes its associated weight towards the bin count\n    (instead of 1). This is currently not used by any of the bin estimators,\n    but may be in the future.\n\nReturns\n-------\nbin_edges : array of dtype float\n    The edges to pass into `histogram`\n\nSee Also\n--------\nhistogram\n\nNotes\n-----\nThe methods to estimate the optimal number of bins are well founded\nin literature, and are inspired by the choices R provides for\nhistogram visualisation. Note that having the number of bins\nproportional to :math:`n^{1/3}` is asymptotically optimal, which is\nwhy it appears in most estimators. These are simply plug-in methods\nthat give good starting points for number of bins. In the equations\nbelow, :math:`h` is the binwidth and :math:`n_h` is the number of\nbins. All estimators that compute bin counts are recast to bin width\nusing the `ptp` of the data. The final bin count is obtained from\n``np.round(np.ceil(range / h))``. The final bin width is often less\nthan what is returned by the estimators below.\n\n'auto' (minimum bin width of the 'sturges' and 'fd' estimators)\n    A compromise to get a good value. For small datasets the Sturges\n    value will usually be chosen, while larger datasets will usually\n    default to FD.  Avoids the overly conservative behaviour of FD\n    and Sturges for small and large datasets respectively.\n    Switchover point is usually :math:`a.size \\approx 1000`.\n\n'fd' (Freedman Diaconis Estimator)\n    .. math:: h = 2 \\frac{IQR}{n^{1/3}}\n\n    The binwidth is proportional to the interquartile range (IQR)\n    and inversely proportional to cube root of a.size. Can be too\n    conservative for small datasets, but is quite good for large\n    datasets. The IQR is very robust to outliers.\n\n'scott'\n    .. math:: h = \\sigma \\sqrt[3]{\\frac{24 \\sqrt{\\pi}}{n}}\n\n    The binwidth is proportional to the standard deviation of the\n    data and inversely proportional to cube root of ``x.size``. Can\n    be too conservative for small datasets, but is quite good for\n    large datasets. The standard deviation is not very robust to\n    outliers. Values are very similar to the Freedman-Diaconis\n    estimator in the absence of outliers.\n\n'rice'\n    .. math:: n_h = 2n^{1/3}\n\n    The number of bins is only proportional to cube root of\n    ``a.size``. It tends to overestimate the number of bins and it\n    does not take into account data variability.\n\n'sturges'\n    .. math:: n_h = \\log _{2}(n) + 1\n\n    The number of bins is the base 2 log of ``a.size``.  This\n    estimator assumes normality of data and is too conservative for\n    larger, non-normal datasets. This is the default method in R's\n    ``hist`` method.\n\n'doane'\n    .. math:: n_h = 1 + \\log_{2}(n) +\n                    \\log_{2}\\left(1 + \\frac{|g_1|}{\\sigma_{g_1}}\\right)\n\n        g_1 = mean\\left[\\left(\\frac{x - \\mu}{\\sigma}\\right)^3\\right]\n\n        \\sigma_{g_1} = \\sqrt{\\frac{6(n - 2)}{(n + 1)(n + 3)}}\n\n    An improved version of Sturges' formula that produces better\n    estimates for non-normal datasets. This estimator attempts to\n    account for the skew of the data.\n\n'sqrt'\n    .. math:: n_h = \\sqrt n\n\n    The simplest and fastest estimator. Only takes into account the\n    data size.\n\nAdditionally, if the data is of integer dtype, then the binwidth will never\nbe less than 1.\n\nExamples\n--------\n>>> import numpy as np\n>>> arr = np.array([0, 0, 0, 1, 2, 3, 3, 4, 5])\n>>> np.histogram_bin_edges(arr, bins='auto', range=(0, 1))\narray([0.  , 0.25, 0.5 , 0.75, 1.  ])\n>>> np.histogram_bin_edges(arr, bins=2)\narray([0. , 2.5, 5. ])\n\nFor consistency with histogram, an array of pre-computed bins is\npassed through unmodified:\n\n>>> np.histogram_bin_edges(arr, [1, 2])\narray([1, 2])\n\nThis function allows one set of bins to be computed, and reused across\nmultiple histograms:\n\n>>> shared_bins = np.histogram_bin_edges(arr, bins='auto')\n>>> shared_bins\narray([0., 1., 2., 3., 4., 5.])\n\n>>> group_id = np.array([0, 1, 1, 0, 1, 1, 0, 1, 1])\n>>> hist_0, _ = np.histogram(arr[group_id == 0], bins=shared_bins)\n>>> hist_1, _ = np.histogram(arr[group_id == 1], bins=shared_bins)\n\n>>> hist_0; hist_1\narray([1, 1, 0, 1, 0])\narray([2, 0, 1, 1, 2])\n\nWhich gives more easily comparable results than using separate bins for\neach histogram:\n\n>>> hist_0, bins_0 = np.histogram(arr[group_id == 0], bins='auto')\n>>> hist_1, bins_1 = np.histogram(arr[group_id == 1], bins='auto')\n>>> hist_0; hist_1\narray([1, 1, 1])\narray([2, 1, 1, 2])\n>>> bins_0; bins_1\narray([0., 1., 2., 3.])\narray([0.  , 1.25, 2.5 , 3.75, 5.  ])"
    },
    {
      "name": "histogram",
      "docstring": "Compute the histogram of a dataset.\n\nParameters\n----------\na : array_like\n    Input data. The histogram is computed over the flattened array.\nbins : int or sequence of scalars or str, optional\n    If `bins` is an int, it defines the number of equal-width\n    bins in the given range (10, by default). If `bins` is a\n    sequence, it defines a monotonically increasing array of bin edges,\n    including the rightmost edge, allowing for non-uniform bin widths.\n\n    If `bins` is a string, it defines the method used to calculate the\n    optimal bin width, as defined by `histogram_bin_edges`.\n\nrange : (float, float), optional\n    The lower and upper range of the bins.  If not provided, range\n    is simply ``(a.min(), a.max())``.  Values outside the range are\n    ignored. The first element of the range must be less than or\n    equal to the second. `range` affects the automatic bin\n    computation as well. While bin width is computed to be optimal\n    based on the actual data within `range`, the bin count will fill\n    the entire range including portions containing no data.\nweights : array_like, optional\n    An array of weights, of the same shape as `a`.  Each value in\n    `a` only contributes its associated weight towards the bin count\n    (instead of 1). If `density` is True, the weights are\n    normalized, so that the integral of the density over the range\n    remains 1.\n    Please note that the ``dtype`` of `weights` will also become the\n    ``dtype`` of the returned accumulator (`hist`), so it must be\n    large enough to hold accumulated values as well.\ndensity : bool, optional\n    If ``False``, the result will contain the number of samples in\n    each bin. If ``True``, the result is the value of the\n    probability *density* function at the bin, normalized such that\n    the *integral* over the range is 1. Note that the sum of the\n    histogram values will not be equal to 1 unless bins of unity\n    width are chosen; it is not a probability *mass* function.\n\nReturns\n-------\nhist : array\n    The values of the histogram. See `density` and `weights` for a\n    description of the possible semantics.  If `weights` are given,\n    ``hist.dtype`` will be taken from `weights`.\nbin_edges : array of dtype float\n    Return the bin edges ``(length(hist)+1)``.\n\n\nSee Also\n--------\nhistogramdd, bincount, searchsorted, digitize, histogram_bin_edges\n\nNotes\n-----\nAll but the last (righthand-most) bin is half-open.  In other words,\nif `bins` is::\n\n  [1, 2, 3, 4]\n\nthen the first bin is ``[1, 2)`` (including 1, but excluding 2) and\nthe second ``[2, 3)``.  The last bin, however, is ``[3, 4]``, which\n*includes* 4.\n\n\nExamples\n--------\n>>> import numpy as np\n>>> np.histogram([1, 2, 1], bins=[0, 1, 2, 3])\n(array([0, 2, 1]), array([0, 1, 2, 3]))\n>>> np.histogram(np.arange(4), bins=np.arange(5), density=True)\n(array([0.25, 0.25, 0.25, 0.25]), array([0, 1, 2, 3, 4]))\n>>> np.histogram([[1, 2, 1], [1, 0, 1]], bins=[0,1,2,3])\n(array([1, 4, 1]), array([0, 1, 2, 3]))\n\n>>> a = np.arange(5)\n>>> hist, bin_edges = np.histogram(a, density=True)\n>>> hist\narray([0.5, 0. , 0.5, 0. , 0. , 0.5, 0. , 0.5, 0. , 0.5])\n>>> hist.sum()\n2.4999999999999996\n>>> np.sum(hist * np.diff(bin_edges))\n1.0\n\nAutomated Bin Selection Methods example, using 2 peak random data\nwith 2000 points.\n\n.. plot::\n    :include-source:\n\n    import matplotlib.pyplot as plt\n    import numpy as np\n\n    rng = np.random.RandomState(10)  # deterministic random data\n    a = np.hstack((rng.normal(size=1000),\n                   rng.normal(loc=5, scale=2, size=1000)))\n    plt.hist(a, bins='auto')  # arguments are passed to np.histogram\n    plt.title(\"Histogram with 'auto' bins\")\n    plt.show()"
    },
    {
      "name": "histogramdd",
      "docstring": "Compute the multidimensional histogram of some data.\n\nParameters\n----------\nsample : (N, D) array, or (N, D) array_like\n    The data to be histogrammed.\n\n    Note the unusual interpretation of sample when an array_like:\n\n    * When an array, each row is a coordinate in a D-dimensional space -\n      such as ``histogramdd(np.array([p1, p2, p3]))``.\n    * When an array_like, each element is the list of values for single\n      coordinate - such as ``histogramdd((X, Y, Z))``.\n\n    The first form should be preferred.\n\nbins : sequence or int, optional\n    The bin specification:\n\n    * A sequence of arrays describing the monotonically increasing bin\n      edges along each dimension.\n    * The number of bins for each dimension (nx, ny, ... =bins)\n    * The number of bins for all dimensions (nx=ny=...=bins).\n\nrange : sequence, optional\n    A sequence of length D, each an optional (lower, upper) tuple giving\n    the outer bin edges to be used if the edges are not given explicitly in\n    `bins`.\n    An entry of None in the sequence results in the minimum and maximum\n    values being used for the corresponding dimension.\n    The default, None, is equivalent to passing a tuple of D None values.\ndensity : bool, optional\n    If False, the default, returns the number of samples in each bin.\n    If True, returns the probability *density* function at the bin,\n    ``bin_count / sample_count / bin_volume``.\nweights : (N,) array_like, optional\n    An array of values `w_i` weighing each sample `(x_i, y_i, z_i, ...)`.\n    Weights are normalized to 1 if density is True. If density is False,\n    the values of the returned histogram are equal to the sum of the\n    weights belonging to the samples falling into each bin.\n\nReturns\n-------\nH : ndarray\n    The multidimensional histogram of sample x. See density and weights\n    for the different possible semantics.\nedges : tuple of ndarrays\n    A tuple of D arrays describing the bin edges for each dimension.\n\nSee Also\n--------\nhistogram: 1-D histogram\nhistogram2d: 2-D histogram\n\nExamples\n--------\n>>> import numpy as np\n>>> rng = np.random.default_rng()\n>>> r = rng.normal(size=(100,3))\n>>> H, edges = np.histogramdd(r, bins = (5, 8, 4))\n>>> H.shape, edges[0].size, edges[1].size, edges[2].size\n((5, 8, 4), 6, 9, 5)"
    },
    {
      "name": "jhat",
      "docstring": null
    }
  ],
  "innovations": []
}