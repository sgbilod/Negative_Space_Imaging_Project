{
  "file_path": "c:\\Users\\sgbil\\OneDrive\\Desktop\\Negative_Space_Imaging_Project\\.venv\\Lib\\site-packages\\fontTools\\ufoLib\\converters.py",
  "classes": [],
  "functions": [
    {
      "name": "convertUFO1OrUFO2KerningToUFO3Kerning",
      "docstring": "Convert kerning data in UFO1 or UFO2 syntax into UFO3 syntax.\n\nArgs:\n  kerning:\n      A dictionary containing the kerning rules defined in\n      the UFO font, as used in :class:`.UFOReader` objects.\n  groups:\n      A dictionary containing the groups defined in the UFO\n      font, as used in :class:`.UFOReader` objects.\n  glyphSet:\n    Optional; a set of glyph objects to skip (default: None).\n\nReturns:\n  1. A dictionary representing the converted kerning data.\n  2. A copy of the groups dictionary, with all groups renamed to UFO3 syntax.\n  3. A dictionary containing the mapping of old group names to new group names."
    },
    {
      "name": "findKnownKerningGroups",
      "docstring": "Find all kerning groups in a UFO1 or UFO2 font that use known prefixes.\n\nIn some cases, not all kerning groups will be referenced\nby the kerning pairs in a UFO. The algorithm for locating\ngroups in :func:`convertUFO1OrUFO2KerningToUFO3Kerning` will\nmiss these unreferenced groups. By scanning for known prefixes,\nthis function will catch all of the prefixed groups.\n\nThe prefixes and sides by this function are:\n\n@MMK_L_ - side 1\n@MMK_R_ - side 2\n\nas defined in the UFO1 specification.\n\nArgs:\n    groups:\n      A dictionary containing the groups defined in the UFO\n      font, as read by :class:`.UFOReader`.\n\nReturns:\n    Two sets; the first containing the names of all\n    first-side kerning groups identified in the ``groups``\n    dictionary, and the second containing the names of all\n    second-side kerning groups identified.\n\n    \"First-side\" and \"second-side\" are with respect to the\n    writing direction of the script.\n\n    Example::\n\n      >>> testGroups = {\n      ...     \"@MMK_L_1\" : None,\n      ...     \"@MMK_L_2\" : None,\n      ...     \"@MMK_L_3\" : None,\n      ...     \"@MMK_R_1\" : None,\n      ...     \"@MMK_R_2\" : None,\n      ...     \"@MMK_R_3\" : None,\n      ...     \"@MMK_l_1\" : None,\n      ...     \"@MMK_r_1\" : None,\n      ...     \"@MMK_X_1\" : None,\n      ...     \"foo\" : None,\n      ... }\n      >>> first, second = findKnownKerningGroups(testGroups)\n      >>> sorted(first) == ['@MMK_L_1', '@MMK_L_2', '@MMK_L_3']\n      True\n      >>> sorted(second) == ['@MMK_R_1', '@MMK_R_2', '@MMK_R_3']\n      True"
    },
    {
      "name": "makeUniqueGroupName",
      "docstring": "Make a kerning group name that will be unique within the set of group names.\n\nIf the requested kerning group name already exists within the set, this\nwill return a new name by adding an incremented counter to the end\nof the requested name.\n\nArgs:\n    name:\n      The requested kerning group name.\n    groupNames:\n      A list of the existing kerning group names.\n    counter:\n      Optional; a counter of group names already seen (default: 0). If\n      :attr:`.counter` is not provided, the function will recurse,\n      incrementing the value of :attr:`.counter` until it finds the\n      first unused ``name+counter`` combination, and return that result.\n\nReturns:\n    A unique kerning group name composed of the requested name suffixed\n    by the smallest available integer counter."
    },
    {
      "name": "test",
      "docstring": "Tests for :func:`.convertUFO1OrUFO2KerningToUFO3Kerning`.\n\nNo known prefixes.\n\n>>> testKerning = {\n...     \"A\" : {\n...         \"A\" : 1,\n...         \"B\" : 2,\n...         \"CGroup\" : 3,\n...         \"DGroup\" : 4\n...     },\n...     \"BGroup\" : {\n...         \"A\" : 5,\n...         \"B\" : 6,\n...         \"CGroup\" : 7,\n...         \"DGroup\" : 8\n...     },\n...     \"CGroup\" : {\n...         \"A\" : 9,\n...         \"B\" : 10,\n...         \"CGroup\" : 11,\n...         \"DGroup\" : 12\n...     },\n... }\n>>> testGroups = {\n...     \"BGroup\" : [\"B\"],\n...     \"CGroup\" : [\"C\"],\n...     \"DGroup\" : [\"D\"],\n... }\n>>> kerning, groups, maps = convertUFO1OrUFO2KerningToUFO3Kerning(\n...     testKerning, testGroups, [])\n>>> expected = {\n...     \"A\" : {\n...         \"A\": 1,\n...         \"B\": 2,\n...         \"public.kern2.CGroup\": 3,\n...         \"public.kern2.DGroup\": 4\n...     },\n...     \"public.kern1.BGroup\": {\n...         \"A\": 5,\n...         \"B\": 6,\n...         \"public.kern2.CGroup\": 7,\n...         \"public.kern2.DGroup\": 8\n...     },\n...     \"public.kern1.CGroup\": {\n...         \"A\": 9,\n...         \"B\": 10,\n...         \"public.kern2.CGroup\": 11,\n...         \"public.kern2.DGroup\": 12\n...     }\n... }\n>>> kerning == expected\nTrue\n>>> expected = {\n...     \"BGroup\": [\"B\"],\n...     \"CGroup\": [\"C\"],\n...     \"DGroup\": [\"D\"],\n...     \"public.kern1.BGroup\": [\"B\"],\n...     \"public.kern1.CGroup\": [\"C\"],\n...     \"public.kern2.CGroup\": [\"C\"],\n...     \"public.kern2.DGroup\": [\"D\"],\n... }\n>>> groups == expected\nTrue\n\nKnown prefixes.\n\n>>> testKerning = {\n...     \"A\" : {\n...         \"A\" : 1,\n...         \"B\" : 2,\n...         \"@MMK_R_CGroup\" : 3,\n...         \"@MMK_R_DGroup\" : 4\n...     },\n...     \"@MMK_L_BGroup\" : {\n...         \"A\" : 5,\n...         \"B\" : 6,\n...         \"@MMK_R_CGroup\" : 7,\n...         \"@MMK_R_DGroup\" : 8\n...     },\n...     \"@MMK_L_CGroup\" : {\n...         \"A\" : 9,\n...         \"B\" : 10,\n...         \"@MMK_R_CGroup\" : 11,\n...         \"@MMK_R_DGroup\" : 12\n...     },\n... }\n>>> testGroups = {\n...     \"@MMK_L_BGroup\" : [\"B\"],\n...     \"@MMK_L_CGroup\" : [\"C\"],\n...     \"@MMK_L_XGroup\" : [\"X\"],\n...     \"@MMK_R_CGroup\" : [\"C\"],\n...     \"@MMK_R_DGroup\" : [\"D\"],\n...     \"@MMK_R_XGroup\" : [\"X\"],\n... }\n>>> kerning, groups, maps = convertUFO1OrUFO2KerningToUFO3Kerning(\n...     testKerning, testGroups, [])\n>>> expected = {\n...     \"A\" : {\n...         \"A\": 1,\n...         \"B\": 2,\n...         \"public.kern2.CGroup\": 3,\n...         \"public.kern2.DGroup\": 4\n...     },\n...     \"public.kern1.BGroup\": {\n...         \"A\": 5,\n...         \"B\": 6,\n...         \"public.kern2.CGroup\": 7,\n...         \"public.kern2.DGroup\": 8\n...     },\n...     \"public.kern1.CGroup\": {\n...         \"A\": 9,\n...         \"B\": 10,\n...         \"public.kern2.CGroup\": 11,\n...         \"public.kern2.DGroup\": 12\n...     }\n... }\n>>> kerning == expected\nTrue\n>>> expected = {\n...     \"@MMK_L_BGroup\": [\"B\"],\n...     \"@MMK_L_CGroup\": [\"C\"],\n...     \"@MMK_L_XGroup\": [\"X\"],\n...     \"@MMK_R_CGroup\": [\"C\"],\n...     \"@MMK_R_DGroup\": [\"D\"],\n...     \"@MMK_R_XGroup\": [\"X\"],\n...     \"public.kern1.BGroup\": [\"B\"],\n...     \"public.kern1.CGroup\": [\"C\"],\n...     \"public.kern1.XGroup\": [\"X\"],\n...     \"public.kern2.CGroup\": [\"C\"],\n...     \"public.kern2.DGroup\": [\"D\"],\n...     \"public.kern2.XGroup\": [\"X\"],\n... }\n>>> groups == expected\nTrue\n\n>>> from .validators import kerningValidator\n>>> kerningValidator(kerning)\n(True, None)\n\nMixture of known prefixes and groups without prefixes.\n\n>>> testKerning = {\n...     \"A\" : {\n...         \"A\" : 1,\n...         \"B\" : 2,\n...         \"@MMK_R_CGroup\" : 3,\n...         \"DGroup\" : 4\n...     },\n...     \"BGroup\" : {\n...         \"A\" : 5,\n...         \"B\" : 6,\n...         \"@MMK_R_CGroup\" : 7,\n...         \"DGroup\" : 8\n...     },\n...     \"@MMK_L_CGroup\" : {\n...         \"A\" : 9,\n...         \"B\" : 10,\n...         \"@MMK_R_CGroup\" : 11,\n...         \"DGroup\" : 12\n...     },\n... }\n>>> testGroups = {\n...     \"BGroup\" : [\"B\"],\n...     \"@MMK_L_CGroup\" : [\"C\"],\n...     \"@MMK_R_CGroup\" : [\"C\"],\n...     \"DGroup\" : [\"D\"],\n... }\n>>> kerning, groups, maps = convertUFO1OrUFO2KerningToUFO3Kerning(\n...     testKerning, testGroups, [])\n>>> expected = {\n...     \"A\" : {\n...         \"A\": 1,\n...         \"B\": 2,\n...         \"public.kern2.CGroup\": 3,\n...         \"public.kern2.DGroup\": 4\n...     },\n...     \"public.kern1.BGroup\": {\n...         \"A\": 5,\n...         \"B\": 6,\n...         \"public.kern2.CGroup\": 7,\n...         \"public.kern2.DGroup\": 8\n...     },\n...     \"public.kern1.CGroup\": {\n...         \"A\": 9,\n...         \"B\": 10,\n...         \"public.kern2.CGroup\": 11,\n...         \"public.kern2.DGroup\": 12\n...     }\n... }\n>>> kerning == expected\nTrue\n>>> expected = {\n...     \"BGroup\": [\"B\"],\n...     \"@MMK_L_CGroup\": [\"C\"],\n...     \"@MMK_R_CGroup\": [\"C\"],\n...     \"DGroup\": [\"D\"],\n...     \"public.kern1.BGroup\": [\"B\"],\n...     \"public.kern1.CGroup\": [\"C\"],\n...     \"public.kern2.CGroup\": [\"C\"],\n...     \"public.kern2.DGroup\": [\"D\"],\n... }\n>>> groups == expected\nTrue"
    }
  ],
  "innovations": []
}