{
  "file_path": "c:\\Users\\sgbil\\OneDrive\\Desktop\\Negative_Space_Imaging_Project\\.venv\\Lib\\site-packages\\pywt\\_multidim.py",
  "classes": [],
  "functions": [
    {
      "name": "dwt2",
      "docstring": "2D Discrete Wavelet Transform.\n\nParameters\n----------\ndata : array_like\n    2D array with input data\nwavelet : Wavelet object or name string, or 2-tuple of wavelets\n    Wavelet to use.  This can also be a tuple containing a wavelet to\n    apply along each axis in ``axes``.\nmode : str or 2-tuple of strings, optional\n    Signal extension mode, see :ref:`Modes <ref-modes>`. This can\n    also be a tuple of modes specifying the mode to use on each axis in\n    ``axes``.\naxes : 2-tuple of ints, optional\n    Axes over which to compute the DWT. Repeated elements mean the DWT will\n    be performed multiple times along these axes.\n\nReturns\n-------\n(cA, (cH, cV, cD)) : tuple\n    Approximation, horizontal detail, vertical detail and diagonal\n    detail coefficients respectively.  Horizontal refers to array axis 0\n    (or ``axes[0]`` for user-specified ``axes``).\n\nExamples\n--------\n>>> import numpy as np\n>>> import pywt\n>>> data = np.ones((4,4), dtype=np.float64)\n>>> coeffs = pywt.dwt2(data, 'haar')\n>>> cA, (cH, cV, cD) = coeffs\n>>> cA\narray([[ 2.,  2.],\n       [ 2.,  2.]])\n>>> cV\narray([[ 0.,  0.],\n       [ 0.,  0.]])"
    },
    {
      "name": "idwt2",
      "docstring": "2-D Inverse Discrete Wavelet Transform.\n\nReconstructs data from coefficient arrays.\n\nParameters\n----------\ncoeffs : tuple\n    (cA, (cH, cV, cD)) A tuple with approximation coefficients and three\n    details coefficients 2D arrays like from ``dwt2``.  If any of these\n    components are set to ``None``, it will be treated as zeros.\nwavelet : Wavelet object or name string, or 2-tuple of wavelets\n    Wavelet to use.  This can also be a tuple containing a wavelet to\n    apply along each axis in ``axes``.\nmode : str or 2-tuple of strings, optional\n    Signal extension mode, see :ref:`Modes <ref-modes>`. This can\n    also be a tuple of modes specifying the mode to use on each axis in\n    ``axes``.\naxes : 2-tuple of ints, optional\n    Axes over which to compute the IDWT. Repeated elements mean the IDWT\n    will be performed multiple times along these axes.\n\nExamples\n--------\n>>> import numpy as np\n>>> import pywt\n>>> data = np.array([[1,2], [3,4]], dtype=np.float64)\n>>> coeffs = pywt.dwt2(data, 'haar')\n>>> pywt.idwt2(coeffs, 'haar')\narray([[ 1.,  2.],\n       [ 3.,  4.]])"
    },
    {
      "name": "dwtn",
      "docstring": "Single-level n-dimensional Discrete Wavelet Transform.\n\nParameters\n----------\ndata : array_like\n    n-dimensional array with input data.\nwavelet : Wavelet object or name string, or tuple of wavelets\n    Wavelet to use.  This can also be a tuple containing a wavelet to\n    apply along each axis in ``axes``.\nmode : str or tuple of string, optional\n    Signal extension mode used in the decomposition,\n    see :ref:`Modes <ref-modes>`. This can also be a tuple of modes\n    specifying the mode to use on each axis in ``axes``.\naxes : sequence of ints, optional\n    Axes over which to compute the DWT. Repeated elements mean the DWT will\n    be performed multiple times along these axes. A value of ``None`` (the\n    default) selects all axes.\n\n    Axes may be repeated, but information about the original size may be\n    lost if it is not divisible by ``2 ** nrepeats``. The reconstruction\n    will be larger, with additional values derived according to the\n    ``mode`` parameter. ``pywt.wavedecn`` should be used for multilevel\n    decomposition.\n\nReturns\n-------\ncoeffs : dict\n    Results are arranged in a dictionary, where key specifies\n    the transform type on each dimension and value is a n-dimensional\n    coefficients array.\n\n    For example, for a 2D case the result will look something like this::\n\n        {'aa': <coeffs>  # A(LL) - approx. on 1st dim, approx. on 2nd dim\n         'ad': <coeffs>  # V(LH) - approx. on 1st dim, det. on 2nd dim\n         'da': <coeffs>  # H(HL) - det. on 1st dim, approx. on 2nd dim\n         'dd': <coeffs>  # D(HH) - det. on 1st dim, det. on 2nd dim\n        }\n\n    For user-specified ``axes``, the order of the characters in the\n    dictionary keys map to the specified ``axes``."
    },
    {
      "name": "idwtn",
      "docstring": "Single-level n-dimensional Inverse Discrete Wavelet Transform.\n\nParameters\n----------\ncoeffs: dict\n    Dictionary as in output of ``dwtn``. Missing or ``None`` items\n    will be treated as zeros.\nwavelet : Wavelet object or name string, or tuple of wavelets\n    Wavelet to use.  This can also be a tuple containing a wavelet to\n    apply along each axis in ``axes``.\nmode : str or list of string, optional\n    Signal extension mode used in the decomposition,\n    see :ref:`Modes <ref-modes>`. This can also be a tuple of modes\n    specifying the mode to use on each axis in ``axes``.\naxes : sequence of ints, optional\n    Axes over which to compute the IDWT. Repeated elements mean the IDWT\n    will be performed multiple times along these axes. A value of ``None``\n    (the default) selects all axes.\n\n    For the most accurate reconstruction, the axes should be provided in\n    the same order as they were provided to ``dwtn``.\n\nReturns\n-------\ndata: ndarray\n    Original signal reconstructed from input data."
    }
  ],
  "innovations": []
}