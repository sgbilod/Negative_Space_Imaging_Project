{
  "file_path": "c:\\Users\\sgbil\\OneDrive\\Desktop\\Negative_Space_Imaging_Project\\.venv\\Lib\\site-packages\\numpy\\lib\\_shape_base_impl.py",
  "classes": [],
  "functions": [
    {
      "name": "take_along_axis",
      "docstring": "Take values from the input array by matching 1d index and data slices.\n\nThis iterates over matching 1d slices oriented along the specified axis in\nthe index and data arrays, and uses the former to look up values in the\nlatter. These slices can be different lengths.\n\nFunctions returning an index along an axis, like `argsort` and\n`argpartition`, produce suitable indices for this function.\n\nParameters\n----------\narr : ndarray (Ni..., M, Nk...)\n    Source array\nindices : ndarray (Ni..., J, Nk...)\n    Indices to take along each 1d slice of `arr`. This must match the\n    dimension of arr, but dimensions Ni and Nj only need to broadcast\n    against `arr`.\naxis : int\n    The axis to take 1d slices along. If axis is None, the input array is\n    treated as if it had first been flattened to 1d, for consistency with\n    `sort` and `argsort`.\n\nReturns\n-------\nout: ndarray (Ni..., J, Nk...)\n    The indexed result.\n\nNotes\n-----\nThis is equivalent to (but faster than) the following use of `ndindex` and\n`s_`, which sets each of ``ii`` and ``kk`` to a tuple of indices::\n\n    Ni, M, Nk = a.shape[:axis], a.shape[axis], a.shape[axis+1:]\n    J = indices.shape[axis]  # Need not equal M\n    out = np.empty(Ni + (J,) + Nk)\n\n    for ii in ndindex(Ni):\n        for kk in ndindex(Nk):\n            a_1d       = a      [ii + s_[:,] + kk]\n            indices_1d = indices[ii + s_[:,] + kk]\n            out_1d     = out    [ii + s_[:,] + kk]\n            for j in range(J):\n                out_1d[j] = a_1d[indices_1d[j]]\n\nEquivalently, eliminating the inner loop, the last two lines would be::\n\n            out_1d[:] = a_1d[indices_1d]\n\nSee Also\n--------\ntake : Take along an axis, using the same indices for every 1d slice\nput_along_axis :\n    Put values into the destination array by matching 1d index and data slices\n\nExamples\n--------\n>>> import numpy as np\n\nFor this sample array\n\n>>> a = np.array([[10, 30, 20], [60, 40, 50]])\n\nWe can sort either by using sort directly, or argsort and this function\n\n>>> np.sort(a, axis=1)\narray([[10, 20, 30],\n       [40, 50, 60]])\n>>> ai = np.argsort(a, axis=1)\n>>> ai\narray([[0, 2, 1],\n       [1, 2, 0]])\n>>> np.take_along_axis(a, ai, axis=1)\narray([[10, 20, 30],\n       [40, 50, 60]])\n\nThe same works for max and min, if you maintain the trivial dimension\nwith ``keepdims``:\n\n>>> np.max(a, axis=1, keepdims=True)\narray([[30],\n       [60]])\n>>> ai = np.argmax(a, axis=1, keepdims=True)\n>>> ai\narray([[1],\n       [0]])\n>>> np.take_along_axis(a, ai, axis=1)\narray([[30],\n       [60]])\n\nIf we want to get the max and min at the same time, we can stack the\nindices first\n\n>>> ai_min = np.argmin(a, axis=1, keepdims=True)\n>>> ai_max = np.argmax(a, axis=1, keepdims=True)\n>>> ai = np.concatenate([ai_min, ai_max], axis=1)\n>>> ai\narray([[0, 1],\n       [1, 0]])\n>>> np.take_along_axis(a, ai, axis=1)\narray([[10, 30],\n       [40, 60]])"
    },
    {
      "name": "put_along_axis",
      "docstring": "Put values into the destination array by matching 1d index and data slices.\n\nThis iterates over matching 1d slices oriented along the specified axis in\nthe index and data arrays, and uses the former to place values into the\nlatter. These slices can be different lengths.\n\nFunctions returning an index along an axis, like `argsort` and\n`argpartition`, produce suitable indices for this function.\n\nParameters\n----------\narr : ndarray (Ni..., M, Nk...)\n    Destination array.\nindices : ndarray (Ni..., J, Nk...)\n    Indices to change along each 1d slice of `arr`. This must match the\n    dimension of arr, but dimensions in Ni and Nj may be 1 to broadcast\n    against `arr`.\nvalues : array_like (Ni..., J, Nk...)\n    values to insert at those indices. Its shape and dimension are\n    broadcast to match that of `indices`.\naxis : int\n    The axis to take 1d slices along. If axis is None, the destination\n    array is treated as if a flattened 1d view had been created of it.\n\nNotes\n-----\nThis is equivalent to (but faster than) the following use of `ndindex` and\n`s_`, which sets each of ``ii`` and ``kk`` to a tuple of indices::\n\n    Ni, M, Nk = a.shape[:axis], a.shape[axis], a.shape[axis+1:]\n    J = indices.shape[axis]  # Need not equal M\n\n    for ii in ndindex(Ni):\n        for kk in ndindex(Nk):\n            a_1d       = a      [ii + s_[:,] + kk]\n            indices_1d = indices[ii + s_[:,] + kk]\n            values_1d  = values [ii + s_[:,] + kk]\n            for j in range(J):\n                a_1d[indices_1d[j]] = values_1d[j]\n\nEquivalently, eliminating the inner loop, the last two lines would be::\n\n            a_1d[indices_1d] = values_1d\n\nSee Also\n--------\ntake_along_axis :\n    Take values from the input array by matching 1d index and data slices\n\nExamples\n--------\n>>> import numpy as np\n\nFor this sample array\n\n>>> a = np.array([[10, 30, 20], [60, 40, 50]])\n\nWe can replace the maximum values with:\n\n>>> ai = np.argmax(a, axis=1, keepdims=True)\n>>> ai\narray([[1],\n       [0]])\n>>> np.put_along_axis(a, ai, 99, axis=1)\n>>> a\narray([[10, 99, 20],\n       [99, 40, 50]])"
    },
    {
      "name": "apply_along_axis",
      "docstring": "Apply a function to 1-D slices along the given axis.\n\nExecute `func1d(a, *args, **kwargs)` where `func1d` operates on 1-D arrays\nand `a` is a 1-D slice of `arr` along `axis`.\n\nThis is equivalent to (but faster than) the following use of `ndindex` and\n`s_`, which sets each of ``ii``, ``jj``, and ``kk`` to a tuple of indices::\n\n    Ni, Nk = a.shape[:axis], a.shape[axis+1:]\n    for ii in ndindex(Ni):\n        for kk in ndindex(Nk):\n            f = func1d(arr[ii + s_[:,] + kk])\n            Nj = f.shape\n            for jj in ndindex(Nj):\n                out[ii + jj + kk] = f[jj]\n\nEquivalently, eliminating the inner loop, this can be expressed as::\n\n    Ni, Nk = a.shape[:axis], a.shape[axis+1:]\n    for ii in ndindex(Ni):\n        for kk in ndindex(Nk):\n            out[ii + s_[...,] + kk] = func1d(arr[ii + s_[:,] + kk])\n\nParameters\n----------\nfunc1d : function (M,) -> (Nj...)\n    This function should accept 1-D arrays. It is applied to 1-D\n    slices of `arr` along the specified axis.\naxis : integer\n    Axis along which `arr` is sliced.\narr : ndarray (Ni..., M, Nk...)\n    Input array.\nargs : any\n    Additional arguments to `func1d`.\nkwargs : any\n    Additional named arguments to `func1d`.\n\nReturns\n-------\nout : ndarray  (Ni..., Nj..., Nk...)\n    The output array. The shape of `out` is identical to the shape of\n    `arr`, except along the `axis` dimension. This axis is removed, and\n    replaced with new dimensions equal to the shape of the return value\n    of `func1d`. So if `func1d` returns a scalar `out` will have one\n    fewer dimensions than `arr`.\n\nSee Also\n--------\napply_over_axes : Apply a function repeatedly over multiple axes.\n\nExamples\n--------\n>>> import numpy as np\n>>> def my_func(a):\n...     \"\"\"Average first and last element of a 1-D array\"\"\"\n...     return (a[0] + a[-1]) * 0.5\n>>> b = np.array([[1,2,3], [4,5,6], [7,8,9]])\n>>> np.apply_along_axis(my_func, 0, b)\narray([4., 5., 6.])\n>>> np.apply_along_axis(my_func, 1, b)\narray([2.,  5.,  8.])\n\nFor a function that returns a 1D array, the number of dimensions in\n`outarr` is the same as `arr`.\n\n>>> b = np.array([[8,1,7], [4,3,9], [5,2,6]])\n>>> np.apply_along_axis(sorted, 1, b)\narray([[1, 7, 8],\n       [3, 4, 9],\n       [2, 5, 6]])\n\nFor a function that returns a higher dimensional array, those dimensions\nare inserted in place of the `axis` dimension.\n\n>>> b = np.array([[1,2,3], [4,5,6], [7,8,9]])\n>>> np.apply_along_axis(np.diag, -1, b)\narray([[[1, 0, 0],\n        [0, 2, 0],\n        [0, 0, 3]],\n       [[4, 0, 0],\n        [0, 5, 0],\n        [0, 0, 6]],\n       [[7, 0, 0],\n        [0, 8, 0],\n        [0, 0, 9]]])"
    },
    {
      "name": "apply_over_axes",
      "docstring": "Apply a function repeatedly over multiple axes.\n\n`func` is called as `res = func(a, axis)`, where `axis` is the first\nelement of `axes`.  The result `res` of the function call must have\neither the same dimensions as `a` or one less dimension.  If `res`\nhas one less dimension than `a`, a dimension is inserted before\n`axis`.  The call to `func` is then repeated for each axis in `axes`,\nwith `res` as the first argument.\n\nParameters\n----------\nfunc : function\n    This function must take two arguments, `func(a, axis)`.\na : array_like\n    Input array.\naxes : array_like\n    Axes over which `func` is applied; the elements must be integers.\n\nReturns\n-------\napply_over_axis : ndarray\n    The output array.  The number of dimensions is the same as `a`,\n    but the shape can be different.  This depends on whether `func`\n    changes the shape of its output with respect to its input.\n\nSee Also\n--------\napply_along_axis :\n    Apply a function to 1-D slices of an array along the given axis.\n\nNotes\n-----\nThis function is equivalent to tuple axis arguments to reorderable ufuncs\nwith keepdims=True. Tuple axis arguments to ufuncs have been available since\nversion 1.7.0.\n\nExamples\n--------\n>>> import numpy as np\n>>> a = np.arange(24).reshape(2,3,4)\n>>> a\narray([[[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]],\n       [[12, 13, 14, 15],\n        [16, 17, 18, 19],\n        [20, 21, 22, 23]]])\n\nSum over axes 0 and 2. The result has same number of dimensions\nas the original array:\n\n>>> np.apply_over_axes(np.sum, a, [0,2])\narray([[[ 60],\n        [ 92],\n        [124]]])\n\nTuple axis arguments to ufuncs are equivalent:\n\n>>> np.sum(a, axis=(0,2), keepdims=True)\narray([[[ 60],\n        [ 92],\n        [124]]])"
    },
    {
      "name": "expand_dims",
      "docstring": "Expand the shape of an array.\n\nInsert a new axis that will appear at the `axis` position in the expanded\narray shape.\n\nParameters\n----------\na : array_like\n    Input array.\naxis : int or tuple of ints\n    Position in the expanded axes where the new axis (or axes) is placed.\n\n    .. deprecated:: 1.13.0\n        Passing an axis where ``axis > a.ndim`` will be treated as\n        ``axis == a.ndim``, and passing ``axis < -a.ndim - 1`` will\n        be treated as ``axis == 0``. This behavior is deprecated.\n\nReturns\n-------\nresult : ndarray\n    View of `a` with the number of dimensions increased.\n\nSee Also\n--------\nsqueeze : The inverse operation, removing singleton dimensions\nreshape : Insert, remove, and combine dimensions, and resize existing ones\natleast_1d, atleast_2d, atleast_3d\n\nExamples\n--------\n>>> import numpy as np\n>>> x = np.array([1, 2])\n>>> x.shape\n(2,)\n\nThe following is equivalent to ``x[np.newaxis, :]`` or ``x[np.newaxis]``:\n\n>>> y = np.expand_dims(x, axis=0)\n>>> y\narray([[1, 2]])\n>>> y.shape\n(1, 2)\n\nThe following is equivalent to ``x[:, np.newaxis]``:\n\n>>> y = np.expand_dims(x, axis=1)\n>>> y\narray([[1],\n       [2]])\n>>> y.shape\n(2, 1)\n\n``axis`` may also be a tuple:\n\n>>> y = np.expand_dims(x, axis=(0, 1))\n>>> y\narray([[[1, 2]]])\n\n>>> y = np.expand_dims(x, axis=(2, 0))\n>>> y\narray([[[1],\n        [2]]])\n\nNote that some examples may use ``None`` instead of ``np.newaxis``.  These\nare the same objects:\n\n>>> np.newaxis is None\nTrue"
    },
    {
      "name": "row_stack",
      "docstring": null
    },
    {
      "name": "column_stack",
      "docstring": "Stack 1-D arrays as columns into a 2-D array.\n\nTake a sequence of 1-D arrays and stack them as columns\nto make a single 2-D array. 2-D arrays are stacked as-is,\njust like with `hstack`.  1-D arrays are turned into 2-D columns\nfirst.\n\nParameters\n----------\ntup : sequence of 1-D or 2-D arrays.\n    Arrays to stack. All of them must have the same first dimension.\n\nReturns\n-------\nstacked : 2-D array\n    The array formed by stacking the given arrays.\n\nSee Also\n--------\nstack, hstack, vstack, concatenate\n\nExamples\n--------\n>>> import numpy as np\n>>> a = np.array((1,2,3))\n>>> b = np.array((2,3,4))\n>>> np.column_stack((a,b))\narray([[1, 2],\n       [2, 3],\n       [3, 4]])"
    },
    {
      "name": "dstack",
      "docstring": "Stack arrays in sequence depth wise (along third axis).\n\nThis is equivalent to concatenation along the third axis after 2-D arrays\nof shape `(M,N)` have been reshaped to `(M,N,1)` and 1-D arrays of shape\n`(N,)` have been reshaped to `(1,N,1)`. Rebuilds arrays divided by\n`dsplit`.\n\nThis function makes most sense for arrays with up to 3 dimensions. For\ninstance, for pixel-data with a height (first axis), width (second axis),\nand r/g/b channels (third axis). The functions `concatenate`, `stack` and\n`block` provide more general stacking and concatenation operations.\n\nParameters\n----------\ntup : sequence of arrays\n    The arrays must have the same shape along all but the third axis.\n    1-D or 2-D arrays must have the same shape.\n\nReturns\n-------\nstacked : ndarray\n    The array formed by stacking the given arrays, will be at least 3-D.\n\nSee Also\n--------\nconcatenate : Join a sequence of arrays along an existing axis.\nstack : Join a sequence of arrays along a new axis.\nblock : Assemble an nd-array from nested lists of blocks.\nvstack : Stack arrays in sequence vertically (row wise).\nhstack : Stack arrays in sequence horizontally (column wise).\ncolumn_stack : Stack 1-D arrays as columns into a 2-D array.\ndsplit : Split array along third axis.\n\nExamples\n--------\n>>> import numpy as np\n>>> a = np.array((1,2,3))\n>>> b = np.array((2,3,4))\n>>> np.dstack((a,b))\narray([[[1, 2],\n        [2, 3],\n        [3, 4]]])\n\n>>> a = np.array([[1],[2],[3]])\n>>> b = np.array([[2],[3],[4]])\n>>> np.dstack((a,b))\narray([[[1, 2]],\n       [[2, 3]],\n       [[3, 4]]])"
    },
    {
      "name": "array_split",
      "docstring": "Split an array into multiple sub-arrays.\n\nPlease refer to the ``split`` documentation.  The only difference\nbetween these functions is that ``array_split`` allows\n`indices_or_sections` to be an integer that does *not* equally\ndivide the axis. For an array of length l that should be split\ninto n sections, it returns l % n sub-arrays of size l//n + 1\nand the rest of size l//n.\n\nSee Also\n--------\nsplit : Split array into multiple sub-arrays of equal size.\n\nExamples\n--------\n>>> import numpy as np\n>>> x = np.arange(8.0)\n>>> np.array_split(x, 3)\n[array([0.,  1.,  2.]), array([3.,  4.,  5.]), array([6.,  7.])]\n\n>>> x = np.arange(9)\n>>> np.array_split(x, 4)\n[array([0, 1, 2]), array([3, 4]), array([5, 6]), array([7, 8])]"
    },
    {
      "name": "split",
      "docstring": "Split an array into multiple sub-arrays as views into `ary`.\n\nParameters\n----------\nary : ndarray\n    Array to be divided into sub-arrays.\nindices_or_sections : int or 1-D array\n    If `indices_or_sections` is an integer, N, the array will be divided\n    into N equal arrays along `axis`.  If such a split is not possible,\n    an error is raised.\n\n    If `indices_or_sections` is a 1-D array of sorted integers, the entries\n    indicate where along `axis` the array is split.  For example,\n    ``[2, 3]`` would, for ``axis=0``, result in\n\n    - ary[:2]\n    - ary[2:3]\n    - ary[3:]\n\n    If an index exceeds the dimension of the array along `axis`,\n    an empty sub-array is returned correspondingly.\naxis : int, optional\n    The axis along which to split, default is 0.\n\nReturns\n-------\nsub-arrays : list of ndarrays\n    A list of sub-arrays as views into `ary`.\n\nRaises\n------\nValueError\n    If `indices_or_sections` is given as an integer, but\n    a split does not result in equal division.\n\nSee Also\n--------\narray_split : Split an array into multiple sub-arrays of equal or\n              near-equal size.  Does not raise an exception if\n              an equal division cannot be made.\nhsplit : Split array into multiple sub-arrays horizontally (column-wise).\nvsplit : Split array into multiple sub-arrays vertically (row wise).\ndsplit : Split array into multiple sub-arrays along the 3rd axis (depth).\nconcatenate : Join a sequence of arrays along an existing axis.\nstack : Join a sequence of arrays along a new axis.\nhstack : Stack arrays in sequence horizontally (column wise).\nvstack : Stack arrays in sequence vertically (row wise).\ndstack : Stack arrays in sequence depth wise (along third dimension).\n\nExamples\n--------\n>>> import numpy as np\n>>> x = np.arange(9.0)\n>>> np.split(x, 3)\n[array([0.,  1.,  2.]), array([3.,  4.,  5.]), array([6.,  7.,  8.])]\n\n>>> x = np.arange(8.0)\n>>> np.split(x, [3, 5, 6, 10])\n[array([0.,  1.,  2.]),\n array([3.,  4.]),\n array([5.]),\n array([6.,  7.]),\n array([], dtype=float64)]"
    },
    {
      "name": "hsplit",
      "docstring": "Split an array into multiple sub-arrays horizontally (column-wise).\n\nPlease refer to the `split` documentation.  `hsplit` is equivalent\nto `split` with ``axis=1``, the array is always split along the second\naxis except for 1-D arrays, where it is split at ``axis=0``.\n\nSee Also\n--------\nsplit : Split an array into multiple sub-arrays of equal size.\n\nExamples\n--------\n>>> import numpy as np\n>>> x = np.arange(16.0).reshape(4, 4)\n>>> x\narray([[ 0.,   1.,   2.,   3.],\n       [ 4.,   5.,   6.,   7.],\n       [ 8.,   9.,  10.,  11.],\n       [12.,  13.,  14.,  15.]])\n>>> np.hsplit(x, 2)\n[array([[  0.,   1.],\n       [  4.,   5.],\n       [  8.,   9.],\n       [12.,  13.]]),\n array([[  2.,   3.],\n       [  6.,   7.],\n       [10.,  11.],\n       [14.,  15.]])]\n>>> np.hsplit(x, np.array([3, 6]))\n[array([[ 0.,   1.,   2.],\n       [ 4.,   5.,   6.],\n       [ 8.,   9.,  10.],\n       [12.,  13.,  14.]]),\n array([[ 3.],\n       [ 7.],\n       [11.],\n       [15.]]),\n array([], shape=(4, 0), dtype=float64)]\n\nWith a higher dimensional array the split is still along the second axis.\n\n>>> x = np.arange(8.0).reshape(2, 2, 2)\n>>> x\narray([[[0.,  1.],\n        [2.,  3.]],\n       [[4.,  5.],\n        [6.,  7.]]])\n>>> np.hsplit(x, 2)\n[array([[[0.,  1.]],\n       [[4.,  5.]]]),\n array([[[2.,  3.]],\n       [[6.,  7.]]])]\n\nWith a 1-D array, the split is along axis 0.\n\n>>> x = np.array([0, 1, 2, 3, 4, 5])\n>>> np.hsplit(x, 2)\n[array([0, 1, 2]), array([3, 4, 5])]"
    },
    {
      "name": "vsplit",
      "docstring": "Split an array into multiple sub-arrays vertically (row-wise).\n\nPlease refer to the ``split`` documentation.  ``vsplit`` is equivalent\nto ``split`` with `axis=0` (default), the array is always split along the\nfirst axis regardless of the array dimension.\n\nSee Also\n--------\nsplit : Split an array into multiple sub-arrays of equal size.\n\nExamples\n--------\n>>> import numpy as np\n>>> x = np.arange(16.0).reshape(4, 4)\n>>> x\narray([[ 0.,   1.,   2.,   3.],\n       [ 4.,   5.,   6.,   7.],\n       [ 8.,   9.,  10.,  11.],\n       [12.,  13.,  14.,  15.]])\n>>> np.vsplit(x, 2)\n[array([[0., 1., 2., 3.],\n        [4., 5., 6., 7.]]),\n array([[ 8.,  9., 10., 11.],\n        [12., 13., 14., 15.]])]\n>>> np.vsplit(x, np.array([3, 6]))\n[array([[ 0.,  1.,  2.,  3.],\n        [ 4.,  5.,  6.,  7.],\n        [ 8.,  9., 10., 11.]]),\n array([[12., 13., 14., 15.]]),\n array([], shape=(0, 4), dtype=float64)]\n\nWith a higher dimensional array the split is still along the first axis.\n\n>>> x = np.arange(8.0).reshape(2, 2, 2)\n>>> x\narray([[[0.,  1.],\n        [2.,  3.]],\n       [[4.,  5.],\n        [6.,  7.]]])\n>>> np.vsplit(x, 2)\n[array([[[0., 1.],\n         [2., 3.]]]),\n array([[[4., 5.],\n         [6., 7.]]])]"
    },
    {
      "name": "dsplit",
      "docstring": "Split array into multiple sub-arrays along the 3rd axis (depth).\n\nPlease refer to the `split` documentation.  `dsplit` is equivalent\nto `split` with ``axis=2``, the array is always split along the third\naxis provided the array dimension is greater than or equal to 3.\n\nSee Also\n--------\nsplit : Split an array into multiple sub-arrays of equal size.\n\nExamples\n--------\n>>> import numpy as np\n>>> x = np.arange(16.0).reshape(2, 2, 4)\n>>> x\narray([[[ 0.,   1.,   2.,   3.],\n        [ 4.,   5.,   6.,   7.]],\n       [[ 8.,   9.,  10.,  11.],\n        [12.,  13.,  14.,  15.]]])\n>>> np.dsplit(x, 2)\n[array([[[ 0.,  1.],\n        [ 4.,  5.]],\n       [[ 8.,  9.],\n        [12., 13.]]]), array([[[ 2.,  3.],\n        [ 6.,  7.]],\n       [[10., 11.],\n        [14., 15.]]])]\n>>> np.dsplit(x, np.array([3, 6]))\n[array([[[ 0.,   1.,   2.],\n        [ 4.,   5.,   6.]],\n       [[ 8.,   9.,  10.],\n        [12.,  13.,  14.]]]),\n array([[[ 3.],\n        [ 7.]],\n       [[11.],\n        [15.]]]),\narray([], shape=(2, 2, 0), dtype=float64)]"
    },
    {
      "name": "get_array_wrap",
      "docstring": "Find the wrapper for the array with the highest priority.\n\nIn case of ties, leftmost wins. If no wrapper is found, return None.\n\n.. deprecated:: 2.0"
    },
    {
      "name": "kron",
      "docstring": "Kronecker product of two arrays.\n\nComputes the Kronecker product, a composite array made of blocks of the\nsecond array scaled by the first.\n\nParameters\n----------\na, b : array_like\n\nReturns\n-------\nout : ndarray\n\nSee Also\n--------\nouter : The outer product\n\nNotes\n-----\nThe function assumes that the number of dimensions of `a` and `b`\nare the same, if necessary prepending the smallest with ones.\nIf ``a.shape = (r0,r1,..,rN)`` and ``b.shape = (s0,s1,...,sN)``,\nthe Kronecker product has shape ``(r0*s0, r1*s1, ..., rN*SN)``.\nThe elements are products of elements from `a` and `b`, organized\nexplicitly by::\n\n    kron(a,b)[k0,k1,...,kN] = a[i0,i1,...,iN] * b[j0,j1,...,jN]\n\nwhere::\n\n    kt = it * st + jt,  t = 0,...,N\n\nIn the common 2-D case (N=1), the block structure can be visualized::\n\n    [[ a[0,0]*b,   a[0,1]*b,  ... , a[0,-1]*b  ],\n     [  ...                              ...   ],\n     [ a[-1,0]*b,  a[-1,1]*b, ... , a[-1,-1]*b ]]\n\n\nExamples\n--------\n>>> import numpy as np\n>>> np.kron([1,10,100], [5,6,7])\narray([  5,   6,   7, ..., 500, 600, 700])\n>>> np.kron([5,6,7], [1,10,100])\narray([  5,  50, 500, ...,   7,  70, 700])\n\n>>> np.kron(np.eye(2), np.ones((2,2)))\narray([[1.,  1.,  0.,  0.],\n       [1.,  1.,  0.,  0.],\n       [0.,  0.,  1.,  1.],\n       [0.,  0.,  1.,  1.]])\n\n>>> a = np.arange(100).reshape((2,5,2,5))\n>>> b = np.arange(24).reshape((2,3,4))\n>>> c = np.kron(a,b)\n>>> c.shape\n(2, 10, 6, 20)\n>>> I = (1,3,0,2)\n>>> J = (0,2,1)\n>>> J1 = (0,) + J             # extend to ndim=4\n>>> S1 = (1,) + b.shape\n>>> K = tuple(np.array(I) * np.array(S1) + np.array(J1))\n>>> c[K] == a[I]*b[J]\nTrue"
    },
    {
      "name": "tile",
      "docstring": "Construct an array by repeating A the number of times given by reps.\n\nIf `reps` has length ``d``, the result will have dimension of\n``max(d, A.ndim)``.\n\nIf ``A.ndim < d``, `A` is promoted to be d-dimensional by prepending new\naxes. So a shape (3,) array is promoted to (1, 3) for 2-D replication,\nor shape (1, 1, 3) for 3-D replication. If this is not the desired\nbehavior, promote `A` to d-dimensions manually before calling this\nfunction.\n\nIf ``A.ndim > d``, `reps` is promoted to `A`.ndim by prepending 1's to it.\nThus for an `A` of shape (2, 3, 4, 5), a `reps` of (2, 2) is treated as\n(1, 1, 2, 2).\n\nNote : Although tile may be used for broadcasting, it is strongly\nrecommended to use numpy's broadcasting operations and functions.\n\nParameters\n----------\nA : array_like\n    The input array.\nreps : array_like\n    The number of repetitions of `A` along each axis.\n\nReturns\n-------\nc : ndarray\n    The tiled output array.\n\nSee Also\n--------\nrepeat : Repeat elements of an array.\nbroadcast_to : Broadcast an array to a new shape\n\nExamples\n--------\n>>> import numpy as np\n>>> a = np.array([0, 1, 2])\n>>> np.tile(a, 2)\narray([0, 1, 2, 0, 1, 2])\n>>> np.tile(a, (2, 2))\narray([[0, 1, 2, 0, 1, 2],\n       [0, 1, 2, 0, 1, 2]])\n>>> np.tile(a, (2, 1, 2))\narray([[[0, 1, 2, 0, 1, 2]],\n       [[0, 1, 2, 0, 1, 2]]])\n\n>>> b = np.array([[1, 2], [3, 4]])\n>>> np.tile(b, 2)\narray([[1, 2, 1, 2],\n       [3, 4, 3, 4]])\n>>> np.tile(b, (2, 1))\narray([[1, 2],\n       [3, 4],\n       [1, 2],\n       [3, 4]])\n\n>>> c = np.array([1,2,3,4])\n>>> np.tile(c,(4,1))\narray([[1, 2, 3, 4],\n       [1, 2, 3, 4],\n       [1, 2, 3, 4],\n       [1, 2, 3, 4]])"
    }
  ],
  "innovations": []
}