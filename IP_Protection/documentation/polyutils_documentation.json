{
  "file_path": "c:\\Users\\sgbil\\OneDrive\\Desktop\\Negative_Space_Imaging_Project\\.venv\\Lib\\site-packages\\numpy\\polynomial\\polyutils.py",
  "classes": [],
  "functions": [
    {
      "name": "trimseq",
      "docstring": "Remove small Poly series coefficients.\n\nParameters\n----------\nseq : sequence\n    Sequence of Poly series coefficients.\n\nReturns\n-------\nseries : sequence\n    Subsequence with trailing zeros removed. If the resulting sequence\n    would be empty, return the first element. The returned sequence may\n    or may not be a view.\n\nNotes\n-----\nDo not lose the type info if the sequence contains unknown objects."
    },
    {
      "name": "as_series",
      "docstring": "Return argument as a list of 1-d arrays.\n\nThe returned list contains array(s) of dtype double, complex double, or\nobject.  A 1-d argument of shape ``(N,)`` is parsed into ``N`` arrays of\nsize one; a 2-d argument of shape ``(M,N)`` is parsed into ``M`` arrays\nof size ``N`` (i.e., is \"parsed by row\"); and a higher dimensional array\nraises a Value Error if it is not first reshaped into either a 1-d or 2-d\narray.\n\nParameters\n----------\nalist : array_like\n    A 1- or 2-d array_like\ntrim : boolean, optional\n    When True, trailing zeros are removed from the inputs.\n    When False, the inputs are passed through intact.\n\nReturns\n-------\n[a1, a2,...] : list of 1-D arrays\n    A copy of the input data as a list of 1-d arrays.\n\nRaises\n------\nValueError\n    Raised when `as_series` cannot convert its input to 1-d arrays, or at\n    least one of the resulting arrays is empty.\n\nExamples\n--------\n>>> import numpy as np\n>>> from numpy.polynomial import polyutils as pu\n>>> a = np.arange(4)\n>>> pu.as_series(a)\n[array([0.]), array([1.]), array([2.]), array([3.])]\n>>> b = np.arange(6).reshape((2,3))\n>>> pu.as_series(b)\n[array([0., 1., 2.]), array([3., 4., 5.])]\n\n>>> pu.as_series((1, np.arange(3), np.arange(2, dtype=np.float16)))\n[array([1.]), array([0., 1., 2.]), array([0., 1.])]\n\n>>> pu.as_series([2, [1.1, 0.]])\n[array([2.]), array([1.1])]\n\n>>> pu.as_series([2, [1.1, 0.]], trim=False)\n[array([2.]), array([1.1, 0. ])]"
    },
    {
      "name": "trimcoef",
      "docstring": "Remove \"small\" \"trailing\" coefficients from a polynomial.\n\n\"Small\" means \"small in absolute value\" and is controlled by the\nparameter `tol`; \"trailing\" means highest order coefficient(s), e.g., in\n``[0, 1, 1, 0, 0]`` (which represents ``0 + x + x**2 + 0*x**3 + 0*x**4``)\nboth the 3-rd and 4-th order coefficients would be \"trimmed.\"\n\nParameters\n----------\nc : array_like\n    1-d array of coefficients, ordered from lowest order to highest.\ntol : number, optional\n    Trailing (i.e., highest order) elements with absolute value less\n    than or equal to `tol` (default value is zero) are removed.\n\nReturns\n-------\ntrimmed : ndarray\n    1-d array with trailing zeros removed.  If the resulting series\n    would be empty, a series containing a single zero is returned.\n\nRaises\n------\nValueError\n    If `tol` < 0\n\nExamples\n--------\n>>> from numpy.polynomial import polyutils as pu\n>>> pu.trimcoef((0,0,3,0,5,0,0))\narray([0.,  0.,  3.,  0.,  5.])\n>>> pu.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed\narray([0.])\n>>> i = complex(0,1) # works for complex\n>>> pu.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)\narray([0.0003+0.j   , 0.001 -0.001j])"
    },
    {
      "name": "getdomain",
      "docstring": "Return a domain suitable for given abscissae.\n\nFind a domain suitable for a polynomial or Chebyshev series\ndefined at the values supplied.\n\nParameters\n----------\nx : array_like\n    1-d array of abscissae whose domain will be determined.\n\nReturns\n-------\ndomain : ndarray\n    1-d array containing two values.  If the inputs are complex, then\n    the two returned points are the lower left and upper right corners\n    of the smallest rectangle (aligned with the axes) in the complex\n    plane containing the points `x`. If the inputs are real, then the\n    two points are the ends of the smallest interval containing the\n    points `x`.\n\nSee Also\n--------\nmapparms, mapdomain\n\nExamples\n--------\n>>> import numpy as np\n>>> from numpy.polynomial import polyutils as pu\n>>> points = np.arange(4)**2 - 5; points\narray([-5, -4, -1,  4])\n>>> pu.getdomain(points)\narray([-5.,  4.])\n>>> c = np.exp(complex(0,1)*np.pi*np.arange(12)/6) # unit circle\n>>> pu.getdomain(c)\narray([-1.-1.j,  1.+1.j])"
    },
    {
      "name": "mapparms",
      "docstring": "Linear map parameters between domains.\n\nReturn the parameters of the linear map ``offset + scale*x`` that maps\n`old` to `new` such that ``old[i] -> new[i]``, ``i = 0, 1``.\n\nParameters\n----------\nold, new : array_like\n    Domains. Each domain must (successfully) convert to a 1-d array\n    containing precisely two values.\n\nReturns\n-------\noffset, scale : scalars\n    The map ``L(x) = offset + scale*x`` maps the first domain to the\n    second.\n\nSee Also\n--------\ngetdomain, mapdomain\n\nNotes\n-----\nAlso works for complex numbers, and thus can be used to calculate the\nparameters required to map any line in the complex plane to any other\nline therein.\n\nExamples\n--------\n>>> from numpy.polynomial import polyutils as pu\n>>> pu.mapparms((-1,1),(-1,1))\n(0.0, 1.0)\n>>> pu.mapparms((1,-1),(-1,1))\n(-0.0, -1.0)\n>>> i = complex(0,1)\n>>> pu.mapparms((-i,-1),(1,i))\n((1+1j), (1-0j))"
    },
    {
      "name": "mapdomain",
      "docstring": "Apply linear map to input points.\n\nThe linear map ``offset + scale*x`` that maps the domain `old` to\nthe domain `new` is applied to the points `x`.\n\nParameters\n----------\nx : array_like\n    Points to be mapped. If `x` is a subtype of ndarray the subtype\n    will be preserved.\nold, new : array_like\n    The two domains that determine the map.  Each must (successfully)\n    convert to 1-d arrays containing precisely two values.\n\nReturns\n-------\nx_out : ndarray\n    Array of points of the same shape as `x`, after application of the\n    linear map between the two domains.\n\nSee Also\n--------\ngetdomain, mapparms\n\nNotes\n-----\nEffectively, this implements:\n\n.. math::\n    x\\_out = new[0] + m(x - old[0])\n\nwhere\n\n.. math::\n    m = \\frac{new[1]-new[0]}{old[1]-old[0]}\n\nExamples\n--------\n>>> import numpy as np\n>>> from numpy.polynomial import polyutils as pu\n>>> old_domain = (-1,1)\n>>> new_domain = (0,2*np.pi)\n>>> x = np.linspace(-1,1,6); x\narray([-1. , -0.6, -0.2,  0.2,  0.6,  1. ])\n>>> x_out = pu.mapdomain(x, old_domain, new_domain); x_out\narray([ 0.        ,  1.25663706,  2.51327412,  3.76991118,  5.02654825, # may vary\n        6.28318531])\n>>> x - pu.mapdomain(x_out, new_domain, old_domain)\narray([0., 0., 0., 0., 0., 0.])\n\nAlso works for complex numbers (and thus can be used to map any line in\nthe complex plane to any other line therein).\n\n>>> i = complex(0,1)\n>>> old = (-1 - i, 1 + i)\n>>> new = (-1 + i, 1 - i)\n>>> z = np.linspace(old[0], old[1], 6); z\narray([-1. -1.j , -0.6-0.6j, -0.2-0.2j,  0.2+0.2j,  0.6+0.6j,  1. +1.j ])\n>>> new_z = pu.mapdomain(z, old, new); new_z\narray([-1.0+1.j , -0.6+0.6j, -0.2+0.2j,  0.2-0.2j,  0.6-0.6j,  1.0-1.j ]) # may vary"
    },
    {
      "name": "format_float",
      "docstring": null
    }
  ],
  "innovations": []
}