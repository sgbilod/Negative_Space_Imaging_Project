{
  "file_path": "c:\\Users\\sgbil\\OneDrive\\Desktop\\Negative_Space_Imaging_Project\\.venv\\Lib\\site-packages\\pywt\\_cwt.py",
  "classes": [],
  "functions": [
    {
      "name": "next_fast_len",
      "docstring": "Round up size to the nearest power of two.\n\nGiven a number of samples `n`, returns the next power of two\nfollowing this number to take advantage of FFT speedup."
    },
    {
      "name": "cwt",
      "docstring": "One dimensional Continuous Wavelet Transform.\n\nParameters\n----------\ndata : array_like\n    Input signal\nscales : array_like\n    The wavelet scales to use. One can use\n    ``f = scale2frequency(wavelet, scale)/sampling_period`` to determine\n    what physical frequency, ``f``. Here, ``f`` is in hertz when the\n    ``sampling_period`` is given in seconds.\nwavelet : Wavelet object or name\n    Wavelet to use\nsampling_period : float\n    Sampling period for the frequencies output (optional).\n    The values computed for ``coefs`` are independent of the choice of\n    ``sampling_period`` (i.e. ``scales`` is not scaled by the sampling\n    period).\nmethod : {'conv', 'fft'}, optional\n    The method used to compute the CWT. Can be any of:\n        - ``conv`` uses ``numpy.convolve``.\n        - ``fft`` uses frequency domain convolution.\n        - ``auto`` uses automatic selection based on an estimate of the\n          computational complexity at each scale.\n\n    The ``conv`` method complexity is ``O(len(scale) * len(data))``.\n    The ``fft`` method is ``O(N * log2(N))`` with\n    ``N = len(scale) + len(data) - 1``. It is well suited for large size\n    signals but slightly slower than ``conv`` on small ones.\naxis: int, optional\n    Axis over which to compute the CWT. If not given, the last axis is\n    used.\nprecision: int, optional\n    Length of wavelet (``2 ** precision``) used to compute the CWT. Greater\n    will increase resolution, especially for higher scales, but will\n    compute a bit slower. Too low will distort coefficients and their\n    norms, with a zipper-like effect. The default is 12, it's recommended\n    to use >=12.\n\nReturns\n-------\ncoefs : array_like\n    Continuous wavelet transform of the input signal for the given scales\n    and wavelet. The first axis of ``coefs`` corresponds to the scales.\n    The remaining axes match the shape of ``data``.\nfrequencies : array_like\n    If the unit of sampling period are seconds and given, then frequencies\n    are in hertz. Otherwise, a sampling period of 1 is assumed.\n\nNotes\n-----\nSize of coefficients arrays depends on the length of the input array and\nthe length of given scales.\n\nExamples\n--------\n>>> import pywt\n>>> import numpy as np\n>>> import matplotlib.pyplot as plt\n>>> x = np.exp(np.linspace(0, 2, 512))\n>>> y = np.cos(2*np.pi*x)  # exponential chirp\n>>> scales = np.logspace(np.log10(1), np.log10(128), 128)\n>>> coef, freqs = pywt.cwt(y, scales, 'gaus1')\n>>> plt.matshow(coef)\n>>> plt.show()\n\n>>> import pywt\n>>> import numpy as np\n>>> import matplotlib.pyplot as plt\n>>> t = np.linspace(-1, 1, 200, endpoint=False)\n>>> sig  = np.cos(2 * np.pi * 7 * t) + np.real(np.exp(-7*(t-0.4)**2)*np.exp(1j*2*np.pi*2*(t-0.4)))\n>>> widths = np.logspace(np.log10(1), np.log10(30), 30)\n>>> cwtmatr, freqs = pywt.cwt(sig, widths, 'mexh')\n>>> plt.imshow(cwtmatr, extent=[-1, 1, 1, 31], cmap='PRGn', aspect='auto',\n...            vmax=abs(cwtmatr).max(), vmin=-abs(cwtmatr).max())\n>>> plt.show()"
    }
  ],
  "innovations": []
}