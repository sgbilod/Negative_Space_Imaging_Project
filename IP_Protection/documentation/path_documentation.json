{
  "file_path": "c:\\Users\\sgbil\\OneDrive\\Desktop\\Negative_Space_Imaging_Project\\.venv\\Lib\\site-packages\\matplotlib\\path.py",
  "classes": [
    {
      "name": "Path",
      "docstring": "A series of possibly disconnected, possibly closed, line and curve\nsegments.\n\nThe underlying storage is made up of two parallel numpy arrays:\n\n- *vertices*: an (N, 2) float array of vertices\n- *codes*: an N-length `numpy.uint8` array of path codes, or None\n\nThese two arrays always have the same length in the first\ndimension.  For example, to represent a cubic curve, you must\nprovide three vertices and three `CURVE4` codes.\n\nThe code types are:\n\n- `STOP`   :  1 vertex (ignored)\n    A marker for the end of the entire path (currently not required and\n    ignored)\n\n- `MOVETO` :  1 vertex\n    Pick up the pen and move to the given vertex.\n\n- `LINETO` :  1 vertex\n    Draw a line from the current position to the given vertex.\n\n- `CURVE3` :  1 control point, 1 endpoint\n    Draw a quadratic B\u00e9zier curve from the current position, with the given\n    control point, to the given end point.\n\n- `CURVE4` :  2 control points, 1 endpoint\n    Draw a cubic B\u00e9zier curve from the current position, with the given\n    control points, to the given end point.\n\n- `CLOSEPOLY` : 1 vertex (ignored)\n    Draw a line segment to the start point of the current polyline.\n\nIf *codes* is None, it is interpreted as a `MOVETO` followed by a series\nof `LINETO`.\n\nUsers of Path objects should not access the vertices and codes arrays\ndirectly.  Instead, they should use `iter_segments` or `cleaned` to get the\nvertex/code pairs.  This helps, in particular, to consistently handle the\ncase of *codes* being None.\n\nSome behavior of Path objects can be controlled by rcParams. See the\nrcParams whose keys start with 'path.'.\n\n.. note::\n\n    The vertices and codes arrays should be treated as\n    immutable -- there are a number of optimizations and assumptions\n    made up front in the constructor that will not change when the\n    data changes.",
      "methods": [
        {
          "name": "__init__",
          "docstring": "Create a new path with the given vertices and codes.\n\nParameters\n----------\nvertices : (N, 2) array-like\n    The path vertices, as an array, masked array or sequence of pairs.\n    Masked values, if any, will be converted to NaNs, which are then\n    handled correctly by the Agg PathIterator and other consumers of\n    path data, such as :meth:`iter_segments`.\ncodes : array-like or None, optional\n    N-length array of integers representing the codes of the path.\n    If not None, codes must be the same length as vertices.\n    If None, *vertices* will be treated as a series of line segments.\n_interpolation_steps : int, optional\n    Used as a hint to certain projections, such as Polar, that this\n    path should be linearly interpolated immediately before drawing.\n    This attribute is primarily an implementation detail and is not\n    intended for public use.\nclosed : bool, optional\n    If *codes* is None and closed is True, vertices will be treated as\n    line segments of a closed polygon.  Note that the last vertex will\n    then be ignored (as the corresponding code will be set to\n    `CLOSEPOLY`).\nreadonly : bool, optional\n    Makes the path behave in an immutable way and sets the vertices\n    and codes as read-only arrays."
        },
        {
          "name": "vertices",
          "docstring": "The vertices of the `Path` as an (N, 2) array."
        },
        {
          "name": "vertices",
          "docstring": null
        },
        {
          "name": "codes",
          "docstring": "The list of codes in the `Path` as a 1D array.\n\nEach code is one of `STOP`, `MOVETO`, `LINETO`, `CURVE3`, `CURVE4` or\n`CLOSEPOLY`.  For codes that correspond to more than one vertex\n(`CURVE3` and `CURVE4`), that code will be repeated so that the length\nof `vertices` and `codes` is always the same."
        },
        {
          "name": "codes",
          "docstring": null
        },
        {
          "name": "simplify_threshold",
          "docstring": "The fraction of a pixel difference below which vertices will\nbe simplified out."
        },
        {
          "name": "simplify_threshold",
          "docstring": null
        },
        {
          "name": "should_simplify",
          "docstring": "`True` if the vertices array should be simplified."
        },
        {
          "name": "should_simplify",
          "docstring": null
        },
        {
          "name": "readonly",
          "docstring": "`True` if the `Path` is read-only."
        },
        {
          "name": "copy",
          "docstring": "Return a shallow copy of the `Path`, which will share the\nvertices and codes with the source `Path`."
        },
        {
          "name": "deepcopy",
          "docstring": "Return a deep copy of the `Path`.  The `Path` will not be readonly,\neven if the source `Path` is.\n\nParameters\n----------\nmemo : dict, optional\n    A dictionary to use for memoizing, passed to `copy.deepcopy`.\n\nReturns\n-------\nPath\n    A deep copy of the `Path`, but not readonly."
        },
        {
          "name": "make_compound_path_from_polys",
          "docstring": "Make a compound `Path` object to draw a number of polygons with equal\nnumbers of sides.\n\n.. plot:: gallery/misc/histogram_path.py\n\nParameters\n----------\nXY : (numpolys, numsides, 2) array"
        },
        {
          "name": "make_compound_path",
          "docstring": "Concatenate a list of `Path`\\s into a single `Path`, removing all `STOP`\\s."
        },
        {
          "name": "iter_segments",
          "docstring": "Iterate over all curve segments in the path.\n\nEach iteration returns a pair ``(vertices, code)``, where ``vertices``\nis a sequence of 1-3 coordinate pairs, and ``code`` is a `Path` code.\n\nAdditionally, this method can provide a number of standard cleanups and\nconversions to the path.\n\nParameters\n----------\ntransform : None or :class:`~matplotlib.transforms.Transform`\n    If not None, the given affine transformation will be applied to the\n    path.\nremove_nans : bool, optional\n    Whether to remove all NaNs from the path and skip over them using\n    MOVETO commands.\nclip : None or (float, float, float, float), optional\n    If not None, must be a four-tuple (x1, y1, x2, y2)\n    defining a rectangle in which to clip the path.\nsnap : None or bool, optional\n    If True, snap all nodes to pixels; if False, don't snap them.\n    If None, snap if the path contains only segments\n    parallel to the x or y axes, and no more than 1024 of them.\nstroke_width : float, optional\n    The width of the stroke being drawn (used for path snapping).\nsimplify : None or bool, optional\n    Whether to simplify the path by removing vertices\n    that do not affect its appearance.  If None, use the\n    :attr:`should_simplify` attribute.  See also :rc:`path.simplify`\n    and :rc:`path.simplify_threshold`.\ncurves : bool, optional\n    If True, curve segments will be returned as curve segments.\n    If False, all curves will be converted to line segments.\nsketch : None or sequence, optional\n    If not None, must be a 3-tuple of the form\n    (scale, length, randomness), representing the sketch parameters."
        },
        {
          "name": "iter_bezier",
          "docstring": "Iterate over each B\u00e9zier curve (lines included) in a `Path`.\n\nParameters\n----------\n**kwargs\n    Forwarded to `.iter_segments`.\n\nYields\n------\nB : `~matplotlib.bezier.BezierSegment`\n    The B\u00e9zier curves that make up the current path. Note in particular\n    that freestanding points are B\u00e9zier curves of order 0, and lines\n    are B\u00e9zier curves of order 1 (with two control points).\ncode : `~matplotlib.path.Path.code_type`\n    The code describing what kind of curve is being returned.\n    `MOVETO`, `LINETO`, `CURVE3`, and `CURVE4` correspond to\n    B\u00e9zier curves with 1, 2, 3, and 4 control points (respectively).\n    `CLOSEPOLY` is a `LINETO` with the control points correctly\n    chosen based on the start/end points of the current stroke."
        },
        {
          "name": "cleaned",
          "docstring": "Return a new `Path` with vertices and codes cleaned according to the\nparameters.\n\nSee Also\n--------\nPath.iter_segments : for details of the keyword arguments."
        },
        {
          "name": "transformed",
          "docstring": "Return a transformed copy of the path.\n\nSee Also\n--------\nmatplotlib.transforms.TransformedPath\n    A specialized path class that will cache the transformed result and\n    automatically update when the transform changes."
        },
        {
          "name": "contains_point",
          "docstring": "Return whether the area enclosed by the path contains the given point.\n\nThe path is always treated as closed; i.e. if the last code is not\n`CLOSEPOLY` an implicit segment connecting the last vertex to the first\nvertex is assumed.\n\nParameters\n----------\npoint : (float, float)\n    The point (x, y) to check.\ntransform : `~matplotlib.transforms.Transform`, optional\n    If not ``None``, *point* will be compared to ``self`` transformed\n    by *transform*; i.e. for a correct check, *transform* should\n    transform the path into the coordinate system of *point*.\nradius : float, default: 0\n    Additional margin on the path in coordinates of *point*.\n    The path is extended tangentially by *radius/2*; i.e. if you would\n    draw the path with a linewidth of *radius*, all points on the line\n    would still be considered to be contained in the area. Conversely,\n    negative values shrink the area: Points on the imaginary line\n    will be considered outside the area.\n\nReturns\n-------\nbool\n\nNotes\n-----\nThe current algorithm has some limitations:\n\n- The result is undefined for points exactly at the boundary\n  (i.e. at the path shifted by *radius/2*).\n- The result is undefined if there is no enclosed area, i.e. all\n  vertices are on a straight line.\n- If bounding lines start to cross each other due to *radius* shift,\n  the result is not guaranteed to be correct."
        },
        {
          "name": "contains_points",
          "docstring": "Return whether the area enclosed by the path contains the given points.\n\nThe path is always treated as closed; i.e. if the last code is not\n`CLOSEPOLY` an implicit segment connecting the last vertex to the first\nvertex is assumed.\n\nParameters\n----------\npoints : (N, 2) array\n    The points to check. Columns contain x and y values.\ntransform : `~matplotlib.transforms.Transform`, optional\n    If not ``None``, *points* will be compared to ``self`` transformed\n    by *transform*; i.e. for a correct check, *transform* should\n    transform the path into the coordinate system of *points*.\nradius : float, default: 0\n    Additional margin on the path in coordinates of *points*.\n    The path is extended tangentially by *radius/2*; i.e. if you would\n    draw the path with a linewidth of *radius*, all points on the line\n    would still be considered to be contained in the area. Conversely,\n    negative values shrink the area: Points on the imaginary line\n    will be considered outside the area.\n\nReturns\n-------\nlength-N bool array\n\nNotes\n-----\nThe current algorithm has some limitations:\n\n- The result is undefined for points exactly at the boundary\n  (i.e. at the path shifted by *radius/2*).\n- The result is undefined if there is no enclosed area, i.e. all\n  vertices are on a straight line.\n- If bounding lines start to cross each other due to *radius* shift,\n  the result is not guaranteed to be correct."
        },
        {
          "name": "contains_path",
          "docstring": "Return whether this (closed) path completely contains the given path.\n\nIf *transform* is not ``None``, the path will be transformed before\nchecking for containment."
        },
        {
          "name": "get_extents",
          "docstring": "Get Bbox of the path.\n\nParameters\n----------\ntransform : `~matplotlib.transforms.Transform`, optional\n    Transform to apply to path before computing extents, if any.\n**kwargs\n    Forwarded to `.iter_bezier`.\n\nReturns\n-------\nmatplotlib.transforms.Bbox\n    The extents of the path Bbox([[xmin, ymin], [xmax, ymax]])"
        },
        {
          "name": "intersects_path",
          "docstring": "Return whether if this path intersects another given path.\n\nIf *filled* is True, then this also returns True if one path completely\nencloses the other (i.e., the paths are treated as filled)."
        },
        {
          "name": "intersects_bbox",
          "docstring": "Return whether this path intersects a given `~.transforms.Bbox`.\n\nIf *filled* is True, then this also returns True if the path completely\nencloses the `.Bbox` (i.e., the path is treated as filled).\n\nThe bounding box is always considered filled."
        },
        {
          "name": "interpolated",
          "docstring": "Return a new path with each segment divided into *steps* parts.\n\nCodes other than `LINETO`, `MOVETO`, and `CLOSEPOLY` are not handled correctly.\n\nParameters\n----------\nsteps : int\n    The number of segments in the new path for each in the original.\n\nReturns\n-------\nPath\n    The interpolated path."
        },
        {
          "name": "to_polygons",
          "docstring": "Convert this path to a list of polygons or polylines.  Each\npolygon/polyline is an (N, 2) array of vertices.  In other words,\neach polygon has no `MOVETO` instructions or curves.  This\nis useful for displaying in backends that do not support\ncompound paths or B\u00e9zier curves.\n\nIf *width* and *height* are both non-zero then the lines will\nbe simplified so that vertices outside of (0, 0), (width,\nheight) will be clipped.\n\nThe resulting polygons will be simplified if the\n:attr:`Path.should_simplify` attribute of the path is `True`.\n\nIf *closed_only* is `True` (default), only closed polygons,\nwith the last point being the same as the first point, will be\nreturned.  Any unclosed polylines in the path will be\nexplicitly closed.  If *closed_only* is `False`, any unclosed\npolygons in the path will be returned as unclosed polygons,\nand the closed polygons will be returned explicitly closed by\nsetting the last point to the same as the first point."
        },
        {
          "name": "unit_rectangle",
          "docstring": "Return a `Path` instance of the unit rectangle from (0, 0) to (1, 1)."
        },
        {
          "name": "unit_regular_polygon",
          "docstring": "Return a :class:`Path` instance for a unit regular polygon with the\ngiven *numVertices* such that the circumscribing circle has radius 1.0,\ncentered at (0, 0)."
        },
        {
          "name": "unit_regular_star",
          "docstring": "Return a :class:`Path` for a unit regular star with the given\nnumVertices and radius of 1.0, centered at (0, 0)."
        },
        {
          "name": "unit_regular_asterisk",
          "docstring": "Return a :class:`Path` for a unit regular asterisk with the given\nnumVertices and radius of 1.0, centered at (0, 0)."
        },
        {
          "name": "unit_circle",
          "docstring": "Return the readonly :class:`Path` of the unit circle.\n\nFor most cases, :func:`Path.circle` will be what you want."
        },
        {
          "name": "circle",
          "docstring": "Return a `Path` representing a circle of a given radius and center.\n\nParameters\n----------\ncenter : (float, float), default: (0, 0)\n    The center of the circle.\nradius : float, default: 1\n    The radius of the circle.\nreadonly : bool\n    Whether the created path should have the \"readonly\" argument\n    set when creating the Path instance.\n\nNotes\n-----\nThe circle is approximated using 8 cubic B\u00e9zier curves, as described in\n\n  Lancaster, Don.  `Approximating a Circle or an Ellipse Using Four\n  Bezier Cubic Splines <https://www.tinaja.com/glib/ellipse4.pdf>`_."
        },
        {
          "name": "unit_circle_righthalf",
          "docstring": "Return a `Path` of the right half of a unit circle.\n\nSee `Path.circle` for the reference on the approximation used."
        },
        {
          "name": "arc",
          "docstring": "Return a `Path` for the unit circle arc from angles *theta1* to\n*theta2* (in degrees).\n\n*theta2* is unwrapped to produce the shortest arc within 360 degrees.\nThat is, if *theta2* > *theta1* + 360, the arc will be from *theta1* to\n*theta2* - 360 and not a full circle plus some extra overlap.\n\nIf *n* is provided, it is the number of spline segments to make.\nIf *n* is not provided, the number of spline segments is\ndetermined based on the delta between *theta1* and *theta2*.\n\n   Masionobe, L.  2003.  `Drawing an elliptical arc using\n   polylines, quadratic or cubic Bezier curves\n   <https://web.archive.org/web/20190318044212/http://www.spaceroots.org/documents/ellipse/index.html>`_."
        },
        {
          "name": "wedge",
          "docstring": "Return a `Path` for the unit circle wedge from angles *theta1* to\n*theta2* (in degrees).\n\n*theta2* is unwrapped to produce the shortest wedge within 360 degrees.\nThat is, if *theta2* > *theta1* + 360, the wedge will be from *theta1*\nto *theta2* - 360 and not a full circle plus some extra overlap.\n\nIf *n* is provided, it is the number of spline segments to make.\nIf *n* is not provided, the number of spline segments is\ndetermined based on the delta between *theta1* and *theta2*.\n\nSee `Path.arc` for the reference on the approximation used."
        },
        {
          "name": "hatch",
          "docstring": "Given a hatch specifier, *hatchpattern*, generates a `Path` that\ncan be used in a repeated hatching pattern.  *density* is the\nnumber of lines per unit square."
        },
        {
          "name": "clip_to_bbox",
          "docstring": "Clip the path to the given bounding box.\n\nThe path must be made up of one or more closed polygons.  This\nalgorithm will not behave correctly for unclosed paths.\n\nIf *inside* is `True`, clip to the inside of the box, otherwise\nto the outside of the box."
        }
      ]
    }
  ],
  "functions": [
    {
      "name": "get_path_collection_extents",
      "docstring": "Get bounding box of a `.PathCollection`\\s internal objects.\n\nThat is, given a sequence of `Path`\\s, `.Transform`\\s objects, and offsets, as found\nin a `.PathCollection`, return the bounding box that encapsulates all of them.\n\nParameters\n----------\nmaster_transform : `~matplotlib.transforms.Transform`\n    Global transformation applied to all paths.\npaths : list of `Path`\ntransforms : list of `~matplotlib.transforms.Affine2DBase`\n    If non-empty, this overrides *master_transform*.\noffsets : (N, 2) array-like\noffset_transform : `~matplotlib.transforms.Affine2DBase`\n    Transform applied to the offsets before offsetting the path.\n\nNotes\n-----\nThe way that *paths*, *transforms* and *offsets* are combined follows the same\nmethod as for collections: each is iterated over independently, so if you have 3\npaths (A, B, C), 2 transforms (\u03b1, \u03b2) and 1 offset (O), their combinations are as\nfollows:\n\n- (A, \u03b1, O)\n- (B, \u03b2, O)\n- (C, \u03b1, O)"
    },
    {
      "name": "vertices",
      "docstring": "The vertices of the `Path` as an (N, 2) array."
    },
    {
      "name": "vertices",
      "docstring": null
    },
    {
      "name": "codes",
      "docstring": "The list of codes in the `Path` as a 1D array.\n\nEach code is one of `STOP`, `MOVETO`, `LINETO`, `CURVE3`, `CURVE4` or\n`CLOSEPOLY`.  For codes that correspond to more than one vertex\n(`CURVE3` and `CURVE4`), that code will be repeated so that the length\nof `vertices` and `codes` is always the same."
    },
    {
      "name": "codes",
      "docstring": null
    },
    {
      "name": "simplify_threshold",
      "docstring": "The fraction of a pixel difference below which vertices will\nbe simplified out."
    },
    {
      "name": "simplify_threshold",
      "docstring": null
    },
    {
      "name": "should_simplify",
      "docstring": "`True` if the vertices array should be simplified."
    },
    {
      "name": "should_simplify",
      "docstring": null
    },
    {
      "name": "readonly",
      "docstring": "`True` if the `Path` is read-only."
    },
    {
      "name": "copy",
      "docstring": "Return a shallow copy of the `Path`, which will share the\nvertices and codes with the source `Path`."
    },
    {
      "name": "deepcopy",
      "docstring": "Return a deep copy of the `Path`.  The `Path` will not be readonly,\neven if the source `Path` is.\n\nParameters\n----------\nmemo : dict, optional\n    A dictionary to use for memoizing, passed to `copy.deepcopy`.\n\nReturns\n-------\nPath\n    A deep copy of the `Path`, but not readonly."
    },
    {
      "name": "make_compound_path_from_polys",
      "docstring": "Make a compound `Path` object to draw a number of polygons with equal\nnumbers of sides.\n\n.. plot:: gallery/misc/histogram_path.py\n\nParameters\n----------\nXY : (numpolys, numsides, 2) array"
    },
    {
      "name": "make_compound_path",
      "docstring": "Concatenate a list of `Path`\\s into a single `Path`, removing all `STOP`\\s."
    },
    {
      "name": "iter_segments",
      "docstring": "Iterate over all curve segments in the path.\n\nEach iteration returns a pair ``(vertices, code)``, where ``vertices``\nis a sequence of 1-3 coordinate pairs, and ``code`` is a `Path` code.\n\nAdditionally, this method can provide a number of standard cleanups and\nconversions to the path.\n\nParameters\n----------\ntransform : None or :class:`~matplotlib.transforms.Transform`\n    If not None, the given affine transformation will be applied to the\n    path.\nremove_nans : bool, optional\n    Whether to remove all NaNs from the path and skip over them using\n    MOVETO commands.\nclip : None or (float, float, float, float), optional\n    If not None, must be a four-tuple (x1, y1, x2, y2)\n    defining a rectangle in which to clip the path.\nsnap : None or bool, optional\n    If True, snap all nodes to pixels; if False, don't snap them.\n    If None, snap if the path contains only segments\n    parallel to the x or y axes, and no more than 1024 of them.\nstroke_width : float, optional\n    The width of the stroke being drawn (used for path snapping).\nsimplify : None or bool, optional\n    Whether to simplify the path by removing vertices\n    that do not affect its appearance.  If None, use the\n    :attr:`should_simplify` attribute.  See also :rc:`path.simplify`\n    and :rc:`path.simplify_threshold`.\ncurves : bool, optional\n    If True, curve segments will be returned as curve segments.\n    If False, all curves will be converted to line segments.\nsketch : None or sequence, optional\n    If not None, must be a 3-tuple of the form\n    (scale, length, randomness), representing the sketch parameters."
    },
    {
      "name": "iter_bezier",
      "docstring": "Iterate over each B\u00e9zier curve (lines included) in a `Path`.\n\nParameters\n----------\n**kwargs\n    Forwarded to `.iter_segments`.\n\nYields\n------\nB : `~matplotlib.bezier.BezierSegment`\n    The B\u00e9zier curves that make up the current path. Note in particular\n    that freestanding points are B\u00e9zier curves of order 0, and lines\n    are B\u00e9zier curves of order 1 (with two control points).\ncode : `~matplotlib.path.Path.code_type`\n    The code describing what kind of curve is being returned.\n    `MOVETO`, `LINETO`, `CURVE3`, and `CURVE4` correspond to\n    B\u00e9zier curves with 1, 2, 3, and 4 control points (respectively).\n    `CLOSEPOLY` is a `LINETO` with the control points correctly\n    chosen based on the start/end points of the current stroke."
    },
    {
      "name": "cleaned",
      "docstring": "Return a new `Path` with vertices and codes cleaned according to the\nparameters.\n\nSee Also\n--------\nPath.iter_segments : for details of the keyword arguments."
    },
    {
      "name": "transformed",
      "docstring": "Return a transformed copy of the path.\n\nSee Also\n--------\nmatplotlib.transforms.TransformedPath\n    A specialized path class that will cache the transformed result and\n    automatically update when the transform changes."
    },
    {
      "name": "contains_point",
      "docstring": "Return whether the area enclosed by the path contains the given point.\n\nThe path is always treated as closed; i.e. if the last code is not\n`CLOSEPOLY` an implicit segment connecting the last vertex to the first\nvertex is assumed.\n\nParameters\n----------\npoint : (float, float)\n    The point (x, y) to check.\ntransform : `~matplotlib.transforms.Transform`, optional\n    If not ``None``, *point* will be compared to ``self`` transformed\n    by *transform*; i.e. for a correct check, *transform* should\n    transform the path into the coordinate system of *point*.\nradius : float, default: 0\n    Additional margin on the path in coordinates of *point*.\n    The path is extended tangentially by *radius/2*; i.e. if you would\n    draw the path with a linewidth of *radius*, all points on the line\n    would still be considered to be contained in the area. Conversely,\n    negative values shrink the area: Points on the imaginary line\n    will be considered outside the area.\n\nReturns\n-------\nbool\n\nNotes\n-----\nThe current algorithm has some limitations:\n\n- The result is undefined for points exactly at the boundary\n  (i.e. at the path shifted by *radius/2*).\n- The result is undefined if there is no enclosed area, i.e. all\n  vertices are on a straight line.\n- If bounding lines start to cross each other due to *radius* shift,\n  the result is not guaranteed to be correct."
    },
    {
      "name": "contains_points",
      "docstring": "Return whether the area enclosed by the path contains the given points.\n\nThe path is always treated as closed; i.e. if the last code is not\n`CLOSEPOLY` an implicit segment connecting the last vertex to the first\nvertex is assumed.\n\nParameters\n----------\npoints : (N, 2) array\n    The points to check. Columns contain x and y values.\ntransform : `~matplotlib.transforms.Transform`, optional\n    If not ``None``, *points* will be compared to ``self`` transformed\n    by *transform*; i.e. for a correct check, *transform* should\n    transform the path into the coordinate system of *points*.\nradius : float, default: 0\n    Additional margin on the path in coordinates of *points*.\n    The path is extended tangentially by *radius/2*; i.e. if you would\n    draw the path with a linewidth of *radius*, all points on the line\n    would still be considered to be contained in the area. Conversely,\n    negative values shrink the area: Points on the imaginary line\n    will be considered outside the area.\n\nReturns\n-------\nlength-N bool array\n\nNotes\n-----\nThe current algorithm has some limitations:\n\n- The result is undefined for points exactly at the boundary\n  (i.e. at the path shifted by *radius/2*).\n- The result is undefined if there is no enclosed area, i.e. all\n  vertices are on a straight line.\n- If bounding lines start to cross each other due to *radius* shift,\n  the result is not guaranteed to be correct."
    },
    {
      "name": "contains_path",
      "docstring": "Return whether this (closed) path completely contains the given path.\n\nIf *transform* is not ``None``, the path will be transformed before\nchecking for containment."
    },
    {
      "name": "get_extents",
      "docstring": "Get Bbox of the path.\n\nParameters\n----------\ntransform : `~matplotlib.transforms.Transform`, optional\n    Transform to apply to path before computing extents, if any.\n**kwargs\n    Forwarded to `.iter_bezier`.\n\nReturns\n-------\nmatplotlib.transforms.Bbox\n    The extents of the path Bbox([[xmin, ymin], [xmax, ymax]])"
    },
    {
      "name": "intersects_path",
      "docstring": "Return whether if this path intersects another given path.\n\nIf *filled* is True, then this also returns True if one path completely\nencloses the other (i.e., the paths are treated as filled)."
    },
    {
      "name": "intersects_bbox",
      "docstring": "Return whether this path intersects a given `~.transforms.Bbox`.\n\nIf *filled* is True, then this also returns True if the path completely\nencloses the `.Bbox` (i.e., the path is treated as filled).\n\nThe bounding box is always considered filled."
    },
    {
      "name": "interpolated",
      "docstring": "Return a new path with each segment divided into *steps* parts.\n\nCodes other than `LINETO`, `MOVETO`, and `CLOSEPOLY` are not handled correctly.\n\nParameters\n----------\nsteps : int\n    The number of segments in the new path for each in the original.\n\nReturns\n-------\nPath\n    The interpolated path."
    },
    {
      "name": "to_polygons",
      "docstring": "Convert this path to a list of polygons or polylines.  Each\npolygon/polyline is an (N, 2) array of vertices.  In other words,\neach polygon has no `MOVETO` instructions or curves.  This\nis useful for displaying in backends that do not support\ncompound paths or B\u00e9zier curves.\n\nIf *width* and *height* are both non-zero then the lines will\nbe simplified so that vertices outside of (0, 0), (width,\nheight) will be clipped.\n\nThe resulting polygons will be simplified if the\n:attr:`Path.should_simplify` attribute of the path is `True`.\n\nIf *closed_only* is `True` (default), only closed polygons,\nwith the last point being the same as the first point, will be\nreturned.  Any unclosed polylines in the path will be\nexplicitly closed.  If *closed_only* is `False`, any unclosed\npolygons in the path will be returned as unclosed polygons,\nand the closed polygons will be returned explicitly closed by\nsetting the last point to the same as the first point."
    },
    {
      "name": "unit_rectangle",
      "docstring": "Return a `Path` instance of the unit rectangle from (0, 0) to (1, 1)."
    },
    {
      "name": "unit_regular_polygon",
      "docstring": "Return a :class:`Path` instance for a unit regular polygon with the\ngiven *numVertices* such that the circumscribing circle has radius 1.0,\ncentered at (0, 0)."
    },
    {
      "name": "unit_regular_star",
      "docstring": "Return a :class:`Path` for a unit regular star with the given\nnumVertices and radius of 1.0, centered at (0, 0)."
    },
    {
      "name": "unit_regular_asterisk",
      "docstring": "Return a :class:`Path` for a unit regular asterisk with the given\nnumVertices and radius of 1.0, centered at (0, 0)."
    },
    {
      "name": "unit_circle",
      "docstring": "Return the readonly :class:`Path` of the unit circle.\n\nFor most cases, :func:`Path.circle` will be what you want."
    },
    {
      "name": "circle",
      "docstring": "Return a `Path` representing a circle of a given radius and center.\n\nParameters\n----------\ncenter : (float, float), default: (0, 0)\n    The center of the circle.\nradius : float, default: 1\n    The radius of the circle.\nreadonly : bool\n    Whether the created path should have the \"readonly\" argument\n    set when creating the Path instance.\n\nNotes\n-----\nThe circle is approximated using 8 cubic B\u00e9zier curves, as described in\n\n  Lancaster, Don.  `Approximating a Circle or an Ellipse Using Four\n  Bezier Cubic Splines <https://www.tinaja.com/glib/ellipse4.pdf>`_."
    },
    {
      "name": "unit_circle_righthalf",
      "docstring": "Return a `Path` of the right half of a unit circle.\n\nSee `Path.circle` for the reference on the approximation used."
    },
    {
      "name": "arc",
      "docstring": "Return a `Path` for the unit circle arc from angles *theta1* to\n*theta2* (in degrees).\n\n*theta2* is unwrapped to produce the shortest arc within 360 degrees.\nThat is, if *theta2* > *theta1* + 360, the arc will be from *theta1* to\n*theta2* - 360 and not a full circle plus some extra overlap.\n\nIf *n* is provided, it is the number of spline segments to make.\nIf *n* is not provided, the number of spline segments is\ndetermined based on the delta between *theta1* and *theta2*.\n\n   Masionobe, L.  2003.  `Drawing an elliptical arc using\n   polylines, quadratic or cubic Bezier curves\n   <https://web.archive.org/web/20190318044212/http://www.spaceroots.org/documents/ellipse/index.html>`_."
    },
    {
      "name": "wedge",
      "docstring": "Return a `Path` for the unit circle wedge from angles *theta1* to\n*theta2* (in degrees).\n\n*theta2* is unwrapped to produce the shortest wedge within 360 degrees.\nThat is, if *theta2* > *theta1* + 360, the wedge will be from *theta1*\nto *theta2* - 360 and not a full circle plus some extra overlap.\n\nIf *n* is provided, it is the number of spline segments to make.\nIf *n* is not provided, the number of spline segments is\ndetermined based on the delta between *theta1* and *theta2*.\n\nSee `Path.arc` for the reference on the approximation used."
    },
    {
      "name": "hatch",
      "docstring": "Given a hatch specifier, *hatchpattern*, generates a `Path` that\ncan be used in a repeated hatching pattern.  *density* is the\nnumber of lines per unit square."
    },
    {
      "name": "clip_to_bbox",
      "docstring": "Clip the path to the given bounding box.\n\nThe path must be made up of one or more closed polygons.  This\nalgorithm will not behave correctly for unclosed paths.\n\nIf *inside* is `True`, clip to the inside of the box, otherwise\nto the outside of the box."
    }
  ],
  "innovations": [
    {
      "type": "potential_innovation",
      "marker": "optimization",
      "context": "    .. note::\n\n        The vertices and codes arrays should be treated as\n        immutable -- there are a number of optimizations and assumptions\n        made up front in the constructor that will not change when the\n        data changes.\n    \"\"\""
    }
  ]
}