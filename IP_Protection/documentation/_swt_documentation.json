{
  "file_path": "c:\\Users\\sgbil\\OneDrive\\Desktop\\Negative_Space_Imaging_Project\\.venv\\Lib\\site-packages\\pywt\\_swt.py",
  "classes": [],
  "functions": [
    {
      "name": "swt",
      "docstring": "Multilevel 1D stationary wavelet transform.\n\nParameters\n----------\ndata :\n    Input signal\nwavelet :\n    Wavelet to use (Wavelet object or name)\nlevel : int, optional\n    The number of decomposition steps to perform.\nstart_level : int, optional\n    The level at which the decomposition will begin (it allows one to\n    skip a given number of transform steps and compute\n    coefficients starting from start_level) (default: 0)\naxis: int, optional\n    Axis over which to compute the SWT. If not given, the\n    last axis is used.\ntrim_approx : bool, optional\n    If True, approximation coefficients at the final level are retained.\nnorm : bool, optional\n    If True, transform is normalized so that the energy of the coefficients\n    will be equal to the energy of ``data``. In other words,\n    ``np.linalg.norm(data.ravel())`` will equal the norm of the\n    concatenated transform coefficients when ``trim_approx`` is True.\n\nReturns\n-------\ncoeffs : list\n    List of approximation and details coefficients pairs in order\n    similar to wavedec function::\n\n        [(cAn, cDn), ..., (cA2, cD2), (cA1, cD1)]\n\n    where n equals input parameter ``level``.\n\n    If ``start_level = m`` is given, then the beginning m steps are\n    skipped::\n\n        [(cAm+n, cDm+n), ..., (cAm+1, cDm+1), (cAm, cDm)]\n\n    If ``trim_approx`` is ``True``, then the output list is exactly as in\n    ``pywt.wavedec``, where the first coefficient in the list is the\n    approximation coefficient at the final level and the rest are the\n    detail coefficients::\n\n        [cAn, cDn, ..., cD2, cD1]\n\nNotes\n-----\nThe implementation here follows the \"algorithm a-trous\" and requires that\nthe signal length along the transformed axis be a multiple of ``2**level``.\nIf this is not the case, the user should pad up to an appropriate size\nusing a function such as ``numpy.pad``.\n\nA primary benefit of this transform in comparison to its decimated\ncounterpart (``pywt.wavedecn``), is that it is shift-invariant. This comes\nat cost of redundancy in the transform (the size of the output coefficients\nis larger than the input).\n\nWhen the following three conditions are true:\n\n    1. The wavelet is orthogonal\n    2. ``swt`` is called with ``norm=True``\n    3. ``swt`` is called with ``trim_approx=True``\n\nthe transform has the following additional properties that may be\ndesirable in applications:\n\n    1. energy is conserved\n    2. variance is partitioned across scales\n\nWhen used with ``norm=True``, this transform is closely related to the\nmultiple-overlap DWT (MODWT) as popularized for time-series analysis,\nalthough the underlying implementation is slightly different from the one\npublished in [1]_. Specifically, the implementation used here requires a\nsignal that is a multiple of ``2**level`` in length.\n\nReferences\n----------\n.. [1] DB Percival and AT Walden. Wavelet Methods for Time Series Analysis.\n    Cambridge University Press, 2000."
    },
    {
      "name": "iswt",
      "docstring": "Multilevel 1D inverse discrete stationary wavelet transform.\n\nParameters\n----------\ncoeffs : array_like\n    Coefficients list of tuples::\n\n        [(cAn, cDn), ..., (cA2, cD2), (cA1, cD1)]\n\n    where cA is approximation, cD is details.  Index 1 corresponds to\n    ``start_level`` from ``pywt.swt``.\nwavelet : Wavelet object or name string\n    Wavelet to use\nnorm : bool, optional\n    Controls the normalization used by the inverse transform. This must\n    be set equal to the value that was used by ``pywt.swt`` to preserve the\n    energy of a round-trip transform.\n\nReturns\n-------\n1D array of reconstructed data.\n\nExamples\n--------\n>>> import pywt\n>>> coeffs = pywt.swt([1,2,3,4,5,6,7,8], 'db2', level=2)\n>>> pywt.iswt(coeffs, 'db2')\narray([ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.])"
    },
    {
      "name": "swt2",
      "docstring": "Multilevel 2D stationary wavelet transform.\n\nParameters\n----------\ndata : array_like\n    2D array with input data\nwavelet : Wavelet object or name string, or 2-tuple of wavelets\n    Wavelet to use.  This can also be a tuple of wavelets to apply per\n    axis in ``axes``.\nlevel : int\n    The number of decomposition steps to perform.\nstart_level : int, optional\n    The level at which the decomposition will start (default: 0)\naxes : 2-tuple of ints, optional\n    Axes over which to compute the SWT. Repeated elements are not allowed.\ntrim_approx : bool, optional\n    If True, approximation coefficients at the final level are retained.\nnorm : bool, optional\n    If True, transform is normalized so that the energy of the coefficients\n    will be equal to the energy of ``data``. In other words,\n    ``np.linalg.norm(data.ravel())`` will equal the norm of the\n    concatenated transform coefficients when ``trim_approx`` is True.\n\nReturns\n-------\ncoeffs : list\n    Approximation and details coefficients (for ``start_level = m``).\n    If ``trim_approx`` is ``False``, approximation coefficients are\n    retained for all levels::\n\n        [\n            (cA_m+level,\n                (cH_m+level, cV_m+level, cD_m+level)\n            ),\n            ...,\n            (cA_m+1,\n                (cH_m+1, cV_m+1, cD_m+1)\n            ),\n            (cA_m,\n                (cH_m, cV_m, cD_m)\n            )\n        ]\n\n    where cA is approximation, cH is horizontal details, cV is\n    vertical details, cD is diagonal details and m is ``start_level``.\n\n    If ``trim_approx`` is ``True``, approximation coefficients are only\n    retained at the final level of decomposition. This matches the format\n    used by ``pywt.wavedec2``::\n\n        [\n            cA_m+level,\n            (cH_m+level, cV_m+level, cD_m+level),\n            ...,\n            (cH_m+1, cV_m+1, cD_m+1),\n            (cH_m, cV_m, cD_m),\n        ]\n\nNotes\n-----\nThe implementation here follows the \"algorithm a-trous\" and requires that\nthe signal length along the transformed axes be a multiple of ``2**level``.\nIf this is not the case, the user should pad up to an appropriate size\nusing a function such as ``numpy.pad``.\n\nA primary benefit of this transform in comparison to its decimated\ncounterpart (``pywt.wavedecn``), is that it is shift-invariant. This comes\nat cost of redundancy in the transform (the size of the output coefficients\nis larger than the input).\n\nWhen the following three conditions are true:\n\n    1. The wavelet is orthogonal\n    2. ``swt2`` is called with ``norm=True``\n    3. ``swt2`` is called with ``trim_approx=True``\n\nthe transform has the following additional properties that may be\ndesirable in applications:\n\n    1. energy is conserved\n    2. variance is partitioned across scales"
    },
    {
      "name": "iswt2",
      "docstring": "Multilevel 2D inverse discrete stationary wavelet transform.\n\nParameters\n----------\ncoeffs : list\n    Approximation and details coefficients::\n\n        [\n            (cA_n,\n                (cH_n, cV_n, cD_n)\n            ),\n            ...,\n            (cA_2,\n                (cH_2, cV_2, cD_2)\n            ),\n            (cA_1,\n                (cH_1, cV_1, cD_1)\n            )\n        ]\n\n    where cA is approximation, cH is horizontal details, cV is\n    vertical details, cD is diagonal details and n is the number of\n    levels.  Index 1 corresponds to ``start_level`` from ``pywt.swt2``.\nwavelet : Wavelet object or name string, or 2-tuple of wavelets\n    Wavelet to use.  This can also be a 2-tuple of wavelets to apply per\n    axis.\nnorm : bool, optional\n    Controls the normalization used by the inverse transform. This must\n    be set equal to the value that was used by ``pywt.swt2`` to preserve\n    the energy of a round-trip transform.\n\nReturns\n-------\n2D array of reconstructed data.\n\nExamples\n--------\n>>> import pywt\n>>> coeffs = pywt.swt2([[1,2,3,4],[5,6,7,8],\n...                     [9,10,11,12],[13,14,15,16]],\n...                    'db1', level=2)\n>>> pywt.iswt2(coeffs, 'db1')\narray([[  1.,   2.,   3.,   4.],\n       [  5.,   6.,   7.,   8.],\n       [  9.,  10.,  11.,  12.],\n       [ 13.,  14.,  15.,  16.]])"
    },
    {
      "name": "swtn",
      "docstring": "n-dimensional stationary wavelet transform.\n\nParameters\n----------\ndata : array_like\n    n-dimensional array with input data.\nwavelet : Wavelet object or name string, or tuple of wavelets\n    Wavelet to use.  This can also be a tuple of wavelets to apply per\n    axis in ``axes``.\nlevel : int\n    The number of decomposition steps to perform.\nstart_level : int, optional\n    The level at which the decomposition will start (default: 0)\naxes : sequence of ints, optional\n    Axes over which to compute the SWT. A value of ``None`` (the\n    default) selects all axes. Axes may not be repeated.\ntrim_approx : bool, optional\n    If True, approximation coefficients at the final level are retained.\nnorm : bool, optional\n    If True, transform is normalized so that the energy of the coefficients\n    will be equal to the energy of ``data``. In other words,\n    ``np.linalg.norm(data.ravel())`` will equal the norm of the\n    concatenated transform coefficients when ``trim_approx`` is True.\n\nReturns\n-------\n[{coeffs_level_n}, ..., {coeffs_level_1}]: list of dict\n    Results for each level are arranged in a dictionary, where the key\n    specifies the transform type on each dimension and value is a\n    n-dimensional coefficients array.\n\n    For example, for a 2D case the result at a given level will look\n    something like this::\n\n        {'aa': <coeffs>  # A(LL) - approx. on 1st dim, approx. on 2nd dim\n         'ad': <coeffs>  # V(LH) - approx. on 1st dim, det. on 2nd dim\n         'da': <coeffs>  # H(HL) - det. on 1st dim, approx. on 2nd dim\n         'dd': <coeffs>  # D(HH) - det. on 1st dim, det. on 2nd dim\n        }\n\n    For user-specified ``axes``, the order of the characters in the\n    dictionary keys map to the specified ``axes``.\n\n    If ``trim_approx`` is ``True``, the first element of the list contains\n    the array of approximation coefficients from the final level of\n    decomposition, while the remaining coefficient dictionaries contain\n    only detail coefficients. This matches the behavior of `pywt.wavedecn`.\n\nNotes\n-----\nThe implementation here follows the \"algorithm a-trous\" and requires that\nthe signal length along the transformed axes be a multiple of ``2**level``.\nIf this is not the case, the user should pad up to an appropriate size\nusing a function such as ``numpy.pad``.\n\nA primary benefit of this transform in comparison to its decimated\ncounterpart (``pywt.wavedecn``), is that it is shift-invariant. This comes\nat cost of redundancy in the transform (the size of the output coefficients\nis larger than the input).\n\nWhen the following three conditions are true:\n\n    1. The wavelet is orthogonal\n    2. ``swtn`` is called with ``norm=True``\n    3. ``swtn`` is called with ``trim_approx=True``\n\nthe transform has the following additional properties that may be\ndesirable in applications:\n\n    1. energy is conserved\n    2. variance is partitioned across scales"
    },
    {
      "name": "iswtn",
      "docstring": "Multilevel nD inverse discrete stationary wavelet transform.\n\nParameters\n----------\ncoeffs : list\n    [{coeffs_level_n}, ..., {coeffs_level_1}]: list of dict\nwavelet : Wavelet object or name string, or tuple of wavelets\n    Wavelet to use.  This can also be a tuple of wavelets to apply per\n    axis in ``axes``.\naxes : sequence of ints, optional\n    Axes over which to compute the inverse SWT. Axes may not be repeated.\n    The default is ``None``, which means transform all axes\n    (``axes = range(data.ndim)``).\nnorm : bool, optional\n    Controls the normalization used by the inverse transform. This must\n    be set equal to the value that was used by ``pywt.swtn`` to preserve\n    the energy of a round-trip transform.\n\nReturns\n-------\nnD array of reconstructed data.\n\nExamples\n--------\n>>> import pywt\n>>> coeffs = pywt.swtn([[1,2,3,4],[5,6,7,8],\n...                     [9,10,11,12],[13,14,15,16]],\n...                    'db1', level=2)\n>>> pywt.iswtn(coeffs, 'db1')\narray([[  1.,   2.,   3.,   4.],\n       [  5.,   6.,   7.,   8.],\n       [  9.,  10.,  11.,  12.],\n       [ 13.,  14.,  15.,  16.]])"
    }
  ],
  "innovations": []
}